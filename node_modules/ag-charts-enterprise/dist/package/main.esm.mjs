var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/ag-charts-enterprise/src/main.ts
import { AgCharts, time } from "ag-charts-community";

// packages/ag-charts-enterprise/src/setup.ts
import { _ModuleSupport as _ModuleSupport164 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxis.ts
import { _ModuleSupport as _ModuleSupport5, _Scale as _Scale2, _Util as _Util4 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/utils/polar.ts
function loopSymmetrically(items, step, iterator) {
  const loop = (start, end, loopStep, loopIterator) => {
    let prev = items[0];
    for (let i = start; loopStep > 0 ? i <= end : i > end; i += loopStep) {
      const curr = items[i];
      if (loopIterator(prev, curr))
        return true;
      prev = curr;
    }
    return false;
  };
  const midIndex = Math.floor(items.length / 2);
  if (loop(step, midIndex, step, iterator))
    return true;
  return loop(items.length - step, midIndex, -step, iterator);
}

// packages/ag-charts-enterprise/src/axes/angle-number/angleAxisInterval.ts
import { _ModuleSupport } from "ag-charts-community";
var { OR, POSITIVE_NUMBER, NAN, AxisInterval, Validate } = _ModuleSupport;
var AngleAxisInterval = class extends AxisInterval {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
  }
};
__decorateClass([
  Validate(OR(POSITIVE_NUMBER, NAN))
], AngleAxisInterval.prototype, "minSpacing", 2);

// packages/ag-charts-enterprise/src/axes/angle/angleAxis.ts
import { _ModuleSupport as _ModuleSupport4, _Scene as _Scene3, _Util as _Util3 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/polar-crosslines/angleCrossLine.ts
import { _ModuleSupport as _ModuleSupport3, _Scale, _Scene as _Scene2, _Util as _Util2 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/polar-crosslines/polarCrossLine.ts
import { _ModuleSupport as _ModuleSupport2, _Scene, _Util } from "ag-charts-community";
var {
  BaseProperties,
  ChartAxisDirection,
  Layers,
  ARRAY,
  BOOLEAN,
  COLOR_STRING,
  FONT_STYLE,
  FONT_WEIGHT,
  LINE_DASH,
  NUMBER,
  OBJECT,
  POSITIVE_NUMBER: POSITIVE_NUMBER2,
  RATIO,
  STRING,
  UNION,
  AND,
  Validate: Validate2,
  MATCHING_CROSSLINE_TYPE
} = _ModuleSupport2;
var { Group } = _Scene;
var { createId } = _Util;
var PolarCrossLineLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass([
  Validate2(BOOLEAN, { optional: true })
], PolarCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Validate2(STRING, { optional: true })
], PolarCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Validate2(FONT_STYLE, { optional: true })
], PolarCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate2(FONT_WEIGHT, { optional: true })
], PolarCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate2(POSITIVE_NUMBER2)
], PolarCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate2(STRING)
], PolarCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate2(NUMBER)
], PolarCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Validate2(COLOR_STRING, { optional: true })
], PolarCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Validate2(BOOLEAN, { optional: true })
], PolarCrossLineLabel.prototype, "parallel", 2);
var _PolarCrossLine = class _PolarCrossLine extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = createId(this);
    this.shape = "polygon";
    this.label = new PolarCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = ChartAxisDirection.X;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LINE_LAYER_ZINDEX });
    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LABEL_LAYER_ZINDEX });
  }
  setSectorNodeProps(node) {
    node.fill = this.fill;
    node.fillOpacity = this.fillOpacity ?? 1;
    node.stroke = this.stroke;
    node.strokeOpacity = this.strokeOpacity ?? 1;
    node.strokeWidth = this.strokeWidth ?? 1;
    node.lineDash = this.lineDash;
  }
  setLabelNodeProps(node, x, y, baseline, rotation) {
    const { label } = this;
    node.x = x;
    node.y = y;
    node.text = label.text;
    node.textAlign = "center";
    node.textBaseline = baseline;
    node.rotation = rotation;
    node.rotationCenterX = x;
    node.rotationCenterY = y;
    node.fill = label.color;
    node.fontFamily = label.fontFamily;
    node.fontSize = label.fontSize;
    node.fontStyle = label.fontStyle;
    node.visible = true;
  }
};
_PolarCrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;
_PolarCrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;
_PolarCrossLine.LABEL_LAYER_ZINDEX = Layers.SERIES_LABEL_ZINDEX;
__decorateClass([
  Validate2(BOOLEAN, { optional: true })
], _PolarCrossLine.prototype, "enabled", 2);
__decorateClass([
  Validate2(UNION(["range", "line"], "a crossLine type"), { optional: true })
], _PolarCrossLine.prototype, "type", 2);
__decorateClass([
  Validate2(AND(MATCHING_CROSSLINE_TYPE("range"), ARRAY.restrict({ length: 2 })), {
    optional: true
  })
], _PolarCrossLine.prototype, "range", 2);
__decorateClass([
  Validate2(MATCHING_CROSSLINE_TYPE("value"), { optional: true })
], _PolarCrossLine.prototype, "value", 2);
__decorateClass([
  Validate2(COLOR_STRING, { optional: true })
], _PolarCrossLine.prototype, "fill", 2);
__decorateClass([
  Validate2(RATIO, { optional: true })
], _PolarCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Validate2(COLOR_STRING, { optional: true })
], _PolarCrossLine.prototype, "stroke", 2);
__decorateClass([
  Validate2(NUMBER, { optional: true })
], _PolarCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Validate2(RATIO, { optional: true })
], _PolarCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate2(LINE_DASH, { optional: true })
], _PolarCrossLine.prototype, "lineDash", 2);
__decorateClass([
  Validate2(UNION(["polygon", "circle"], "a shape"))
], _PolarCrossLine.prototype, "shape", 2);
__decorateClass([
  Validate2(OBJECT)
], _PolarCrossLine.prototype, "label", 2);
var PolarCrossLine = _PolarCrossLine;

// packages/ag-charts-enterprise/src/axes/polar-crosslines/angleCrossLine.ts
var { ChartAxisDirection: ChartAxisDirection2, validateCrossLineValues } = _ModuleSupport3;
var { Path, Sector, RotatableText, ContinuousScale } = _Scene2;
var { normalizeAngle360, isNumberEqual } = _Util2;
var _AngleCrossLine = class _AngleCrossLine extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection2.X;
    this.polygonNode = new Path();
    this.sectorNode = new Sector();
    this.lineNode = new Path();
    this.labelNode = new RotatableText();
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.group.append(this.lineNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale, shape, type, value, range: range2 } = this;
    const visibilityCheck = () => {
      if (!ContinuousScale.is(scale)) {
        return true;
      }
      const [start, end] = range2 ?? [value, void 0];
      const domain = scale.getDomain?.() ?? scale.domain;
      return start >= domain[0] && start <= domain[1] && (type === "line" || end >= start && end <= domain[1]);
    };
    if (!scale || !type || !validateCrossLineValues(type, value, range2, scale, visibilityCheck)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    if (type === "line" && shape === "circle" && scale instanceof _Scale.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateLineNode(visible);
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
  }
  updateLineNode(visible) {
    const { scale, type, value, lineNode: line } = this;
    let angle;
    if (!visible || type !== "line" || !scale || isNaN(angle = scale.convert(value))) {
      line.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    line.visible = true;
    line.stroke = this.stroke;
    line.strokeOpacity = this.strokeOpacity ?? 1;
    line.strokeWidth = this.strokeWidth ?? 1;
    line.fill = void 0;
    line.lineDash = this.lineDash;
    const x = axisOuterRadius * Math.cos(angle);
    const y = axisOuterRadius * Math.sin(angle);
    const x0 = axisInnerRadius * Math.cos(angle);
    const y0 = axisInnerRadius * Math.sin(angle);
    line.path.clear(true);
    line.path.moveTo(x0, y0);
    line.path.lineTo(x, y);
    this.group.zIndex = _AngleCrossLine.LINE_LAYER_ZINDEX;
  }
  updatePolygonNode(visible) {
    const { polygonNode: polygon, range: range2, scale, shape, type } = this;
    let ticks;
    if (!visible || type !== "range" || shape !== "polygon" || !scale || !range2 || !(ticks = scale.ticks?.())) {
      polygon.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const startIndex = ticks.indexOf(range2[0]);
    const endIndex = ticks.indexOf(range2[1]);
    const stops = startIndex <= endIndex ? ticks.slice(startIndex, endIndex + 1) : ticks.slice(startIndex).concat(ticks.slice(0, endIndex + 1));
    const angles = stops.map((value) => scale.convert(value));
    polygon.visible = true;
    this.setSectorNodeProps(polygon);
    const { path } = polygon;
    path.clear(true);
    angles.forEach((angle, index) => {
      const x = axisOuterRadius * Math.cos(angle);
      const y = axisOuterRadius * Math.sin(angle);
      if (index === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (axisInnerRadius === 0) {
      path.lineTo(0, 0);
    } else {
      angles.slice().reverse().forEach((angle) => {
        const x = axisInnerRadius * Math.cos(angle);
        const y = axisInnerRadius * Math.sin(angle);
        path.lineTo(x, y);
      });
    }
    polygon.path.closePath();
    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateSectorNode(visible) {
    const { sectorNode: sector, range: range2, scale, shape, type } = this;
    if (!visible || type !== "range" || shape !== "circle" || !scale || !range2) {
      sector.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const angles = range2.map((value) => scale.convert(value));
    const step = scale.step ?? 0;
    const padding = scale instanceof _Scale.BandScale ? step / 2 : 0;
    sector.visible = true;
    this.setSectorNodeProps(sector);
    sector.centerX = 0;
    sector.centerY = 0;
    sector.innerRadius = axisInnerRadius;
    sector.outerRadius = axisOuterRadius;
    sector.startAngle = angles[0] - padding;
    sector.endAngle = angles[1] + padding;
    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateLabelNode(visible) {
    const { label, labelNode: node, range: range2, scale, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale || type === "range" && !range2) {
      node.visible = true;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    let labelX;
    let labelY;
    let rotation;
    let textBaseline;
    if (type === "line") {
      const angle = normalizeAngle360(scale.convert(this.value));
      const angle270 = 1.5 * Math.PI;
      const isRightSide = isNumberEqual(angle, angle270) || angle > angle270 || angle < Math.PI / 2;
      const midX = (axisInnerRadius + axisOuterRadius) / 2 * Math.cos(angle);
      const midY = (axisInnerRadius + axisOuterRadius) / 2 * Math.sin(angle);
      labelX = midX + label.padding * Math.cos(angle + Math.PI / 2);
      labelY = midY + label.padding * Math.sin(angle + Math.PI / 2);
      textBaseline = isRightSide ? "top" : "bottom";
      rotation = isRightSide ? angle : angle - Math.PI;
    } else {
      const [startAngle, endAngle] = range2.map((value) => normalizeAngle360(scale.convert(value)));
      let angle = (startAngle + endAngle) / 2;
      if (startAngle > endAngle) {
        angle -= Math.PI;
      }
      angle = normalizeAngle360(angle);
      const isBottomSide = (isNumberEqual(angle, 0) || angle > 0) && angle < Math.PI;
      let distance;
      const ticks = scale.ticks?.() ?? [];
      if (this.shape === "circle" || ticks.length < 3) {
        distance = axisOuterRadius - label.padding;
      } else {
        distance = axisOuterRadius * Math.cos(Math.PI / ticks.length) - label.padding;
      }
      labelX = distance * Math.cos(angle);
      labelY = distance * Math.sin(angle);
      textBaseline = isBottomSide ? "bottom" : "top";
      rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
};
_AngleCrossLine.className = "AngleCrossLine";
var AngleCrossLine = _AngleCrossLine;

// packages/ag-charts-enterprise/src/axes/angle/angleAxis.ts
var { AND: AND2, ChartAxisDirection: ChartAxisDirection3, GREATER_THAN, NUMBER: NUMBER2, UNION: UNION2, ProxyOnWrite, TextWrapper, TextUtils, Validate: Validate3 } = _ModuleSupport4;
var { Path: Path2, RotatableText: RotatableText2 } = _Scene3;
var { angleBetween, isNumberEqual: isNumberEqual2, toRadians, normalizeAngle360: normalizeAngle3602 } = _Util3;
var AngleAxisLabel = class extends _ModuleSupport4.AxisLabel {
  constructor() {
    super(...arguments);
    this.orientation = "fixed";
  }
};
__decorateClass([
  Validate3(UNION2(["fixed", "parallel", "perpendicular"], "a label orientation"))
], AngleAxisLabel.prototype, "orientation", 2);
var AngleAxis = class extends _ModuleSupport4.PolarAxis {
  constructor(moduleCtx, scale) {
    super(moduleCtx, scale);
    this.startAngle = 0;
    this.endAngle = void 0;
    this.labelData = [];
    this.tickData = [];
    this.radiusLine = this.axisGroup.appendChild(new Path2());
    this.includeInvisibleDomains = true;
  }
  get direction() {
    return ChartAxisDirection3.X;
  }
  createLabel() {
    return new AngleAxisLabel();
  }
  update() {
    this.updateScale();
    this.updatePosition();
    this.updateGridLines();
    this.updateTickLines();
    this.updateLabels();
    this.updateRadiusLine();
    this.updateCrossLines();
    return this.tickData.length;
  }
  computeRange() {
    const startAngle = normalizeAngle3602(-Math.PI / 2 + toRadians(this.startAngle));
    let endAngle = this.endAngle == null ? startAngle + Math.PI * 2 : -Math.PI / 2 + toRadians(this.endAngle);
    if (endAngle < startAngle) {
      endAngle += 2 * Math.PI;
    }
    this.range = [startAngle, endAngle];
  }
  calculateAvailableRange() {
    const { range: range2, gridLength: radius } = this;
    return angleBetween(range2[0], range2[1]) * radius;
  }
  updatePosition() {
    const { translation, axisGroup, gridGroup, crossLineGroup } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    axisGroup.translationX = translationX;
    axisGroup.translationY = translationY;
    gridGroup.translationX = translationX;
    gridGroup.translationY = translationY;
    crossLineGroup.translationX = translationX;
    crossLineGroup.translationY = translationY;
  }
  updateRadiusLine() {
    const node = this.radiusLine;
    const { path } = node;
    path.clear(true);
    const { points, closePath } = this.getAxisLinePoints();
    points.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
      if (arc) {
        path.arc(x, y, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (closePath) {
      path.closePath();
    }
    node.visible = this.line.enabled;
    node.stroke = this.line.stroke;
    node.strokeWidth = this.line.width;
    node.fill = void 0;
  }
  getAxisLinePoints() {
    const { scale, shape, gridLength: radius } = this;
    const [startAngle, endAngle] = this.range;
    const isFullCircle = isNumberEqual2(endAngle - startAngle, 2 * Math.PI);
    const points = [];
    if (shape === "circle") {
      if (isFullCircle) {
        points.push(
          { x: radius, y: 0, moveTo: true },
          {
            x: 0,
            y: 0,
            radius,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            arc: true,
            moveTo: false
          }
        );
      } else {
        points.push(
          {
            x: radius * Math.cos(startAngle),
            y: radius * Math.sin(startAngle),
            moveTo: true
          },
          {
            x: 0,
            y: 0,
            radius,
            startAngle: normalizeAngle3602(startAngle),
            endAngle: normalizeAngle3602(endAngle),
            arc: true,
            moveTo: false
          }
        );
      }
    } else if (shape === "polygon") {
      const angles = scale.ticks?.().map((value) => scale.convert(value));
      if (angles && angles.length > 2) {
        angles.forEach((angle, i) => {
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const moveTo = i === 0;
          points.push({ x, y, moveTo });
        });
      }
    }
    return { points, closePath: isFullCircle };
  }
  updateGridLines() {
    const {
      scale,
      gridLength: radius,
      gridLine: { enabled, style, width },
      innerRadiusRatio
    } = this;
    if (!(style && radius > 0)) {
      return;
    }
    const ticks = this.tickData;
    const innerRadius = radius * innerRadiusRatio;
    const styleCount = style.length;
    const idFn = (datum) => datum.value;
    this.gridLineGroupSelection.update(enabled ? ticks : [], void 0, idFn).each((line, datum, index) => {
      const { value } = datum;
      const { stroke: stroke2, lineDash } = style[index % styleCount];
      const angle = scale.convert(value);
      line.x1 = innerRadius * Math.cos(angle);
      line.y1 = innerRadius * Math.sin(angle);
      line.x2 = radius * Math.cos(angle);
      line.y2 = radius * Math.sin(angle);
      line.stroke = stroke2;
      line.strokeWidth = width;
      line.lineDash = lineDash;
      line.fill = void 0;
    });
    this.gridLineGroupSelection.cleanup();
  }
  updateLabels() {
    const { label, tickLabelGroupSelection } = this;
    const ticks = this.tickData;
    tickLabelGroupSelection.update(label.enabled ? ticks : []).each((node, _, index) => {
      const labelDatum = this.labelData[index];
      if (!labelDatum || labelDatum.hidden) {
        node.visible = false;
        return;
      }
      node.text = labelDatum.text;
      node.setFont(label);
      node.fill = label.color;
      node.x = labelDatum.x;
      node.y = labelDatum.y;
      node.textAlign = labelDatum.textAlign;
      node.textBaseline = labelDatum.textBaseline;
      node.visible = true;
      if (labelDatum.rotation) {
        node.rotation = labelDatum.rotation;
        node.rotationCenterX = labelDatum.x;
        node.rotationCenterY = labelDatum.y;
      } else {
        node.rotation = 0;
      }
    });
  }
  updateTickLines() {
    const { scale, gridLength: radius, tick, tickLineGroupSelection } = this;
    const ticks = this.tickData;
    tickLineGroupSelection.update(tick.enabled ? ticks : []).each((line, datum) => {
      const { value } = datum;
      const angle = scale.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      line.x1 = radius * cos;
      line.y1 = radius * sin;
      line.x2 = (radius + tick.size) * cos;
      line.y2 = (radius + tick.size) * sin;
      line.stroke = tick.stroke;
      line.strokeWidth = tick.width;
    });
  }
  createLabelNodeData(ticks, options, seriesRect) {
    const { label, gridLength: radius, scale, tick } = this;
    if (!label.enabled) {
      return [];
    }
    const tempText2 = new RotatableText2();
    const seriesLeft = seriesRect.x - this.translation.x;
    const seriesRight = seriesRect.x + seriesRect.width - this.translation.x;
    const labelData = ticks.map((datum, index) => {
      const { value } = datum;
      const distance = radius + label.padding + tick.size;
      const angle = scale.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = distance * cos;
      const y = distance * sin;
      const { textAlign, textBaseline } = this.getLabelAlign(angle);
      const isLastTickOverFirst = index === ticks.length - 1 && value !== ticks[0] && isNumberEqual2(normalizeAngle3602(angle), normalizeAngle3602(scale.convert(ticks[0])));
      const rotation = this.getLabelRotation(angle);
      let text2 = String(value);
      if (label.formatter) {
        const { callbackCache } = this.moduleCtx;
        text2 = callbackCache.call(label.formatter, { value, index }) ?? "";
      }
      tempText2.text = text2;
      tempText2.x = x;
      tempText2.y = y;
      tempText2.setFont(label);
      tempText2.textAlign = textAlign;
      tempText2.textBaseline = textBaseline;
      tempText2.rotation = rotation;
      if (rotation) {
        tempText2.rotationCenterX = x;
        tempText2.rotationCenterY = y;
      }
      let box = rotation ? _Scene3.Transformable.toCanvas(tempText2) : tempText2.getBBox();
      if (box && options.hideWhenNecessary && !rotation) {
        const overflowLeft = seriesLeft - box.x;
        const overflowRight = box.x + box.width - seriesRight;
        const pixelError = 1;
        if (overflowLeft > pixelError || overflowRight > pixelError) {
          const availWidth = box.width - Math.max(overflowLeft, overflowRight);
          text2 = TextWrapper.wrapText(text2, { maxWidth: availWidth, font: label, textWrap: "never" });
          if (text2 === TextUtils.EllipsisChar) {
            text2 = "";
          }
          tempText2.text = text2;
          box = tempText2.getBBox();
        }
      }
      return {
        text: text2,
        x,
        y,
        textAlign,
        textBaseline,
        hidden: text2 === "" || datum.hidden || isLastTickOverFirst,
        rotation,
        box
      };
    });
    if (label.avoidCollisions) {
      this.avoidLabelCollisions(labelData);
    }
    return labelData;
  }
  computeLabelsBBox(options, seriesRect) {
    this.tickData = this.generateAngleTicks();
    this.labelData = this.createLabelNodeData(this.tickData, options, seriesRect);
    const textBoxes = this.labelData.map(({ box }) => box).filter((box) => box != null);
    if (!this.label.enabled || textBoxes.length === 0) {
      return null;
    }
    return _Scene3.BBox.merge(textBoxes);
  }
  getLabelOrientation() {
    const { label } = this;
    return label instanceof AngleAxisLabel ? label.orientation : "fixed";
  }
  getLabelRotation(tickAngle) {
    let rotation = toRadians(this.label.rotation ?? 0);
    tickAngle = normalizeAngle3602(tickAngle);
    const orientation = this.getLabelOrientation();
    if (orientation === "parallel") {
      rotation += tickAngle;
      if (tickAngle >= 0 && tickAngle < Math.PI) {
        rotation -= Math.PI / 2;
      } else {
        rotation += Math.PI / 2;
      }
    } else if (orientation === "perpendicular") {
      rotation += tickAngle;
      if (tickAngle >= Math.PI / 2 && tickAngle < 1.5 * Math.PI) {
        rotation += Math.PI;
      }
    }
    return rotation;
  }
  getLabelAlign(tickAngle) {
    const cos = Math.cos(tickAngle);
    const sin = Math.sin(tickAngle);
    let textAlign;
    let textBaseline;
    const orientation = this.getLabelOrientation();
    const isCos0 = isNumberEqual2(cos, 0);
    const isSin0 = isNumberEqual2(sin, 0);
    const isCos1 = isNumberEqual2(cos, 1);
    const isSinMinus1 = isNumberEqual2(sin, -1);
    const isCosPositive = cos > 0 && !isCos0;
    const isSinPositive = sin > 0 && !isSin0;
    if (orientation === "parallel") {
      textAlign = "center";
      textBaseline = isCos1 && isSin0 || isSinPositive ? "top" : "bottom";
    } else if (orientation === "perpendicular") {
      textAlign = isSinMinus1 || isCosPositive ? "left" : "right";
      textBaseline = "middle";
    } else {
      textAlign = "right";
      if (isCos0) {
        textAlign = "center";
      } else if (isCosPositive) {
        textAlign = "left";
      }
      textBaseline = "bottom";
      if (isSin0) {
        textBaseline = "middle";
      } else if (isSinPositive) {
        textBaseline = "top";
      }
    }
    return { textAlign, textBaseline };
  }
  updateCrossLines() {
    this.crossLines?.forEach((crossLine) => {
      if (crossLine instanceof AngleCrossLine) {
        const { shape, gridLength: radius, innerRadiusRatio } = this;
        crossLine.shape = shape;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
};
AngleAxis.CrossLineConstructor = AngleCrossLine;
__decorateClass([
  ProxyOnWrite("rotation"),
  Validate3(NUMBER2.restrict({ min: 0, max: 360 }))
], AngleAxis.prototype, "startAngle", 2);
__decorateClass([
  Validate3(AND2(NUMBER2.restrict({ min: 0, max: 720 }), GREATER_THAN("startAngle")), { optional: true })
], AngleAxis.prototype, "endAngle", 2);

// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxis.ts
var { RATIO: RATIO2, OBJECT: OBJECT2, Validate: Validate4 } = _ModuleSupport5;
var { BandScale } = _Scale2;
var { isNumberEqual: isNumberEqual3 } = _Util4;
var AngleCategoryAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale());
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.interval = new AngleAxisInterval();
  }
  generateAngleTicks() {
    const { scale, gridLength: radius } = this;
    const { values, minSpacing } = this.interval;
    const ticks = values ?? scale.ticks() ?? [];
    if (ticks.length < 2 || isNaN(minSpacing)) {
      return ticks.map((value) => {
        return { value, visible: true };
      });
    }
    const startTick = ticks[0];
    const startAngle = scale.convert(startTick);
    const startX = radius * Math.cos(startAngle);
    const startY = radius * Math.sin(startAngle);
    for (let step = 1; step < ticks.length - 1; step++) {
      const nextTick = ticks[step];
      const nextAngle = scale.convert(nextTick);
      if (nextAngle - startAngle > Math.PI) {
        break;
      }
      const nextX = radius * Math.cos(nextAngle);
      const nextY = radius * Math.sin(nextAngle);
      const spacing = Math.sqrt((nextX - startX) ** 2 + (nextY - startY) ** 2);
      if (spacing > minSpacing) {
        const visibleTicks = /* @__PURE__ */ new Set([startTick]);
        loopSymmetrically(ticks, step, (_, next) => {
          visibleTicks.add(next);
        });
        return ticks.map((value) => {
          const visible = visibleTicks.has(value);
          return { value, visible };
        });
      }
    }
    return [{ value: startTick, visible: true }];
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    if (labelData.length < 3) {
      return;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    const visibleLabels = /* @__PURE__ */ new Set([firstLabel]);
    const lastLabelIsOverFirst = isNumberEqual3(firstLabel.x, lastLabel.x) && isNumberEqual3(firstLabel.y, lastLabel.y);
    const maxStep = Math.floor(labelData.length / 2);
    for (let step = 1; step <= maxStep; step++) {
      const labels = lastLabelIsOverFirst ? labelData.slice(0, -1) : labelData;
      const collisionDetected = loopSymmetrically(labels, step, labelsCollide);
      if (!collisionDetected) {
        loopSymmetrically(labels, step, (_, next) => {
          visibleLabels.add(next);
        });
        break;
      }
    }
    labelData.forEach((datum) => {
      if (!visibleLabels.has(datum)) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleCategoryAxis.className = "AngleCategoryAxis";
AngleCategoryAxis.type = "angle-category";
__decorateClass([
  Validate4(RATIO2)
], AngleCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Validate4(RATIO2)
], AngleCategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  Validate4(OBJECT2)
], AngleCategoryAxis.prototype, "interval", 2);

// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxisModule.ts
var AngleCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-category",
  moduleFactory: (ctx) => new AngleCategoryAxis(ctx)
};

// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxis.ts
import { _ModuleSupport as _ModuleSupport6, _Util as _Util6 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/angle-number/linearAngleScale.ts
import { _Scale as _Scale3, _Util as _Util5 } from "ag-charts-community";
var { LinearScale, Invalidating } = _Scale3;
var { range, isDenseInterval, isNumberEqual: isNumberEqual4 } = _Util5;
var LinearAngleScale = class extends LinearScale {
  constructor() {
    super(...arguments);
    this.arcLength = 0;
    this.niceTickStep = 0;
  }
  ticks() {
    if (!this.domain || this.domain.length < 2 || this.domain.some((d) => !isFinite(d)) || this.arcLength <= 0) {
      return [];
    }
    this.refresh();
    const { interval } = this;
    const [d0, d1] = this.getDomain();
    if (interval) {
      const step2 = Math.abs(interval);
      const availableRange = this.getPixelRange();
      if (!isDenseInterval((d1 - d0) / step2, availableRange)) {
        return range(d0, d1, step2);
      }
    }
    const step = this.nice && this.niceTickStep ? this.niceTickStep : this.getTickStep(d0, d1);
    return range(d0, d1, step);
  }
  hasNiceRange() {
    const sortedRange = this.range.slice().sort((a, b) => a - b);
    const niceRanges = [Math.PI, 2 * Math.PI];
    return niceRanges.some((r) => isNumberEqual4(r, sortedRange[1] - sortedRange[0]));
  }
  getNiceStepAndTickCount() {
    const [start, stop] = this.niceDomain;
    let step = this.getTickStep(start, stop);
    const maxTickCount = isNaN(this.maxTickCount) ? Infinity : this.maxTickCount;
    const expectedTickCount = Math.abs(stop - start) / step;
    let niceTickCount = Math.pow(2, Math.ceil(Math.log(expectedTickCount) / Math.log(2)));
    if (niceTickCount > maxTickCount) {
      niceTickCount /= 2;
      step *= 2;
    }
    return { count: niceTickCount, step };
  }
  updateNiceDomain() {
    super.updateNiceDomain();
    if (!this.hasNiceRange())
      return;
    const reversed = this.niceDomain[0] > this.niceDomain[1];
    const start = reversed ? this.niceDomain[1] : this.niceDomain[0];
    const { step, count } = this.getNiceStepAndTickCount();
    const s = 1 / step;
    const stop = step >= 1 ? Math.ceil(start / step + count) * step : Math.ceil((start + count * step) * s) / s;
    this.niceDomain = reversed ? [stop, start] : [start, stop];
    this.niceTickStep = step;
  }
  getPixelRange() {
    return this.arcLength;
  }
};
__decorateClass([
  Invalidating
], LinearAngleScale.prototype, "arcLength", 2);

// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxis.ts
var { AND: AND3, Default, GREATER_THAN: GREATER_THAN2, LESS_THAN, NUMBER_OR_NAN, OBJECT: OBJECT3, Validate: Validate5 } = _ModuleSupport6;
var { angleBetween: angleBetween2, isNumberEqual: isNumberEqual5, normalisedExtentWithMetadata, findMinMax } = _Util6;
var AngleNumberAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearAngleScale());
    this.shape = "circle";
    this.min = NaN;
    this.max = NaN;
    this.interval = new AngleAxisInterval();
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent3, clipped };
  }
  getRangeArcLength() {
    const { range: requestedRange } = this;
    const min = Math.min(...requestedRange);
    const max = Math.max(...requestedRange);
    const rotation = angleBetween2(min, max) || 2 * Math.PI;
    const radius = this.gridLength;
    return rotation * radius;
  }
  generateAngleTicks() {
    const arcLength = this.getRangeArcLength();
    const { scale, range: requestedRange } = this;
    const { values, minSpacing, maxSpacing } = this.interval;
    const minTicksCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;
    const maxTicksCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;
    const preferredTicksCount = Math.floor(4 / Math.PI * Math.abs(requestedRange[0] - requestedRange[1]));
    scale.tickCount = Math.max(minTicksCount, Math.min(maxTicksCount, preferredTicksCount));
    scale.minTickCount = minTicksCount;
    scale.maxTickCount = maxTicksCount;
    scale.arcLength = arcLength;
    let rawTicks;
    if (values != null) {
      const [d0, d1] = findMinMax(scale.getDomain().map(Number));
      rawTicks = values.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);
    } else {
      rawTicks = scale.ticks();
    }
    return rawTicks.map((value) => ({ value, visible: true }));
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    if (firstLabel !== lastLabel && isNumberEqual5(firstLabel.x, lastLabel.x) && isNumberEqual5(firstLabel.y, lastLabel.y)) {
      lastLabel.hidden = true;
    }
    for (let step = 1; step < labelData.length; step *= 2) {
      let collisionDetected = false;
      for (let i = step; i < labelData.length; i += step) {
        const next = labelData[i];
        const prev = labelData[i - step];
        if (labelsCollide(prev, next)) {
          collisionDetected = true;
          break;
        }
      }
      if (!collisionDetected) {
        labelData.forEach((datum, i) => {
          if (i % step > 0) {
            datum.hidden = true;
            datum.box = void 0;
          }
        });
        return;
      }
    }
    labelData.forEach((datum, i) => {
      if (i > 0) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleNumberAxis.className = "AngleNumberAxis";
AngleNumberAxis.type = "angle-number";
__decorateClass([
  Validate5(AND3(NUMBER_OR_NAN, LESS_THAN("max"))),
  Default(NaN)
], AngleNumberAxis.prototype, "min", 2);
__decorateClass([
  Validate5(AND3(NUMBER_OR_NAN, GREATER_THAN2("min"))),
  Default(NaN)
], AngleNumberAxis.prototype, "max", 2);
__decorateClass([
  Validate5(OBJECT3)
], AngleNumberAxis.prototype, "interval", 2);

// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxisModule.ts
var AngleNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-number",
  moduleFactory: (ctx) => new AngleNumberAxis(ctx)
};

// packages/ag-charts-enterprise/src/axes/ordinal/ordinalTimeAxis.ts
import { _ModuleSupport as _ModuleSupport7, _Scale as _Scale4 } from "ag-charts-community";
var { OrdinalTimeScale } = _Scale4;
var { dateToNumber } = _ModuleSupport7;
var OrdinalTimeAxis = class extends _ModuleSupport7.CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new OrdinalTimeScale());
  }
  normaliseDataDomain(d) {
    const domain = [];
    const uniqueValues = /* @__PURE__ */ new Set();
    for (let v of d) {
      if (typeof v === "number") {
        v = new Date(v);
      }
      const key = dateToNumber(v);
      if (!uniqueValues.has(key)) {
        uniqueValues.add(key);
        domain.push(v);
      }
    }
    domain.sort((a, b) => dateToNumber(a) - dateToNumber(b));
    return { domain, clipped: false };
  }
  onFormatChange(ticks, fractionDigits, domain, format) {
    if (format) {
      super.onFormatChange(ticks, fractionDigits, domain, format);
    } else {
      this.labelFormatter = this.scale.tickFormat({ ticks, domain });
    }
  }
};
OrdinalTimeAxis.className = "OrdinalTimeAxis";
OrdinalTimeAxis.type = "ordinal-time";

// packages/ag-charts-enterprise/src/axes/ordinal/ordinalTimeAxisModule.ts
var OrdinalTimeAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ordinal-time",
  moduleFactory: (ctx) => new OrdinalTimeAxis(ctx)
};

// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxis.ts
import { _ModuleSupport as _ModuleSupport10, _Scale as _Scale6 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/radius/radiusAxis.ts
import { _ModuleSupport as _ModuleSupport9, _Scene as _Scene5, _Util as _Util8 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/axes/polar-crosslines/radiusCrossLine.ts
import { _ModuleSupport as _ModuleSupport8, _Scale as _Scale5, _Scene as _Scene4, _Util as _Util7 } from "ag-charts-community";
var { ChartAxisDirection: ChartAxisDirection4, Validate: Validate6, DEGREE, validateCrossLineValues: validateCrossLineValues2 } = _ModuleSupport8;
var { Path: Path3, Sector: Sector2, RotatableText: RotatableText3 } = _Scene4;
var { normalizeAngle360: normalizeAngle3603, toRadians: toRadians2, isNumberEqual: isNumberEqual6 } = _Util7;
var RadiusCrossLineLabel = class extends PolarCrossLineLabel {
  constructor() {
    super(...arguments);
    this.positionAngle = void 0;
  }
};
__decorateClass([
  Validate6(DEGREE, { optional: true })
], RadiusCrossLineLabel.prototype, "positionAngle", 2);
var _RadiusCrossLine = class _RadiusCrossLine extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection4.Y;
    this.label = new RadiusCrossLineLabel();
    this.polygonNode = new Path3();
    this.sectorNode = new Sector2();
    this.labelNode = new RotatableText3();
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale, type, value, range: range2 } = this;
    if (!scale || !type || !validateCrossLineValues2(type, value, range2, scale)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    if (type === "line" && scale instanceof _Scale5.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateRadii();
    const { innerRadius, outerRadius } = this;
    visible && (visible = innerRadius >= this.axisInnerRadius && outerRadius <= this.axisOuterRadius);
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
    this.group.zIndex = this.type === "line" ? _RadiusCrossLine.LINE_LAYER_ZINDEX : _RadiusCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateRadii() {
    const { range: range2, scale, type, axisInnerRadius, axisOuterRadius } = this;
    if (!scale)
      return { innerRadius: 0, outerRadius: 0 };
    const getRadius = (value) => axisOuterRadius + axisInnerRadius - value;
    let outerRadius = 0;
    let innerRadius = 0;
    if (type === "line") {
      outerRadius = getRadius(scale.convert(this.value));
      innerRadius = outerRadius;
    } else {
      const bandwidth = Math.abs(scale?.bandwidth ?? 0);
      const convertedRange = range2.map((r) => scale.convert(r));
      outerRadius = getRadius(Math.max(...convertedRange));
      innerRadius = getRadius(Math.min(...convertedRange)) + bandwidth;
    }
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
  }
  drawPolygon(radius, angles, polygon) {
    angles.forEach((angle, index) => {
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      if (index === 0) {
        polygon.path.moveTo(x, y);
      } else {
        polygon.path.lineTo(x, y);
      }
    });
    polygon.path.closePath();
  }
  updatePolygonNode(visible) {
    const { gridAngles, polygonNode: polygon, scale, shape, type, innerRadius, outerRadius } = this;
    if (!visible || shape !== "polygon" || !scale || !gridAngles) {
      polygon.visible = false;
      return;
    }
    polygon.visible = true;
    const padding = this.getPadding();
    polygon.path.clear(true);
    this.drawPolygon(outerRadius - padding, gridAngles, polygon);
    const reversedAngles = gridAngles.slice().reverse();
    const innerPolygonRadius = type === "line" ? outerRadius - padding : innerRadius + padding;
    this.drawPolygon(innerPolygonRadius, reversedAngles, polygon);
    this.setSectorNodeProps(polygon);
  }
  updateSectorNode(visible) {
    const { axisInnerRadius, axisOuterRadius, scale, sectorNode: sector, shape, innerRadius, outerRadius } = this;
    if (!visible || shape !== "circle" || !scale) {
      sector.visible = false;
      return;
    }
    sector.visible = true;
    sector.startAngle = 0;
    sector.endAngle = 2 * Math.PI;
    const padding = this.getPadding();
    const r0 = _Util7.clamp(axisInnerRadius, innerRadius + padding, axisOuterRadius);
    const r1 = _Util7.clamp(axisInnerRadius, outerRadius - padding, axisOuterRadius);
    sector.innerRadius = Math.min(r0, r1);
    sector.outerRadius = Math.max(r0, r1);
    this.setSectorNodeProps(sector);
  }
  updateLabelNode(visible) {
    const { innerRadius, label, labelNode: node, scale, shape, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale) {
      node.visible = false;
      return;
    }
    const angle = normalizeAngle3603(toRadians2((label.positionAngle ?? 0) - 90));
    const isBottomSide = (isNumberEqual6(angle, 0) || angle > 0) && angle < Math.PI;
    const rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    let distance = 0;
    const angles = this.gridAngles ?? [];
    if (type === "line") {
      distance = innerRadius + label.padding;
    } else if (shape === "circle" || angles.length < 3) {
      distance = innerRadius - label.padding;
    } else {
      distance = innerRadius * Math.cos(Math.PI / angles.length) - label.padding;
    }
    const labelX = distance * Math.cos(angle);
    const labelY = distance * Math.sin(angle);
    let textBaseline;
    if (type === "line") {
      textBaseline = isBottomSide ? "top" : "bottom";
    } else {
      textBaseline = isBottomSide ? "bottom" : "top";
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
  getPadding() {
    const { scale } = this;
    if (!scale)
      return 0;
    const bandwidth = Math.abs(scale.bandwidth ?? 0);
    const step = Math.abs(scale.step ?? 0);
    return scale instanceof _Scale5.BandScale ? (step - bandwidth) / 2 : 0;
  }
};
_RadiusCrossLine.className = "RadiusCrossLine";
var RadiusCrossLine = _RadiusCrossLine;

// packages/ag-charts-enterprise/src/axes/radius/radiusAxis.ts
var { ChartAxisDirection: ChartAxisDirection5, Default: Default2, Layers: Layers2, DEGREE: DEGREE2, BOOLEAN: BOOLEAN2, Validate: Validate7 } = _ModuleSupport9;
var { Caption, Group: Group2, Path: Path4, Selection } = _Scene5;
var { isNumberEqual: isNumberEqual7, normalizeAngle360: normalizeAngle3604, toRadians: toRadians3 } = _Util8;
var RadiusAxisLabel = class extends _ModuleSupport9.AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Validate7(BOOLEAN2, { optional: true })
], RadiusAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Validate7(DEGREE2)
], RadiusAxisLabel.prototype, "autoRotateAngle", 2);
var RadiusAxis = class extends _ModuleSupport9.PolarAxis {
  constructor(moduleCtx, scale) {
    super(moduleCtx, scale);
    this.positionAngle = 0;
    this.gridPathGroup = this.gridGroup.appendChild(
      new Group2({
        name: `${this.id}-gridPaths`,
        zIndex: Layers2.AXIS_GRID_ZINDEX
      })
    );
    this.gridPathSelection = Selection.select(this.gridPathGroup, Path4);
  }
  get direction() {
    return ChartAxisDirection5.Y;
  }
  getAxisTransform() {
    const maxRadius = this.scale.range[0];
    const { translation, positionAngle, innerRadiusRatio } = this;
    const innerRadius = maxRadius * innerRadiusRatio;
    const rotation = toRadians3(positionAngle);
    return {
      translationX: translation.x,
      translationY: translation.y - maxRadius - innerRadius,
      rotation,
      rotationCenterX: 0,
      rotationCenterY: maxRadius + innerRadius
    };
  }
  updateSelections(lineData, data, params) {
    super.updateSelections(lineData, data, params);
    const {
      gridLine: { enabled, style, width },
      shape
    } = this;
    if (!style) {
      return;
    }
    const ticks = this.prepareTickData(data);
    const styleCount = style.length;
    const setStyle = (node, index) => {
      const { stroke: stroke2, lineDash } = style[index % styleCount];
      node.stroke = stroke2;
      node.strokeWidth = width;
      node.lineDash = lineDash;
      node.fill = void 0;
    };
    const [startAngle, endAngle] = this.gridRange ?? [0, 2 * Math.PI];
    const isFullCircle = isNumberEqual7(endAngle - startAngle, 2 * Math.PI);
    const drawCircleShape = (node, value) => {
      const { path } = node;
      path.clear(true);
      const radius = this.getTickRadius(value);
      if (isFullCircle) {
        path.moveTo(radius, 0);
        path.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        path.moveTo(radius * Math.cos(startAngle), radius * Math.sin(startAngle));
        path.arc(0, 0, radius, normalizeAngle3604(startAngle), normalizeAngle3604(endAngle));
      }
      if (isFullCircle) {
        path.closePath();
      }
    };
    const drawPolygonShape = (node, value) => {
      const { path } = node;
      const angles = this.gridAngles;
      path.clear(true);
      if (!angles || angles.length < 3) {
        return;
      }
      const radius = this.getTickRadius(value);
      angles.forEach((angle, idx) => {
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (idx === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        angles.forEach((innerAngle, innerIdx) => {
          const x2 = radius * Math.cos(innerAngle);
          const y2 = radius * Math.sin(innerAngle);
          if (innerIdx === 0) {
            path.moveTo(x2, y2);
          } else {
            path.lineTo(x2, y2);
          }
        });
        path.closePath();
      });
      path.closePath();
    };
    this.gridPathSelection.update(enabled ? ticks : []).each((node, value, index) => {
      setStyle(node, index);
      if (shape === "circle") {
        drawCircleShape(node, value);
      } else {
        drawPolygonShape(node, value);
      }
    });
  }
  updateTitle() {
    const identityFormatter = (params) => params.defaultValue;
    const {
      title,
      range: requestedRange,
      moduleCtx: { callbackCache }
    } = this;
    const { formatter = identityFormatter } = this.title;
    title.caption.enabled = title.enabled;
    title.caption.fontFamily = title.fontFamily;
    title.caption.fontSize = title.fontSize;
    title.caption.fontStyle = title.fontStyle;
    title.caption.fontWeight = title.fontWeight;
    title.caption.color = title.color;
    title.caption.wrapping = title.wrapping;
    let titleVisible = false;
    const titleNode = title.caption.node;
    if (title.enabled) {
      titleVisible = true;
      titleNode.rotation = Math.PI / 2;
      titleNode.x = Math.floor((requestedRange[0] + requestedRange[1]) / 2);
      titleNode.y = -Caption.SMALL_PADDING;
      titleNode.textAlign = "center";
      titleNode.textBaseline = "bottom";
      titleNode.text = callbackCache.call(formatter, this.getTitleFormatterParams());
    }
    titleNode.visible = titleVisible;
  }
  updateCrossLines() {
    this.crossLines?.forEach((crossLine) => {
      if (crossLine instanceof RadiusCrossLine) {
        const { shape, gridAngles, range: range2, innerRadiusRatio } = this;
        const radius = range2[0];
        crossLine.shape = shape;
        crossLine.gridAngles = gridAngles;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
  createLabel() {
    return new RadiusAxisLabel();
  }
};
RadiusAxis.CrossLineConstructor = RadiusCrossLine;
__decorateClass([
  Validate7(DEGREE2),
  Default2(0)
], RadiusAxis.prototype, "positionAngle", 2);

// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxis.ts
var { RATIO: RATIO3, ProxyPropertyOnWrite, Validate: Validate8 } = _ModuleSupport10;
var { BandScale: BandScale2 } = _Scale6;
var RadiusCategoryAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale2());
    this.shape = "circle";
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.paddingOuter = 0;
  }
  prepareTickData(data) {
    return data.slice().reverse();
  }
  getTickRadius(tickDatum) {
    const { scale, innerRadiusRatio } = this;
    const maxRadius = scale.range[0];
    const minRadius = maxRadius * innerRadiusRatio;
    if (scale instanceof BandScale2) {
      const ticks = scale.ticks();
      const index = ticks.length - 1 - ticks.indexOf(tickDatum.tickId);
      return index === 0 ? minRadius : scale.inset + scale.step * (index - 0.5) + scale.bandwidth / 2;
    } else {
      const tickRange = (maxRadius - minRadius) / scale.domain.length;
      return maxRadius - tickDatum.translationY + minRadius - tickRange / 2;
    }
  }
};
RadiusCategoryAxis.className = "RadiusCategoryAxis";
RadiusCategoryAxis.type = "radius-category";
__decorateClass([
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  ProxyPropertyOnWrite("scale", "paddingInner"),
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  ProxyPropertyOnWrite("scale", "paddingOuter"),
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "paddingOuter", 2);

// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxisModule.ts
var RadiusCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-category",
  moduleFactory: (ctx) => new RadiusCategoryAxis(ctx)
};

// packages/ag-charts-enterprise/src/axes/radius-number/radiusNumberAxis.ts
import { _ModuleSupport as _ModuleSupport11, _Scale as _Scale7, _Util as _Util9 } from "ag-charts-community";
var { AND: AND4, Default: Default3, GREATER_THAN: GREATER_THAN3, LESS_THAN: LESS_THAN2, NUMBER_OR_NAN: NUMBER_OR_NAN2, Validate: Validate9 } = _ModuleSupport11;
var { LinearScale: LinearScale2 } = _Scale7;
var { normalisedExtentWithMetadata: normalisedExtentWithMetadata2 } = _Util9;
var RadiusNumberAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearScale2());
    this.shape = "polygon";
    this.min = NaN;
    this.max = NaN;
  }
  prepareTickData(data) {
    const { scale } = this;
    const domainTop = scale.getDomain?.()[1];
    return data.filter(({ tick }) => tick !== domainTop).sort((a, b) => b.tick - a.tick);
  }
  getTickRadius(tickDatum) {
    const { scale } = this;
    const maxRadius = scale.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    return maxRadius - tickDatum.translationY + minRadius;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata2(d, min, max);
    return { domain: extent3, clipped };
  }
};
RadiusNumberAxis.className = "RadiusNumberAxis";
RadiusNumberAxis.type = "radius-number";
__decorateClass([
  Validate9(AND4(NUMBER_OR_NAN2, LESS_THAN2("max"))),
  Default3(NaN)
], RadiusNumberAxis.prototype, "min", 2);
__decorateClass([
  Validate9(AND4(NUMBER_OR_NAN2, GREATER_THAN3("min"))),
  Default3(NaN)
], RadiusNumberAxis.prototype, "max", 2);

// packages/ag-charts-enterprise/src/axes/radius-number/radiusNumberAxisModule.ts
var RadiusNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-number",
  moduleFactory: (ctx) => new RadiusNumberAxis(ctx)
};

// packages/ag-charts-enterprise/src/features/animation/animation.ts
import { _ModuleSupport as _ModuleSupport12 } from "ag-charts-community";
var { BOOLEAN: BOOLEAN3, POSITIVE_NUMBER: POSITIVE_NUMBER3, ObserveChanges, Validate: Validate10 } = _ModuleSupport12;
var Animation = class extends _ModuleSupport12.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    ctx.animationManager.skip(false);
  }
};
__decorateClass([
  ObserveChanges((target, newValue) => {
    target.ctx.animationManager.skip(!newValue);
  }),
  Validate10(BOOLEAN3)
], Animation.prototype, "enabled", 2);
__decorateClass([
  ObserveChanges((target, newValue) => {
    target.ctx.animationManager.defaultDuration = newValue;
  }),
  Validate10(POSITIVE_NUMBER3, { optional: true })
], Animation.prototype, "duration", 2);

// packages/ag-charts-enterprise/src/features/animation/animationModule.ts
var AnimationModule = {
  type: "root",
  optionsKey: "animation",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "gauge"],
  moduleFactory: (ctx) => new Animation(ctx),
  themeTemplate: {
    animation: {
      enabled: true
    }
  }
};

// packages/ag-charts-enterprise/src/features/annotations/annotationsModule.ts
import { _Theme } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/annotations.ts
import {
  _ModuleSupport as _ModuleSupport60,
  _Scene as _Scene25,
  _Util as _Util47
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/components/menu/menu.ts
import { _ModuleSupport as _ModuleSupport15 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/components/popover/anchoredPopover.ts
import { _ModuleSupport as _ModuleSupport14, _Util as _Util10 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/components/popover/popover.ts
import { _ModuleSupport as _ModuleSupport13 } from "ag-charts-community";
var { BaseModuleInstance, createElement } = _ModuleSupport13;
var canvasOverlay = "canvas-overlay";
var Popover = class extends BaseModuleInstance {
  constructor(ctx, id, options) {
    super();
    this.ctx = ctx;
    this.hideFns = [];
    this.moduleId = `popover-${id}`;
    if (options?.detached) {
      this.element = createElement("div");
    } else {
      this.element = ctx.domManager.addChild(canvasOverlay, this.moduleId);
    }
    this.element.setAttribute("role", "presentation");
    this.destroyFns.push(() => ctx.domManager.removeChild(canvasOverlay, this.moduleId));
  }
  attachTo(popover) {
    if (this.element.parentElement)
      return;
    popover.element.append(this.element);
  }
  hide(opts) {
    const { lastFocus = this.lastFocus } = opts ?? {};
    if (this.element.children.length === 0)
      return;
    this.hideFns.forEach((fn) => fn());
    lastFocus?.focus();
    this.lastFocus = void 0;
  }
  removeChildren() {
    this.element.replaceChildren();
  }
  showWithChildren(children, options) {
    if (!this.element.parentElement) {
      throw new Error("Can not show popover that has not been attached to a parent.");
    }
    const popover = createElement("div", "ag-charts-popover");
    popover.setAttribute("data-pointer-capture", "exclusive");
    if (options.ariaLabel != null) {
      popover.setAttribute("aria-label", options.ariaLabel);
    }
    if (options.class != null) {
      popover.classList.add(options.class);
    }
    popover.replaceChildren(...children);
    this.element.replaceChildren(popover);
    this.hideFns.push(() => this.removeChildren());
    if (options.onHide) {
      this.hideFns.push(options.onHide);
    }
    if (options.initialFocus && options.sourceEvent) {
      const { lastFocus } = this.ctx.focusIndicator.guessDevice(options.sourceEvent);
      if (lastFocus !== void 0) {
        options.initialFocus.focus();
        this.lastFocus = lastFocus;
      }
    }
    return popover;
  }
  getPopoverElement() {
    return this.element.firstElementChild;
  }
  updatePosition(position) {
    const popover = this.getPopoverElement();
    if (!popover)
      return;
    popover.style.setProperty("top", "unset");
    popover.style.setProperty("bottom", "unset");
    popover.style.setProperty("left", `${Math.floor(position.x)}px`);
    popover.style.setProperty("top", `${Math.floor(position.y)}px`);
  }
};

// packages/ag-charts-enterprise/src/components/popover/anchoredPopover.ts
var { clamp } = _Util10;
var AnchoredPopover = class extends Popover {
  setAnchor(anchor, fallbackAnchor) {
    this.anchor = anchor;
    this.fallbackAnchor = fallbackAnchor;
    this.updatePosition(anchor);
    this.repositionWithinBounds();
  }
  showWithChildren(children, options) {
    const anchor = options.anchor ?? this.anchor;
    const fallbackAnchor = options.fallbackAnchor ?? this.fallbackAnchor;
    const popover = super.showWithChildren(children, options);
    if (anchor) {
      this.setAnchor(anchor, fallbackAnchor);
    }
    _ModuleSupport14.getWindow().requestAnimationFrame(() => {
      this.repositionWithinBounds();
    });
    return popover;
  }
  repositionWithinBounds() {
    const { anchor, ctx, fallbackAnchor } = this;
    const popover = this.getPopoverElement();
    if (!anchor || !popover)
      return;
    const canvasRect = ctx.domManager.getBoundingClientRect();
    const { offsetWidth: width, offsetHeight: height } = popover;
    let x = clamp(0, anchor.x, canvasRect.width - width);
    let y = clamp(0, anchor.y, canvasRect.height - height);
    if (x !== anchor.x && fallbackAnchor?.x != null) {
      x = clamp(0, fallbackAnchor.x - width, canvasRect.width - width);
    }
    if (y !== anchor.y && fallbackAnchor?.y != null) {
      y = clamp(0, fallbackAnchor.y - height, canvasRect.height - height);
    }
    this.updatePosition({ x, y });
  }
};

// packages/ag-charts-enterprise/src/components/menu/menu.ts
var { createElement: createElement2, initMenuKeyNav, isButtonClickEvent } = _ModuleSupport15;
var Menu = class extends AnchoredPopover {
  show(options) {
    const rows = options.items.map((item) => this.createRow(options, item));
    const popover = this.showWithChildren(rows, options);
    popover.classList.add("ag-charts-menu");
    popover.setAttribute("role", "menu");
    this.menuCloser = initMenuKeyNav({
      orientation: "vertical",
      menu: popover,
      buttons: rows,
      device: this.ctx.focusIndicator.guessDevice(options.sourceEvent),
      closeCallback: () => this.hide()
    });
    this.hideFns.push(() => {
      this.menuCloser?.finishClosing();
      this.menuCloser = void 0;
    });
  }
  createRow(options, item) {
    const { domManager } = this.ctx;
    const { menuItemRole = "menuitem" } = options;
    const active = item.value === options.value;
    const row = createElement2("div", "ag-charts-menu__row");
    row.setAttribute("role", menuItemRole);
    if (menuItemRole === "menuitemradio") {
      row.setAttribute("aria-checked", (options.value === item.value).toString());
    }
    if (typeof item.value === "string") {
      row.dataset.popoverId = item.value;
    }
    row.classList.toggle(`ag-charts-menu__row--active`, active);
    if (item.icon != null) {
      const icon = createElement2("span", `ag-charts-menu__icon ${domManager.getIconClassNames(item.icon)}`);
      row.appendChild(icon);
    }
    const strokeWidthVisible = item.strokeWidth != null;
    if (strokeWidthVisible) {
      row.classList.toggle(`ag-charts-menu__row--stroke-width-visible`, strokeWidthVisible);
      row.style.setProperty("--strokeWidth", strokeWidthVisible ? `${item.strokeWidth}px` : null);
    }
    if (item.label != null) {
      const label = createElement2("span", "ag-charts-menu__label");
      label.textContent = this.ctx.localeManager.t(item.label);
      row.appendChild(label);
    }
    if (item.altText != null) {
      row.ariaLabel = this.ctx.localeManager.t(item.altText);
    }
    const select = () => {
      options.onPress?.(item);
    };
    const onclick = (e) => {
      if (isButtonClickEvent(e)) {
        select();
        e.preventDefault();
        e.stopPropagation();
      }
    };
    row.addEventListener("keydown", onclick);
    row.addEventListener("click", onclick);
    row.addEventListener("mousemove", () => {
      row.focus();
    });
    return row;
  }
};

// packages/ag-charts-enterprise/src/utils/position.ts
import { _ModuleSupport as _ModuleSupport16 } from "ag-charts-community";
var { ChartAxisDirection: ChartAxisDirection6 } = _ModuleSupport16;
function calculateAxisLabelPosition({
  x,
  y,
  labelBBox,
  bounds,
  axisPosition,
  axisDirection,
  padding
}) {
  let coordinates;
  if (axisDirection === ChartAxisDirection6.X) {
    const alignmentShift = 4;
    const xOffset = -labelBBox.width / 2;
    const yOffset = axisPosition === "bottom" ? -alignmentShift : -labelBBox.height + alignmentShift;
    const fixedY = axisPosition === "bottom" ? bounds.y + bounds.height + padding : bounds.y - padding;
    coordinates = {
      x: x + xOffset,
      y: fixedY + yOffset
    };
  } else {
    const alignmentShift = 8;
    const yOffset = -labelBBox.height / 2;
    const xOffset = axisPosition === "right" ? -alignmentShift : -labelBBox.width + alignmentShift;
    const fixedX = axisPosition === "right" ? bounds.x + bounds.width + padding : bounds.x - padding;
    coordinates = {
      x: fixedX + xOffset,
      y: y + yOffset
    };
  }
  return coordinates;
}
function buildBounds(rect, axisPosition, padding) {
  const bounds = rect.clone();
  bounds.x += axisPosition === "left" ? -padding : 0;
  bounds.y += axisPosition === "top" ? -padding : 0;
  bounds.width += axisPosition === "left" || axisPosition === "right" ? padding : 0;
  bounds.height += axisPosition === "top" || axisPosition === "bottom" ? padding : 0;
  return bounds;
}

// packages/ag-charts-enterprise/src/features/color-picker/colorPicker.ts
import { _ModuleSupport as _ModuleSupport17, _Util as _Util11 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/color-picker/colorPickerTemplate.html
var colorPickerTemplate_default = '<div class="ag-charts-color-picker__palette" tabindex="0"></div><input class="ag-charts-color-picker__hue-input" tabindex="0" type="range" min="0" max="360" value="0"> <input class="ag-charts-color-picker__alpha-input" tabindex="0" type="range" min="0" max="1" value="1" step="0.01"> <label class="ag-charts-color-picker__color-field"><span class="ag-charts-color-picker__color-label">Color</span> <input class="ag-charts-color-picker__color-input" tabindex="0" value="#000"></label>';

// packages/ag-charts-enterprise/src/features/color-picker/colorPicker.ts
var { createElement: createElement3 } = _ModuleSupport17;
var { Color, clamp: clamp2 } = _Util11;
var getHsva = (input) => {
  try {
    const color = Color.fromString(input);
    const [h, s, v] = color.toHSB();
    return [h, s, v, color.a];
  } catch {
    return;
  }
};
var ColorPicker = class extends AnchoredPopover {
  constructor(ctx, options) {
    super(ctx, "color-picker", options);
    this.hasChanged = false;
    this.hideFns.push(() => {
      if (this.hasChanged)
        this.onChangeHide?.();
    });
  }
  show(options) {
    this.hasChanged = false;
    this.onChangeHide = options.onChangeHide;
    const { element, initialFocus } = this.createColorPicker(options);
    const popover = this.showWithChildren([element], { initialFocus, ...options });
    popover.classList.add("ag-charts-color-picker");
    popover.setAttribute("role", "dialog");
  }
  createColorPicker(opts) {
    let [h, s, v, a] = getHsva(opts.color ?? "#f00") ?? [0, 1, 0.5, 1];
    a = opts.opacity ?? a;
    const colorPicker = createElement3("div", "ag-charts-color-picker__content");
    colorPicker.innerHTML = colorPickerTemplate_default;
    colorPicker.ariaLabel = this.ctx.localeManager.t("ariaLabelColorPicker");
    const paletteInput = colorPicker.querySelector(".ag-charts-color-picker__palette");
    const hueInput = colorPicker.querySelector(".ag-charts-color-picker__hue-input");
    const alphaInput = colorPicker.querySelector(".ag-charts-color-picker__alpha-input");
    const colorInput = colorPicker.querySelector(".ag-charts-color-picker__color-input");
    const update = (trackChange = true) => {
      const color = Color.fromHSB(h, s, v, a);
      const colorString = color.toHexString();
      colorPicker.style.setProperty("--h", `${h}`);
      colorPicker.style.setProperty("--s", `${s}`);
      colorPicker.style.setProperty("--v", `${v}`);
      colorPicker.style.setProperty("--a", `${a}`);
      colorPicker.style.setProperty("--color", colorString.slice(0, 7));
      colorPicker.style.setProperty("--color-a", colorString);
      hueInput.value = `${h}`;
      alphaInput.value = `${a}`;
      alphaInput.classList.toggle("ag-charts-color-picker__alpha-input--opaque", a === 1);
      if (document.activeElement !== colorInput) {
        colorInput.value = colorString.toUpperCase();
      }
      if (trackChange || opts.color == null) {
        const plainColor = Color.fromHSB(h, s, v, 1).toHexString();
        opts.onChange?.(colorString, plainColor, a);
      }
      if (trackChange)
        this.hasChanged = true;
    };
    update(false);
    const beginPaletteInteraction = (e) => {
      e.preventDefault();
      const currentTarget = e.currentTarget;
      currentTarget.focus();
      const rect = currentTarget.getBoundingClientRect();
      const mouseMove = ({ pageX, pageY }) => {
        s = Math.min(Math.max((pageX - rect.left) / rect.width, 0), 1);
        v = 1 - Math.min(Math.max((pageY - rect.top) / rect.height, 0), 1);
        update();
      };
      mouseMove(e);
      window.addEventListener("mousemove", mouseMove);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", mouseMove), {
        once: true
      });
    };
    colorPicker.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });
    colorPicker.addEventListener("keydown", (e) => {
      e.stopPropagation();
      switch (e.key) {
        case "Enter":
        case "Escape":
          this.hide();
          break;
        default:
          return;
      }
      e.preventDefault();
    });
    paletteInput.addEventListener("mousedown", beginPaletteInteraction);
    paletteInput.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        s = clamp2(0, s - 0.01, 1);
      } else if (e.key === "ArrowRight") {
        s = clamp2(0, s + 0.01, 1);
      } else if (e.key === "ArrowUp") {
        v = clamp2(0, v + 0.01, 1);
      } else if (e.key === "ArrowDown") {
        v = clamp2(0, v - 0.01, 1);
      } else {
        return;
      }
      e.preventDefault();
      update();
    });
    hueInput.addEventListener("input", (e) => {
      h = e.currentTarget.valueAsNumber ?? 0;
      update();
    });
    alphaInput.addEventListener("input", (e) => {
      a = e.currentTarget.valueAsNumber ?? 0;
      update();
    });
    colorInput.addEventListener("input", (e) => {
      const hsva = getHsva(e.currentTarget.value);
      if (hsva == null)
        return;
      [h, s, v, a] = hsva;
      update();
    });
    colorInput.addEventListener("blur", () => update());
    colorInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.currentTarget.blur();
        update();
      }
    });
    return { element: colorPicker, initialFocus: paletteInput };
  }
};

// packages/ag-charts-enterprise/src/features/text-input/textInput.ts
import { _ModuleSupport as _ModuleSupport18, _Scene as _Scene8 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/text-input/textInputTemplate.html
var textInputTemplate_default = '<div contenteditable="plaintext-only" class="ag-charts-text-input__textarea" tabindex="0"></div>';

// packages/ag-charts-enterprise/src/features/text-input/textInput.ts
var { focusCursorAtEnd } = _ModuleSupport18;
var moduleId = "text-input";
var canvasOverlay2 = "canvas-overlay";
var TextInput = class extends _ModuleSupport18.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.layout = {
      getTextInputCoords: () => ({ x: 0, y: 0 }),
      position: "center",
      alignment: "center",
      textAlign: "center"
    };
    this.element = ctx.domManager.addChild(canvasOverlay2, moduleId);
    this.element.classList.add("ag-charts-text-input");
    this.destroyFns.push(() => ctx.domManager.removeChild(canvasOverlay2, moduleId));
  }
  show(opts) {
    this.element.innerHTML = textInputTemplate_default;
    const textArea = this.element.firstElementChild;
    if (!textArea.isContentEditable) {
      textArea.contentEditable = "true";
    }
    textArea.setAttribute(
      "placeholder",
      this.ctx.localeManager.t(opts.placeholderText ?? "inputTextareaPlaceholder")
    );
    if (opts.styles?.placeholderColor) {
      textArea.style.setProperty("--ag-charts-input-placeholder-color", opts.styles?.placeholderColor);
    }
    textArea.innerText = opts.text ?? "";
    textArea.style.color = opts.styles?.color ?? "inherit";
    textArea.style.fontFamily = opts.styles?.fontFamily ?? "inherit";
    textArea.style.fontSize = opts.styles?.fontSize ? `${opts.styles.fontSize}px` : "inherit";
    textArea.style.fontStyle = opts.styles?.fontStyle ?? "inherit";
    textArea.style.fontWeight = typeof opts.styles?.fontWeight === "number" ? `${opts.styles.fontWeight}` : opts.styles?.fontWeight ?? "inherit";
    focusCursorAtEnd(textArea);
    textArea.addEventListener("input", () => {
      this.updatePosition();
      opts.onChange?.(this.getValue(), this.getBBox());
    });
    textArea.addEventListener("click", (event) => {
      event.stopPropagation();
    });
    if (opts.layout) {
      this.layout = opts.layout;
      this.updatePosition();
    }
    opts.onChange?.(this.getValue(), this.getBBox());
  }
  hide() {
    this.element.innerHTML = "";
    this.layout = {
      getTextInputCoords: () => ({ x: 0, y: 0 }),
      position: "center",
      alignment: "center",
      textAlign: "center"
    };
  }
  updateColor(color) {
    if (!this.element.firstElementChild)
      return;
    this.element.firstElementChild.style.color = color;
  }
  updateFontSize(fontSize) {
    if (!this.element.firstElementChild)
      return;
    this.element.firstElementChild.style.fontSize = `${fontSize}px`;
    this.updatePosition();
    return this.getBBox();
  }
  getValue() {
    if (!this.element.firstElementChild)
      return;
    return this.element.firstElementChild.innerText.trim();
  }
  updatePosition() {
    const { element } = this;
    const textArea = element.firstElementChild;
    if (!textArea)
      return;
    const sceneRect = this.ctx.domManager.getBoundingClientRect();
    const { width, getTextInputCoords, position, alignment, textAlign } = this.layout;
    element.style.setProperty("width", width ? `${width}px` : "unset");
    const textRect = textArea.getBoundingClientRect();
    const point = getTextInputCoords();
    let horizontalPosition = point.x;
    if (alignment === "center") {
      horizontalPosition -= (width ?? textRect.width) / 2;
    } else if (alignment === "right") {
      horizontalPosition -= width ?? textRect.width;
    }
    let verticalPosition = point.y;
    if (position === "center") {
      verticalPosition -= textRect.height / 2;
    } else if (position === "bottom") {
      verticalPosition -= textRect.height;
    }
    element.style.setProperty("top", `${verticalPosition}px`);
    element.style.setProperty("left", `${horizontalPosition}px`);
    element.style.setProperty("max-width", `${sceneRect.width - horizontalPosition}px`);
    element.style.setProperty("text-align", alignment);
    textArea.style.setProperty("text-align", textAlign);
  }
  getBBox() {
    const { left, top, width, height } = this.element.getBoundingClientRect();
    return new _Scene8.BBox(left, top, width, height);
  }
};

// packages/ag-charts-enterprise/src/features/annotations/annotationDefaults.ts
import { _Util as _Util23 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/annotationTypes.ts
var AnnotationType = /* @__PURE__ */ ((AnnotationType3) => {
  AnnotationType3["Line"] = "line";
  AnnotationType3["HorizontalLine"] = "horizontal-line";
  AnnotationType3["VerticalLine"] = "vertical-line";
  AnnotationType3["DisjointChannel"] = "disjoint-channel";
  AnnotationType3["ParallelChannel"] = "parallel-channel";
  AnnotationType3["Callout"] = "callout";
  AnnotationType3["Comment"] = "comment";
  AnnotationType3["Note"] = "note";
  AnnotationType3["Text"] = "text";
  AnnotationType3["Arrow"] = "arrow";
  AnnotationType3["ArrowUp"] = "arrow-up";
  AnnotationType3["ArrowDown"] = "arrow-down";
  return AnnotationType3;
})(AnnotationType || {});
var ANNOTATION_TYPES = Object.values(AnnotationType);
var ANNOTATION_BUTTONS = [
  // Lines
  "line" /* Line */,
  "horizontal-line" /* HorizontalLine */,
  "vertical-line" /* VerticalLine */,
  // Channels
  "disjoint-channel" /* DisjointChannel */,
  "parallel-channel" /* ParallelChannel */,
  // Texts
  "callout" /* Callout */,
  "comment" /* Comment */,
  "note" /* Note */,
  "text" /* Text */,
  // Shapes
  "arrow" /* Arrow */,
  "arrow-up" /* ArrowUp */,
  "arrow-down" /* ArrowDown */
];
var ANNOTATION_BUTTON_GROUPS = ["line-menu", "text-menu", "shape-menu"];
function stringToAnnotationType(value) {
  for (const t of ANNOTATION_TYPES) {
    if (t === value)
      return t;
  }
}

// packages/ag-charts-enterprise/src/features/annotations/utils/has.ts
import { _ModuleSupport as _ModuleSupport36 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutProperties.ts
import { _ModuleSupport as _ModuleSupport21, _Util as _Util14 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/annotationProperties.ts
import { _ModuleSupport as _ModuleSupport19, _Util as _Util13 } from "ag-charts-community";
var {
  BOOLEAN: BOOLEAN4,
  COLOR_STRING: COLOR_STRING2,
  DATE,
  FONT_STYLE: FONT_STYLE2,
  FONT_WEIGHT: FONT_WEIGHT2,
  FUNCTION,
  LINE_DASH: LINE_DASH2,
  LINE_STYLE,
  NUMBER: NUMBER3,
  OBJECT: OBJECT4,
  OR: OR2,
  POSITIVE_NUMBER: POSITIVE_NUMBER4,
  RATIO: RATIO4,
  STRING: STRING2,
  TEXT_ALIGN,
  UNION: UNION3,
  BaseProperties: BaseProperties2,
  Validate: Validate11
} = _ModuleSupport19;
var PointProperties = class extends BaseProperties2 {
};
__decorateClass([
  Validate11(OR2(STRING2, NUMBER3, DATE))
], PointProperties.prototype, "x", 2);
__decorateClass([
  Validate11(NUMBER3)
], PointProperties.prototype, "y", 2);
var ChannelAnnotationMiddleProperties = class extends Stroke(LineStyle(Visible(BaseProperties2))) {
};
var AxisLabelProperties = class extends Stroke(LineStyle(Fill(Label(Font(BaseProperties2))))) {
  constructor() {
    super(...arguments);
    this.cornerRadius = 2;
  }
};
__decorateClass([
  Validate11(BOOLEAN4)
], AxisLabelProperties.prototype, "enabled", 2);
__decorateClass([
  Validate11(POSITIVE_NUMBER4)
], AxisLabelProperties.prototype, "cornerRadius", 2);
var BackgroundProperties = class extends Fill(BaseProperties2) {
};
var HandleProperties = class extends Stroke(LineStyle(Fill(BaseProperties2))) {
};
var LineTextProperties = class extends Font(BaseProperties2) {
  constructor() {
    super(...arguments);
    this.label = "";
    this.position = "top";
    this.alignment = "left";
  }
};
__decorateClass([
  Validate11(STRING2)
], LineTextProperties.prototype, "label", 2);
__decorateClass([
  Validate11(UNION3(["top", "center", "bottom"]), { optional: true })
], LineTextProperties.prototype, "position", 2);
__decorateClass([
  Validate11(UNION3(["left", "center", "right"]), { optional: true })
], LineTextProperties.prototype, "alignment", 2);
var ChannelTextProperties = class extends Font(BaseProperties2) {
  constructor() {
    super(...arguments);
    this.label = "";
  }
};
__decorateClass([
  Validate11(STRING2)
], ChannelTextProperties.prototype, "label", 2);
__decorateClass([
  Validate11(UNION3(["top", "inside", "bottom"]), { optional: true })
], ChannelTextProperties.prototype, "position", 2);
__decorateClass([
  Validate11(UNION3(["left", "center", "right"]), { optional: true })
], ChannelTextProperties.prototype, "alignment", 2);
function Annotation(Parent) {
  class AnnotationInternal extends Lockable(Visible(Parent)) {
    constructor() {
      super(...arguments);
      // A uuid is required, over the usual incrementing index, as annotations can be restored from external databases
      this.id = _Util13.uuid();
    }
    isValidWithContext(_context, warningPrefix) {
      return super.isValid(warningPrefix);
    }
  }
  return AnnotationInternal;
}
function Line(Parent) {
  class LineInternal extends Parent {
    constructor() {
      super(...arguments);
      this.start = new PointProperties();
      this.end = new PointProperties();
    }
  }
  __decorateClass([
    Validate11(OBJECT4)
  ], LineInternal.prototype, "start", 2);
  __decorateClass([
    Validate11(OBJECT4)
  ], LineInternal.prototype, "end", 2);
  return LineInternal;
}
function Point(Parent) {
  class PointInternal extends Parent {
  }
  __decorateClass([
    Validate11(OR2(STRING2, NUMBER3, DATE))
  ], PointInternal.prototype, "x", 2);
  __decorateClass([
    Validate11(NUMBER3)
  ], PointInternal.prototype, "y", 2);
  return PointInternal;
}
function Value(Parent) {
  class ValueInternal extends Parent {
  }
  __decorateClass([
    Validate11(OR2(STRING2, NUMBER3, DATE))
  ], ValueInternal.prototype, "value", 2);
  return ValueInternal;
}
function Background(Parent) {
  class BackgroundInternal extends Parent {
    constructor() {
      super(...arguments);
      this.background = new BackgroundProperties();
    }
  }
  __decorateClass([
    Validate11(OBJECT4, { optional: true })
  ], BackgroundInternal.prototype, "background", 2);
  return BackgroundInternal;
}
function Handle(Parent) {
  class HandleInternal extends Parent {
    constructor() {
      super(...arguments);
      this.handle = new HandleProperties();
    }
  }
  __decorateClass([
    Validate11(OBJECT4, { optional: true })
  ], HandleInternal.prototype, "handle", 2);
  return HandleInternal;
}
function AxisLabel(Parent) {
  class AxisLabelInternal extends Parent {
    constructor() {
      super(...arguments);
      this.axisLabel = new AxisLabelProperties();
    }
  }
  __decorateClass([
    Validate11(OBJECT4, { optional: true })
  ], AxisLabelInternal.prototype, "axisLabel", 2);
  return AxisLabelInternal;
}
function Label(Parent) {
  class LabelInternal extends Parent {
    constructor() {
      super(...arguments);
      this.textAlign = "center";
    }
    // TODO: making this generic causes issues with mixins sequence
  }
  __decorateClass([
    Validate11(POSITIVE_NUMBER4, { optional: true })
  ], LabelInternal.prototype, "padding", 2);
  __decorateClass([
    Validate11(TEXT_ALIGN, { optional: true })
  ], LabelInternal.prototype, "textAlign", 2);
  __decorateClass([
    Validate11(FUNCTION, { optional: true })
  ], LabelInternal.prototype, "formatter", 2);
  return LabelInternal;
}
function Cappable(Parent) {
  class CappableInternal extends Parent {
  }
  return CappableInternal;
}
function Extendable(Parent) {
  class ExtendableInternal extends Parent {
  }
  __decorateClass([
    Validate11(BOOLEAN4, { optional: true })
  ], ExtendableInternal.prototype, "extendStart", 2);
  __decorateClass([
    Validate11(BOOLEAN4, { optional: true })
  ], ExtendableInternal.prototype, "extendEnd", 2);
  return ExtendableInternal;
}
function Lockable(Parent) {
  class LockableInternal extends Parent {
  }
  __decorateClass([
    Validate11(BOOLEAN4, { optional: true })
  ], LockableInternal.prototype, "locked", 2);
  return LockableInternal;
}
function Localisable(Parent) {
  class LocalisableInternal extends Parent {
    setLocaleManager(localeManager) {
      this.localeManager = localeManager;
    }
  }
  return LocalisableInternal;
}
function Visible(Parent) {
  class VisibleInternal extends Parent {
  }
  __decorateClass([
    Validate11(BOOLEAN4, { optional: true })
  ], VisibleInternal.prototype, "visible", 2);
  return VisibleInternal;
}
function Fill(Parent) {
  class FillInternal extends Parent {
  }
  __decorateClass([
    Validate11(COLOR_STRING2, { optional: true })
  ], FillInternal.prototype, "fill", 2);
  __decorateClass([
    Validate11(RATIO4, { optional: true })
  ], FillInternal.prototype, "fillOpacity", 2);
  return FillInternal;
}
function Stroke(Parent) {
  class StrokeInternal extends Parent {
  }
  __decorateClass([
    Validate11(COLOR_STRING2, { optional: true })
  ], StrokeInternal.prototype, "stroke", 2);
  __decorateClass([
    Validate11(RATIO4, { optional: true })
  ], StrokeInternal.prototype, "strokeOpacity", 2);
  __decorateClass([
    Validate11(NUMBER3, { optional: true })
  ], StrokeInternal.prototype, "strokeWidth", 2);
  return StrokeInternal;
}
function LineStyle(Parent) {
  class LineDashInternal extends Parent {
  }
  __decorateClass([
    Validate11(LINE_DASH2, { optional: true })
  ], LineDashInternal.prototype, "lineDash", 2);
  __decorateClass([
    Validate11(NUMBER3, { optional: true })
  ], LineDashInternal.prototype, "lineDashOffset", 2);
  __decorateClass([
    Validate11(LINE_STYLE, { optional: true })
  ], LineDashInternal.prototype, "lineStyle", 2);
  return LineDashInternal;
}
function Font(Parent) {
  class FontInternal extends Parent {
    constructor() {
      super(...arguments);
      this.fontSize = 12;
      this.fontFamily = "Verdana, sans-serif";
    }
  }
  __decorateClass([
    Validate11(FONT_STYLE2, { optional: true })
  ], FontInternal.prototype, "fontStyle", 2);
  __decorateClass([
    Validate11(FONT_WEIGHT2, { optional: true })
  ], FontInternal.prototype, "fontWeight", 2);
  __decorateClass([
    Validate11(POSITIVE_NUMBER4)
  ], FontInternal.prototype, "fontSize", 2);
  __decorateClass([
    Validate11(STRING2)
  ], FontInternal.prototype, "fontFamily", 2);
  __decorateClass([
    Validate11(COLOR_STRING2, { optional: true })
  ], FontInternal.prototype, "color", 2);
  return FontInternal;
}

// packages/ag-charts-enterprise/src/features/annotations/properties/textualStartEndProperties.ts
import { _ModuleSupport as _ModuleSupport20 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/utils/values.ts
function convertLine(datum, context) {
  if (datum.start == null || datum.end == null)
    return;
  const start = convertPoint(datum.start, context);
  const end = convertPoint(datum.end, context);
  if (start == null || end == null)
    return;
  return { x1: start.x, y1: start.y, x2: end.x, y2: end.y };
}
function convertPoint(point, context) {
  const x = convert(point.x, context.xAxis);
  const y = convert(point.y, context.yAxis);
  return { x, y };
}
function convert(p, context) {
  if (p == null)
    return 0;
  const halfBandwidth = (context.scaleBandwidth() ?? 0) / 2;
  return context.scaleConvert(p) + halfBandwidth;
}
function invertCoords(coords, context) {
  const x = invert(coords.x, context.xAxis);
  const y = invert(coords.y, context.yAxis);
  return { x, y };
}
function invert(n, context) {
  const halfBandwidth = (context.scaleBandwidth() ?? 0) / 2;
  if (context.continuous) {
    return context.scaleInvert(n - halfBandwidth);
  }
  return context.scaleInvertNearest(n - halfBandwidth);
}

// packages/ag-charts-enterprise/src/features/annotations/properties/textualStartEndProperties.ts
var { STRING: STRING3, BaseProperties: BaseProperties3, Validate: Validate12 } = _ModuleSupport20;
var TextualStartEndProperties = class extends Annotation(Localisable(Line(Handle(Label(Font(BaseProperties3)))))) {
  constructor() {
    super(...arguments);
    this.text = "";
    this.position = "top";
    this.alignment = "left";
    this.placement = "inside";
    this.placeholderText = "inputTextareaPlaceholder";
  }
  isValidWithContext(_context, warningPrefix) {
    return super.isValid(warningPrefix);
  }
  getDefaultColor(_colorPickerType) {
    return this.color;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
  getPlaceholderColor() {
    return void 0;
  }
  getPadding() {
    const { padding = 0 } = this;
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  getText() {
    const isPlaceholder = this.text.length == 0;
    let text2 = this.text;
    if (isPlaceholder) {
      text2 = this.placeholderText ?? "";
      if (this.localeManager)
        text2 = this.localeManager.t(text2);
    }
    return {
      text: text2,
      isPlaceholder
    };
  }
  getTextInputCoords(context) {
    return convertPoint(this.end, context);
  }
};
__decorateClass([
  Validate12(STRING3)
], TextualStartEndProperties.prototype, "text", 2);

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutProperties.ts
var { STRING: STRING4, Validate: Validate13, isObject } = _ModuleSupport21;
var { Color: Color2 } = _Util14;
var DEFAULT_CALLOUT_PADDING = {
  top: 6,
  right: 12,
  bottom: 9,
  left: 12
};
var CalloutProperties = class extends Fill(Stroke(TextualStartEndProperties)) {
  constructor() {
    super(...arguments);
    this.type = "callout" /* Callout */;
    this.position = "bottom";
    this.alignment = "left";
  }
  static is(value) {
    return isObject(value) && value.type === "callout" /* Callout */;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fill;
      case `line-color`:
        return this.stroke;
      case `text-color`:
      default:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
      case `text-color`:
      default:
        return void 0;
    }
  }
  getPlaceholderColor() {
    const { r, g, b } = Color2.fromString(this.color ?? "#888888");
    return new Color2(r, g, b, 0.66).toString();
  }
  getPadding() {
    const { padding } = this;
    if (padding == null) {
      return { ...DEFAULT_CALLOUT_PADDING };
    }
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  getTextInputCoords(context) {
    const coords = super.getTextInputCoords(context);
    const padding = this.getPadding();
    const paddingLeft = typeof padding === "number" ? padding : padding?.left ?? 0;
    const paddingBottom = typeof padding === "number" ? padding : padding?.bottom ?? 0;
    return {
      x: coords.x + paddingLeft,
      y: coords.y - paddingBottom
    };
  }
};
__decorateClass([
  Validate13(STRING4)
], CalloutProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/comment/commentProperties.ts
import { _ModuleSupport as _ModuleSupport23, _Util as _Util15 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/properties/textualPointProperties.ts
import { _ModuleSupport as _ModuleSupport22 } from "ag-charts-community";
var { STRING: STRING5, BaseProperties: BaseProperties4, Validate: Validate14 } = _ModuleSupport22;
var TextualPointProperties = class extends Annotation(Point(Handle(Label(Font(BaseProperties4))))) {
  constructor() {
    super(...arguments);
    this.text = "";
    this.position = "top";
    this.alignment = "left";
    this.placement = "inside";
    this.placeholderText = "inputTextareaPlaceholder";
  }
  isValidWithContext(_context, warningPrefix) {
    return super.isValid(warningPrefix);
  }
  getDefaultColor(_colorPickerType) {
    return this.color;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
  getPlaceholderColor() {
    return void 0;
  }
  getPadding() {
    const { padding = 0 } = this;
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  getText() {
    const isPlaceholder = this.text.length == 0;
    const text2 = !isPlaceholder ? this.text : this.placeholderText ?? "";
    return {
      text: text2,
      isPlaceholder
    };
  }
  getTextInputCoords(context) {
    return convertPoint(this, context);
  }
};
__decorateClass([
  Validate14(STRING5)
], TextualPointProperties.prototype, "text", 2);

// packages/ag-charts-enterprise/src/features/annotations/comment/commentProperties.ts
var { STRING: STRING6, Validate: Validate15, isObject: isObject2 } = _ModuleSupport23;
var { Color: Color3 } = _Util15;
var DEFAULT_COMMENT_PADDING = {
  top: 8,
  right: 14,
  bottom: 8,
  left: 14
};
var CommentProperties = class extends Fill(Stroke(TextualPointProperties)) {
  constructor() {
    super(...arguments);
    this.type = "comment" /* Comment */;
    this.position = "bottom";
    this.alignment = "left";
  }
  static is(value) {
    return isObject2(value) && value.type === "comment" /* Comment */;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fill;
      case `line-color`:
        return this.stroke;
      case `text-color`:
      default:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
      case `text-color`:
      default:
        return void 0;
    }
  }
  getPlaceholderColor() {
    const { r, g, b } = Color3.fromString(this.color ?? "#888888");
    return new Color3(r, g, b, 0.66).toString();
  }
  getPadding() {
    const { padding, fontSize } = this;
    if (padding == null) {
      return {
        top: Math.max(fontSize * 0.4, DEFAULT_COMMENT_PADDING.top),
        bottom: Math.max(fontSize * 0.4, DEFAULT_COMMENT_PADDING.bottom),
        left: Math.max(fontSize * 0.8, DEFAULT_COMMENT_PADDING.left),
        right: Math.max(fontSize * 0.8, DEFAULT_COMMENT_PADDING.right)
      };
    }
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  getTextInputCoords(context) {
    const coords = super.getTextInputCoords(context);
    const padding = this.getPadding();
    return {
      x: coords.x + padding.left,
      y: coords.y - padding.bottom
    };
  }
};
__decorateClass([
  Validate15(STRING6)
], CommentProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/note/noteProperties.ts
import { _ModuleSupport as _ModuleSupport28, _Util as _Util18 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/note/noteScene.ts
import { _ModuleSupport as _ModuleSupport27, _Scene as _Scene13, _Util as _Util17 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/annotationScene.ts
import { _ModuleSupport as _ModuleSupport24, _Scene as _Scene10 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/handle.ts
import { _Scene as _Scene9 } from "ag-charts-community";
var _Handle = class _Handle extends _Scene9.Group {
  constructor() {
    super(...arguments);
    this.active = false;
    this.locked = false;
    this.visible = false;
    this.zIndex = 1;
  }
  drag(target) {
    const { handle: handle2, locked } = this;
    if (locked) {
      return { point: { x: handle2.x, y: handle2.y }, offset: { x: 0, y: 0 } };
    }
    return {
      point: target,
      offset: { x: target.x - handle2.x, y: target.y - handle2.y }
    };
  }
  toggleActive(active) {
    this.active = active;
    if (!active) {
      this.handle.strokeWidth = _Handle.INACTIVE_STROKE_WIDTH;
    }
  }
  toggleHovered(hovered) {
    this.glow.visible = !this.locked && hovered;
    this.glow.dirtyPath = true;
  }
  toggleDragging(dragging) {
    if (this.locked)
      return;
    this.handle.visible = !dragging;
    this.glow.visible = this.glow.visible && !dragging;
    this.handle.dirtyPath = true;
    this.glow.dirtyPath = true;
  }
  toggleLocked(locked) {
    this.locked = locked;
  }
  getCursor() {
    return void 0;
  }
  containsPoint(x, y) {
    return this.handle.containsPoint(x, y);
  }
};
_Handle.INACTIVE_STROKE_WIDTH = 2;
var Handle2 = _Handle;
var _InvariantHandle = class _InvariantHandle extends Handle2 {
  constructor() {
    super();
    this.handle = new _Scene9.Circle();
    this.glow = new _Scene9.Circle();
    this.append([this.handle]);
    this.handle.size = _InvariantHandle.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
  }
  update(styles) {
    this.handle.setProperties({ ...styles, strokeWidth: Handle2.INACTIVE_STROKE_WIDTH });
  }
  drag(target) {
    return { point: target, offset: { x: 0, y: 0 } };
  }
};
_InvariantHandle.HANDLE_SIZE = 7;
_InvariantHandle.GLOW_SIZE = 9;
var InvariantHandle = _InvariantHandle;
var _UnivariantHandle = class _UnivariantHandle extends Handle2 {
  constructor() {
    super();
    this.handle = new _Scene9.Rect();
    this.glow = new _Scene9.Rect();
    this.gradient = "horizontal";
    this.append([this.glow, this.handle]);
    this.handle.cornerRadius = _UnivariantHandle.CORNER_RADIUS;
    this.handle.width = _UnivariantHandle.HANDLE_SIZE;
    this.handle.height = _UnivariantHandle.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
    this.glow.cornerRadius = _UnivariantHandle.CORNER_RADIUS;
    this.glow.width = _UnivariantHandle.GLOW_SIZE;
    this.glow.height = _UnivariantHandle.GLOW_SIZE;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  toggleLocked(locked) {
    super.toggleLocked(locked);
    if (locked) {
      const offset = (_UnivariantHandle.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;
      this.handle.cornerRadius = 1;
      this.handle.fill = this.handle.stroke;
      this.handle.strokeWidth = 0;
      this.handle.x += offset;
      this.handle.y += offset;
      this.handle.width = InvariantHandle.HANDLE_SIZE;
      this.handle.height = InvariantHandle.HANDLE_SIZE;
      this.glow.width = InvariantHandle.GLOW_SIZE;
      this.glow.height = InvariantHandle.GLOW_SIZE;
    } else {
      this.handle.cornerRadius = _UnivariantHandle.CORNER_RADIUS;
      this.handle.width = _UnivariantHandle.HANDLE_SIZE;
      this.handle.height = _UnivariantHandle.HANDLE_SIZE;
      this.glow.width = _UnivariantHandle.GLOW_SIZE;
      this.glow.height = _UnivariantHandle.GLOW_SIZE;
      if (this.cachedStyles) {
        this.handle.setProperties(this.cachedStyles);
      }
    }
  }
  update(styles) {
    this.cachedStyles = { ...styles };
    if (!this.active) {
      delete styles.strokeWidth;
    }
    if (this.locked) {
      delete styles.fill;
      delete styles.strokeWidth;
      const offset = (_UnivariantHandle.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;
      styles.x -= offset;
      styles.y -= offset;
      this.cachedStyles.x -= offset;
      this.cachedStyles.y -= offset;
    }
    this.handle.setProperties(styles);
    this.glow.setProperties({
      ...styles,
      x: (styles.x ?? this.glow.x) - 2,
      y: (styles.y ?? this.glow.y) - 2,
      strokeWidth: 0,
      fill: styles.stroke
    });
  }
  drag(target) {
    if (this.locked) {
      return { point: target, offset: { x: 0, y: 0 } };
    }
    if (this.gradient === "vertical") {
      return {
        point: { x: target.x, y: this.handle.y },
        offset: { x: target.x - this.handle.x, y: 0 }
      };
    }
    return {
      point: { x: this.handle.x, y: target.y },
      offset: { x: 0, y: target.y - this.handle.y }
    };
  }
  getCursor() {
    if (this.locked)
      return;
    return this.gradient === "vertical" ? "col-resize" : "row-resize";
  }
};
_UnivariantHandle.HANDLE_SIZE = 12;
_UnivariantHandle.GLOW_SIZE = 16;
_UnivariantHandle.CORNER_RADIUS = 4;
var UnivariantHandle = _UnivariantHandle;
var _DivariantHandle = class _DivariantHandle extends Handle2 {
  constructor() {
    super();
    this.handle = new _Scene9.Circle();
    this.glow = new _Scene9.Circle();
    this.append([this.glow, this.handle]);
    this.handle.size = _DivariantHandle.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
    this.glow.size = _DivariantHandle.GLOW_SIZE;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  toggleLocked(locked) {
    super.toggleLocked(locked);
    if (locked) {
      this.handle.fill = this.handle.stroke;
      this.handle.strokeWidth = 0;
      this.handle.size = InvariantHandle.HANDLE_SIZE;
      this.glow.size = InvariantHandle.GLOW_SIZE;
    } else {
      this.handle.size = _DivariantHandle.HANDLE_SIZE;
      this.glow.size = _DivariantHandle.GLOW_SIZE;
      if (this.cachedStyles) {
        this.handle.setProperties(this.cachedStyles);
      }
    }
  }
  update(styles) {
    this.cachedStyles = { ...styles };
    if (!this.active) {
      delete styles.strokeWidth;
    }
    if (this.locked) {
      delete styles.fill;
      delete styles.strokeWidth;
    }
    this.handle.setProperties(styles);
    this.glow.setProperties({ ...styles, strokeWidth: 0, fill: styles.stroke });
  }
};
_DivariantHandle.HANDLE_SIZE = 11;
_DivariantHandle.GLOW_SIZE = 17;
var DivariantHandle = _DivariantHandle;

// packages/ag-charts-enterprise/src/features/annotations/scenes/annotationScene.ts
var { Layers: Layers3, isObject: isObject3 } = _ModuleSupport24;
var AnnotationScene = class extends _Scene10.Group {
  constructor() {
    super(...arguments);
    this.name = "AnnotationScene";
    this.zIndex = Layers3.CHART_ANNOTATION_ZINDEX;
  }
  static isCheck(value, type) {
    return isObject3(value) && Object.hasOwn(value, "type") && value.type === type;
  }
  toggleHovered(hovered) {
    this.toggleHandles(hovered);
  }
  computeBBoxWithoutHandles() {
    return _Scene10.Transformable.toCanvas(
      this,
      _Scene10.Group.computeChildrenBBox(this.children.filter((node) => !(node instanceof Handle2)))
    );
  }
};

// packages/ag-charts-enterprise/src/features/annotations/scenes/textualPointScene.ts
import { _Scene as _Scene12, _Util as _Util16 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/text/util.ts
import { _ModuleSupport as _ModuleSupport25, _Scene as _Scene11 } from "ag-charts-community";
var { TextWrapper: TextWrapper2, CachedTextMeasurerPool } = _ModuleSupport25;
var { BBox } = _Scene11;
var ANNOTATION_TEXT_LINE_HEIGHT = 1.38;
function getTextWrapOptions(options) {
  return {
    font: {
      fontFamily: options.fontFamily,
      fontSize: options.fontSize,
      fontStyle: options.fontStyle,
      fontWeight: options.fontWeight
    },
    textAlign: options.textAlign,
    textBaseline: options.position == "center" ? "middle" : options.position,
    lineHeight: ANNOTATION_TEXT_LINE_HEIGHT,
    avoidOrphans: false,
    textWrap: "always"
  };
}
function wrapText(options, text2, width) {
  return width ? TextWrapper2.wrapText(text2, {
    ...getTextWrapOptions(options),
    maxWidth: width
  }) : text2;
}
function measureAnnotationText(options, text2) {
  const textOptions = getTextWrapOptions(options);
  const { lineMetrics, width } = CachedTextMeasurerPool.measureLines(text2, textOptions);
  const height = lineMetrics.length * (options.fontSize ?? 14) * ANNOTATION_TEXT_LINE_HEIGHT;
  return {
    width,
    height
  };
}
function getBBox(options, text2, coords, bbox) {
  let width = bbox?.width ?? 0;
  let height = bbox?.height ?? 0;
  if (!bbox) {
    const wrappedText = options.width != null ? wrapText(options, text2, options.width) : text2;
    ({ width, height } = measureAnnotationText(options, wrappedText));
  }
  return new BBox(coords.x, coords.y, width, height);
}
function updateTextNode(node, text2, isPlaceholder, config, { x, y }) {
  const { visible = true, fontFamily, fontSize = 14, fontStyle, fontWeight, textAlign } = config;
  const lineHeight = fontSize * ANNOTATION_TEXT_LINE_HEIGHT;
  const textBaseline = config.position == "center" ? "middle" : config.position;
  const fill = isPlaceholder ? config.getPlaceholderColor() : config.color;
  node.setProperties({
    x,
    y,
    visible,
    text: text2,
    fill,
    fontFamily,
    fontSize,
    fontStyle,
    fontWeight,
    textAlign,
    lineHeight,
    textBaseline
  });
}

// packages/ag-charts-enterprise/src/features/annotations/scenes/textualPointScene.ts
var { Vec2 } = _Util16;
var TextualPointScene = class extends AnnotationScene {
  constructor() {
    super(...arguments);
    this.label = new _Scene12.Text({ zIndex: 1 });
    this.handle = new DivariantHandle();
    this.anchor = {
      x: 0,
      y: 0,
      position: "above-left"
    };
  }
  setTextInputBBox(bbox) {
    this.textInputBBox = bbox;
    this.markDirty(this, _Scene12.RedrawType.MINOR);
  }
  update(datum, context) {
    const coords = convertPoint(datum, context);
    const bbox = this.getTextBBox(datum, coords, context);
    this.updateLabel(datum, bbox);
    this.updateHandle(datum, bbox, coords);
    this.updateShape(datum, bbox);
    this.anchor = this.updateAnchor(datum, bbox, context);
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      handle: convertPoint(datum, context)
    };
  }
  drag(datum, target, context) {
    const { dragState } = this;
    if (datum.locked || !dragState)
      return;
    const coords = Vec2.add(dragState.handle, Vec2.sub(target, dragState.offset));
    const point = invertCoords(coords, context);
    datum.x = point.x;
    datum.y = point.y;
  }
  copy(datum, copiedDatum, context) {
    const coords = convertPoint(datum, context);
    const bbox = this.getTextBBox(datum, coords, context);
    const padding = datum.getPadding();
    const horizontalPadding = padding.left + padding.right;
    const verticalPadding = padding.top + padding.bottom;
    const xOffset = (bbox.width + horizontalPadding) / 2;
    const yOffset = bbox.height + verticalPadding;
    const point = invertCoords({ x: coords.x - xOffset, y: coords.y - yOffset }, context);
    copiedDatum.x = point.x;
    copiedDatum.y = point.y;
    return copiedDatum;
  }
  toggleHandles(show) {
    this.handle.visible = Boolean(show);
    this.handle.toggleHovered(this.activeHandle === "handle");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.handle.toggleActive(active);
  }
  stopDragging() {
    this.handle.toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
  }
  containsPoint(x, y) {
    const { handle: handle2, label } = this;
    this.activeHandle = void 0;
    if (handle2.containsPoint(x, y)) {
      this.activeHandle = "handle";
      return true;
    }
    return label.visible && label.containsPoint(x, y);
  }
  getTextBBox(datum, coords, _context) {
    const { text: text2 } = datum.getText();
    return getBBox(datum, text2, { x: coords.x, y: coords.y }, this.textInputBBox);
  }
  updateLabel(datum, bbox) {
    const { text: text2, isPlaceholder } = datum.getText();
    const wrappedText = wrapText(datum, text2, bbox.width);
    if (!isPlaceholder) {
      datum.set({ text: wrappedText });
    }
    updateTextNode(this.label, wrappedText, isPlaceholder, datum, this.getLabelCoords(datum, bbox));
  }
  updateHandle(datum, bbox, coords) {
    const { x, y } = this.getHandleCoords(datum, bbox, coords);
    const styles = this.getHandleStyles(datum);
    this.handle.update({ ...styles, x, y });
    this.handle.toggleLocked(datum.locked ?? false);
  }
  updateShape(_datum, _bbox) {
  }
  updateAnchor(_datum, bbox, context) {
    return {
      x: bbox.x + context.seriesRect.x,
      y: bbox.y + context.seriesRect.y - bbox.height,
      position: this.anchor.position
    };
  }
  getLabelCoords(_datum, bbox) {
    return bbox;
  }
  getHandleCoords(_datum, bbox, _coords) {
    return bbox;
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.color,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
};

// packages/ag-charts-enterprise/src/features/annotations/note/noteScene.ts
var ICON_HEIGHT = 20;
var ICON_WIDTH = 22;
var ICON_SPACING = 10;
var LABEL_OFFSET = ICON_HEIGHT + ICON_SPACING;
var { Layers: Layers4, TextWrapper: TextWrapper3 } = _ModuleSupport27;
var { clamp: clamp3 } = _Util17;
var NoteScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "note" /* Note */;
    this.shape = new _Scene13.Rect();
    this.iconBackground = new _Scene13.SvgPath(
      "M22 1.83333C22 0.820811 21.1792 0 20.1667 0H1.83333C0.820811 0 0 0.82081 0 1.83333V13.9868C0 14.9994 0.820811 15.8202 1.83333 15.8202L5.88971 15.8202C6.44575 15.8202 6.97175 16.0725 7.31971 16.5062L9.57006 19.3112C10.304 20.2259 11.6962 20.2259 12.4301 19.3112L14.6804 16.5062C15.0284 16.0725 15.5544 15.8202 16.1104 15.8202L20.1667 15.8202C21.1792 15.8202 22 14.9994 22 13.9868V1.83333Z"
    );
    this.iconLines = new _Scene13.SvgPath(
      "M17.1114 5.75C17.1114 6.16421 16.7756 6.5 16.3614 6.5H5.63916C5.22495 6.5 4.88916 6.16421 4.88916 5.75V5.75C4.88916 5.33579 5.22495 5 5.63916 5H16.3614C16.7756 5 17.1114 5.33579 17.1114 5.75V5.75ZM17.1114 9.25C17.1114 9.66421 16.7756 10 16.3614 10H5.63916C5.22495 10 4.88916 9.66421 4.88916 9.25V9.25C4.88916 8.83579 5.22495 8.5 5.63916 8.5H16.3614C16.7756 8.5 17.1114 8.83579 17.1114 9.25V9.25Z"
    );
    this.active = false;
    this.shape.visible = false;
    this.label.visible = false;
    this.iconBackground.fillShadow = new _Scene13.DropShadow();
    this.append([this.shape, this.label, this.iconLines, this.iconBackground, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "note" /* Note */);
  }
  update(datum, context) {
    this.updateIcon(datum, context);
    super.update(datum, context);
  }
  getTextBBox(datum, coords, context) {
    const { seriesRect } = context;
    const bbox = super.getTextBBox(datum, coords, context);
    bbox.x = clamp3(datum.width / 2, bbox.x, seriesRect.width - bbox.width / 2);
    return bbox;
  }
  updateLabel(datum, bbox) {
    const labelVisibility = datum.visible === false ? false : this.label.visible;
    super.updateLabel(datum, bbox);
    this.label.visible = labelVisibility;
    this.label.text = TextWrapper3.wrapText(datum.text, {
      font: {
        fontFamily: datum.fontFamily,
        fontSize: datum.fontSize,
        fontStyle: datum.fontStyle,
        fontWeight: datum.fontWeight
      },
      avoidOrphans: false,
      textAlign: datum.textAlign,
      textBaseline: "hanging",
      textWrap: "always",
      maxWidth: 200
    });
  }
  updateShape(datum, bbox) {
    const { shape } = this;
    shape.fill = datum.background.fill;
    shape.fillOpacity = datum.background.fillOpacity ?? 1;
    shape.stroke = datum.background.stroke;
    shape.strokeOpacity = datum.background.strokeOpacity ?? 1;
    shape.strokeWidth = datum.background.strokeWidth ?? 1;
    shape.cornerRadius = 4;
    const padding = datum.getPadding().top;
    shape.x = bbox.x - datum.width / 2 - padding;
    shape.width = datum.width + padding * 2;
    shape.height = bbox.height + padding * 2;
    shape.y = bbox.y - shape.height - LABEL_OFFSET;
  }
  updateIcon(datum, context) {
    const { active, iconBackground, iconLines } = this;
    const { x, y } = convertPoint(datum, context);
    iconBackground.x = x - ICON_WIDTH / 2;
    iconBackground.y = y - ICON_HEIGHT;
    iconLines.x = iconBackground.x;
    iconLines.y = iconBackground.y;
    iconBackground.fill = datum.fill;
    iconBackground.fillOpacity = datum.fillOpacity ?? 1;
    iconBackground.stroke = datum.stroke;
    iconBackground.strokeOpacity = datum.strokeOpacity ?? 1;
    iconBackground.strokeWidth = datum.strokeWidth ?? 1;
    iconLines.fill = datum.stroke;
    if (active) {
      iconBackground.fillShadow.color = datum.fill ?? "rgba(0, 0, 0, 0.22)";
    } else {
      iconBackground.fillShadow.color = "rgba(0, 0, 0, 0.22)";
    }
  }
  updateAnchor(datum, bbox, context) {
    const anchor = super.updateAnchor(datum, bbox, context);
    const padding = datum.getPadding().top;
    return {
      x: anchor.x,
      y: anchor.y - padding * 2 - LABEL_OFFSET,
      position: "above"
    };
  }
  getLabelCoords(datum, bbox) {
    const padding = datum.getPadding().top;
    return {
      x: bbox.x - datum.width / 2,
      y: bbox.y - LABEL_OFFSET - padding
    };
  }
  getHandleCoords(_datum, _bbox, coords) {
    return {
      x: coords.x,
      y: coords.y + DivariantHandle.HANDLE_SIZE / 2 + 4
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.fill,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
  toggleHovered(hovered) {
    super.toggleHovered(hovered);
    this.label.visible = hovered;
    this.shape.visible = hovered;
    this.zIndex = hovered ? Layers4.CHART_ANNOTATION_FOCUSED_ZINDEX : Layers4.CHART_ANNOTATION_ZINDEX;
  }
  toggleActive(active) {
    super.toggleActive(active);
    this.label.visible = active;
    this.shape.visible = active;
    this.active = active;
  }
  containsPoint(x, y) {
    if (this.shape.visible && this.shape.containsPoint(x, y))
      return true;
    if (this.iconBackground.containsPoint(x, y))
      return true;
    return super.containsPoint(x, y);
  }
};

// packages/ag-charts-enterprise/src/features/annotations/note/noteProperties.ts
var { OBJECT: OBJECT5, STRING: STRING7, BaseProperties: BaseProperties5, Validate: Validate16, isObject: isObject4 } = _ModuleSupport28;
var { clamp: clamp4 } = _Util18;
var DEFAULT_NOTE_PADDING = 10;
var NoteBackgroundProperties = class extends Fill(Stroke(BaseProperties5)) {
};
var NoteProperties = class extends Fill(Stroke(TextualPointProperties)) {
  constructor() {
    super(...arguments);
    this.type = "note" /* Note */;
    this.background = new NoteBackgroundProperties();
    this.position = "bottom";
    this.alignment = "center";
    this.width = 200;
  }
  static is(value) {
    return isObject4(value) && value.type === "note" /* Note */;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `line-color`:
        return this.fill;
      case `text-color`:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `line-color`:
        return this.fillOpacity;
      case `text-color`:
        return void 0;
    }
  }
  getPadding() {
    const padding = this.padding ?? DEFAULT_NOTE_PADDING;
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  getTextInputCoords(context) {
    const { width } = this;
    const { seriesRect } = context;
    const coords = super.getTextInputCoords(context);
    const padding = this.getPadding();
    coords.x = clamp4(width / 2, coords.x, seriesRect.width - width / 2);
    coords.y = coords.y - padding.top - LABEL_OFFSET;
    return coords;
  }
};
__decorateClass([
  Validate16(STRING7)
], NoteProperties.prototype, "type", 2);
__decorateClass([
  Validate16(OBJECT5, { optional: true })
], NoteProperties.prototype, "background", 2);

// packages/ag-charts-enterprise/src/features/annotations/properties/shapePointProperties.ts
import "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/properties/pointProperties.ts
import { _ModuleSupport as _ModuleSupport29 } from "ag-charts-community";
var { BaseProperties: BaseProperties6 } = _ModuleSupport29;
var PointProperties2 = class extends Annotation(Point(Handle(BaseProperties6))) {
  isValidWithContext(_context, warningPrefix) {
    return super.isValid(warningPrefix);
  }
  getDefaultColor(_colorPickerType) {
    return void 0;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/properties/shapePointProperties.ts
var ShapePointProperties = class _ShapePointProperties extends Fill(PointProperties2) {
  constructor() {
    super(...arguments);
    this.size = 32;
  }
  static is(value) {
    return value instanceof _ShapePointProperties;
  }
  getDefaultColor(colorPickerType) {
    return colorPickerType === `fill-color` ? this.fill : void 0;
  }
  getDefaultOpacity(colorPickerType) {
    return colorPickerType === `fill-color` ? this.fillOpacity : void 0;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineProperties.ts
import { _ModuleSupport as _ModuleSupport31 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/utils/line.ts
import { _Util as _Util19 } from "ag-charts-community";
var { Vec2: Vec22 } = _Util19;
function getLineStyle(lineDash, lineStyle) {
  return lineDash ? "dashed" : lineStyle ?? "solid";
}
function getComputedLineDash(strokeWidth, styleType) {
  switch (styleType) {
    case "solid":
      return [];
    case "dashed":
      return [strokeWidth * 4, strokeWidth * 2];
    case "dotted":
      return [0, strokeWidth * 2];
  }
}
function getLineDash(lineDash, computedLineDash, lineStyle, strokeWidth) {
  const styleType = getLineStyle(lineDash, lineStyle);
  return computedLineDash ?? lineDash ?? getComputedLineDash(strokeWidth ?? 1, styleType);
}
function getLineCap(lineCap, lineDash, lineStyle) {
  const styleType = getLineStyle(lineDash, lineStyle);
  return lineCap ?? styleType === "dotted" ? "round" : void 0;
}
function boundsIntersections({ x1, y1, x2, y2 }, bounds) {
  const p1 = Vec22.from(x1, y1);
  const p2 = Vec22.from(x2, y2);
  const reflection = bounds.height;
  const gradient = Vec22.gradient(p2, p1, reflection);
  const intercept = Vec22.intercept(p2, gradient, reflection);
  const fallback = [
    { x: p1.x, y: reflection == null ? 0 : reflection },
    { x: p1.x, y: reflection == null ? bounds.height : reflection - bounds.height }
  ];
  if (gradient === Infinity) {
    return fallback;
  }
  let points = [
    Vec22.intersectAtY(gradient, intercept, 0, reflection),
    Vec22.intersectAtY(gradient, intercept, bounds.height, reflection),
    Vec22.intersectAtX(gradient, intercept, 0, reflection),
    Vec22.intersectAtX(gradient, intercept, bounds.width, reflection)
  ];
  points = points.filter((p) => p.x >= bounds.x && p.x <= bounds.width && p.y >= bounds.y && p.y <= bounds.height).sort((a, b) => {
    if (a.x === b.x)
      return 0;
    return a.x < b.x ? -1 : 1;
  });
  if (points.length !== 2) {
    return fallback;
  }
  return points;
}

// packages/ag-charts-enterprise/src/features/annotations/utils/validation.ts
import { _Util as _Util20 } from "ag-charts-community";
var { Logger } = _Util20;
function validateDatumLine(context, datum, warningPrefix) {
  let valid = true;
  valid && (valid = validateDatumPoint(context, datum.start, warningPrefix && `${warningPrefix}[start] `));
  valid && (valid = validateDatumPoint(context, datum.end, warningPrefix && `${warningPrefix}[end] `));
  return valid;
}
function validateDatumValue(context, datum, warningPrefix) {
  const axis = datum.direction === "horizontal" ? context.yAxis : context.xAxis;
  const valid = validateDatumPointDirection(datum.value, axis);
  if (!valid && warningPrefix) {
    Logger.warnOnce(`${warningPrefix}is outside the axis domain, ignoring. - value: [${datum.value}]]`);
  }
  return valid;
}
function validateDatumPoint(context, point, warningPrefix) {
  if (point.x == null || point.y == null) {
    if (warningPrefix) {
      Logger.warnOnce(`${warningPrefix}requires both an [x] and [y] property, ignoring.`);
    }
    return false;
  }
  const validX = validateDatumPointDirection(point.x, context.xAxis);
  const validY = validateDatumPointDirection(point.y, context.yAxis);
  if (!validX || !validY) {
    let text2 = "x & y domains";
    if (validX)
      text2 = "y domain";
    if (validY)
      text2 = "x domain";
    if (warningPrefix) {
      Logger.warnOnce(`${warningPrefix}is outside the ${text2}, ignoring. - x: [${point.x}], y: ${point.y}]`);
    }
    return false;
  }
  return true;
}
function validateDatumPointDirection(value, context) {
  const domain = context.scaleDomain();
  if (domain && context.continuous) {
    return value >= domain[0] && value <= domain.at(-1);
  }
  return true;
}

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineProperties.ts
var { OBJECT: OBJECT6, STRING: STRING8, BaseProperties: BaseProperties7, Validate: Validate17, isObject: isObject5 } = _ModuleSupport31;
var HorizontalLineProperties = class extends Annotation(Value(Handle(AxisLabel(Stroke(LineStyle(BaseProperties7)))))) {
  constructor() {
    super(...arguments);
    this.direction = "horizontal";
    this.type = "horizontal-line" /* HorizontalLine */;
    this.text = new LineTextProperties();
    this.lineCap = void 0;
    this.computedLineDash = void 0;
  }
  static is(value) {
    return isObject5(value) && value.type === "horizontal-line" /* HorizontalLine */;
  }
  isValidWithContext(context, warningPrefix) {
    return super.isValid(warningPrefix) && validateDatumValue(context, this, warningPrefix);
  }
  getDefaultColor(_colorPickerType) {
    return this.stroke;
  }
  getDefaultOpacity(_colorPickerType) {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass([
  Validate17(STRING8)
], HorizontalLineProperties.prototype, "type", 2);
__decorateClass([
  Validate17(OBJECT6, { optional: true })
], HorizontalLineProperties.prototype, "text", 2);
var VerticalLineProperties = class extends Annotation(Value(Handle(AxisLabel(Stroke(LineStyle(BaseProperties7)))))) {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
    this.type = "vertical-line" /* VerticalLine */;
    this.text = new LineTextProperties();
    this.lineCap = void 0;
    this.computedLineDash = void 0;
  }
  static is(value) {
    return isObject5(value) && value.type === "vertical-line" /* VerticalLine */;
  }
  isValidWithContext(context, warningPrefix) {
    return super.isValid(warningPrefix) && validateDatumValue(context, this, warningPrefix);
  }
  getDefaultColor(_colorPickerType) {
    return this.stroke;
  }
  getDefaultOpacity(_colorPickerType) {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass([
  Validate17(STRING8)
], VerticalLineProperties.prototype, "type", 2);
__decorateClass([
  Validate17(OBJECT6, { optional: true })
], VerticalLineProperties.prototype, "text", 2);

// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelProperties.ts
import { _ModuleSupport as _ModuleSupport32, _Util as _Util21 } from "ag-charts-community";
var { NUMBER: NUMBER4, OBJECT: OBJECT7, STRING: STRING9, BaseProperties: BaseProperties8, Validate: Validate18, isObject: isObject6 } = _ModuleSupport32;
var DisjointChannelProperties = class extends Annotation(
  Background(Line(Handle(Extendable(Stroke(LineStyle(BaseProperties8))))))
) {
  constructor() {
    super(...arguments);
    this.type = "disjoint-channel" /* DisjointChannel */;
    this.text = new ChannelTextProperties();
    this.lineCap = void 0;
    this.computedLineDash = void 0;
  }
  static is(value) {
    return isObject6(value) && value.type === "disjoint-channel" /* DisjointChannel */;
  }
  get bottom() {
    const bottom = {
      start: { x: this.start.x, y: this.start.y },
      end: { x: this.end.x, y: this.end.y }
    };
    if (typeof bottom.start.y === "number" && typeof bottom.end.y === "number") {
      bottom.start.y -= this.startHeight;
      bottom.end.y -= this.endHeight;
    } else {
      _Util21.Logger.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);
    }
    return bottom;
  }
  isValidWithContext(context, warningPrefix) {
    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix) && validateDatumLine(context, this.bottom, warningPrefix);
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fill;
      case `line-color`:
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
    }
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass([
  Validate18(STRING9)
], DisjointChannelProperties.prototype, "type", 2);
__decorateClass([
  Validate18(NUMBER4)
], DisjointChannelProperties.prototype, "startHeight", 2);
__decorateClass([
  Validate18(NUMBER4)
], DisjointChannelProperties.prototype, "endHeight", 2);
__decorateClass([
  Validate18(OBJECT7, { optional: true })
], DisjointChannelProperties.prototype, "text", 2);

// packages/ag-charts-enterprise/src/features/annotations/line/lineProperties.ts
import { _ModuleSupport as _ModuleSupport33 } from "ag-charts-community";
var { OBJECT: OBJECT8, STRING: STRING10, BaseProperties: BaseProperties9, Validate: Validate19, isObject: isObject7 } = _ModuleSupport33;
var LineTypeProperties = class extends Annotation(
  Line(Handle(Cappable(Extendable(Stroke(LineStyle(BaseProperties9))))))
) {
  constructor() {
    super(...arguments);
    this.text = new LineTextProperties();
    this.lineCap = void 0;
    this.computedLineDash = void 0;
  }
  isValidWithContext(context, warningPrefix) {
    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix);
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case "line-color":
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity(_colorPickerType) {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass([
  Validate19(OBJECT8, { optional: true })
], LineTypeProperties.prototype, "text", 2);
var ArrowProperties = class extends LineTypeProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow" /* Arrow */;
    this.endCap = "arrow";
  }
  static is(value) {
    return isObject7(value) && value.type === "arrow" /* Arrow */;
  }
};
__decorateClass([
  Validate19(STRING10)
], ArrowProperties.prototype, "type", 2);
var LineProperties = class extends LineTypeProperties {
  constructor() {
    super(...arguments);
    this.type = "line" /* Line */;
  }
  static is(value) {
    return isObject7(value) && value.type === "line" /* Line */;
  }
};
__decorateClass([
  Validate19(STRING10)
], LineProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelProperties.ts
import { _ModuleSupport as _ModuleSupport34, _Util as _Util22 } from "ag-charts-community";
var { NUMBER: NUMBER5, STRING: STRING11, OBJECT: OBJECT9, BaseProperties: BaseProperties10, Validate: Validate20, isObject: isObject8 } = _ModuleSupport34;
var ParallelChannelProperties = class extends Annotation(
  Background(Line(Handle(Extendable(Stroke(LineStyle(BaseProperties10))))))
) {
  constructor() {
    super(...arguments);
    this.type = "parallel-channel" /* ParallelChannel */;
    this.middle = new ChannelAnnotationMiddleProperties();
    this.text = new ChannelTextProperties();
    this.lineCap = void 0;
    this.computedLineDash = void 0;
  }
  static is(value) {
    return isObject8(value) && value.type === "parallel-channel" /* ParallelChannel */;
  }
  get bottom() {
    const bottom = {
      start: { x: this.start.x, y: this.start.y },
      end: { x: this.end.x, y: this.end.y }
    };
    if (typeof bottom.start.y === "number" && typeof bottom.end.y === "number") {
      bottom.start.y -= this.height;
      bottom.end.y -= this.height;
    } else {
      _Util22.Logger.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);
    }
    return bottom;
  }
  isValidWithContext(context, warningPrefix) {
    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix) && validateDatumLine(context, this.bottom, warningPrefix);
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fill;
      case `line-color`:
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
    }
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass([
  Validate20(STRING11)
], ParallelChannelProperties.prototype, "type", 2);
__decorateClass([
  Validate20(NUMBER5)
], ParallelChannelProperties.prototype, "height", 2);
__decorateClass([
  Validate20(OBJECT9, { optional: true })
], ParallelChannelProperties.prototype, "middle", 2);
__decorateClass([
  Validate20(OBJECT9, { optional: true })
], ParallelChannelProperties.prototype, "text", 2);

// packages/ag-charts-enterprise/src/features/annotations/text/textProperties.ts
import { _ModuleSupport as _ModuleSupport35 } from "ag-charts-community";
var { STRING: STRING12, Validate: Validate21, isObject: isObject9 } = _ModuleSupport35;
var TextProperties = class extends TextualPointProperties {
  constructor() {
    super(...arguments);
    this.type = "text" /* Text */;
    this.position = "bottom";
  }
  static is(value) {
    return isObject9(value) && value.type === "text" /* Text */;
  }
};
__decorateClass([
  Validate21(STRING12)
], TextProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/utils/types.ts
function isLineType(datum) {
  return LineProperties.is(datum) || HorizontalLineProperties.is(datum) || VerticalLineProperties.is(datum) || ArrowProperties.is(datum);
}
function isChannelType(datum) {
  return DisjointChannelProperties.is(datum) || ParallelChannelProperties.is(datum);
}
function isTextType(datum) {
  return CalloutProperties.is(datum) || CommentProperties.is(datum) || NoteProperties.is(datum) || TextProperties.is(datum);
}

// packages/ag-charts-enterprise/src/features/annotations/utils/has.ts
var { isObject: isObject10 } = _ModuleSupport36;
function hasFontSize(datum) {
  return isTextType(datum) && !NoteProperties.is(datum);
}
function hasLineStyle(datum) {
  return isLineType(datum) || isChannelType(datum);
}
function hasLineColor(datum) {
  return isLineType(datum) || isChannelType(datum) || CalloutProperties.is(datum) || NoteProperties.is(datum);
}
function hasIconColor(datum) {
  return NoteProperties.is(datum);
}
function hasFillColor(datum) {
  return isChannelType(datum) || CalloutProperties.is(datum) || CommentProperties.is(datum) || ShapePointProperties.is(datum);
}
function hasTextColor(datum) {
  return isTextType(datum) && !NoteProperties.is(datum);
}
function hasLineText(datum) {
  return (isLineType(datum) || isChannelType(datum)) && isObject10(datum.text);
}

// packages/ag-charts-enterprise/src/features/annotations/utils/styles.ts
function setFontSize(datum, fontSize) {
  if ("fontSize" in datum)
    datum.fontSize = fontSize;
  if (hasLineText(datum))
    datum.text.fontSize = fontSize;
}
function setLineStyle(datum, style) {
  const strokeWidth = style?.strokeWidth ?? datum.strokeWidth ?? 1;
  const lineType = style?.type ?? datum.lineStyle;
  const lineStyle = lineType ?? getLineStyle(datum.lineDash, lineType);
  const computedLineDash = getComputedLineDash(strokeWidth, lineStyle);
  datum.strokeWidth = strokeWidth;
  datum.computedLineDash = computedLineDash;
  datum.lineStyle = lineStyle;
  datum.lineCap = lineStyle === "dotted" ? "round" : void 0;
}
function setColor(datum, colorPickerType, colorOpacity, color, opacity) {
  switch (colorPickerType) {
    case `fill-color`: {
      if ("fill" in datum)
        datum.fill = color;
      if ("fillOpacity" in datum)
        datum.fillOpacity = opacity;
      if ("background" in datum) {
        datum.background.fill = color;
        datum.background.fillOpacity = opacity;
      }
      break;
    }
    case `line-color`: {
      if ("axisLabel" in datum) {
        datum.axisLabel.fill = color;
        datum.axisLabel.fillOpacity = opacity;
        datum.axisLabel.stroke = color;
        datum.axisLabel.strokeOpacity = opacity;
      }
      if ("fill" in datum && "fillOpacity" in datum && hasIconColor(datum)) {
        datum.fill = color;
        datum.fillOpacity = opacity;
      } else {
        if ("stroke" in datum)
          datum.stroke = color;
        if ("strokeOpacity" in datum)
          datum.strokeOpacity = opacity;
      }
      break;
    }
    case `text-color`: {
      if ("color" in datum)
        datum.color = colorOpacity;
      if (hasLineText(datum))
        datum.text.color = color;
      break;
    }
  }
}

// packages/ag-charts-enterprise/src/features/annotations/annotationDefaults.ts
var AnnotationDefaults = class {
  constructor() {
    this.mementoOriginatorKey = "annotation-defaults";
    this.colors = new Map(
      Object.values(AnnotationType).map((type) => [
        type,
        /* @__PURE__ */ new Map([
          ["line-color", void 0],
          ["fill-color", void 0],
          ["text-color", void 0]
        ])
      ])
    );
    this.fontSizes = /* @__PURE__ */ new Map([
      ["callout" /* Callout */, void 0],
      ["comment" /* Comment */, void 0],
      ["text" /* Text */, void 0],
      ["arrow" /* Arrow */, void 0],
      ["line" /* Line */, void 0],
      ["disjoint-channel" /* DisjointChannel */, void 0],
      ["parallel-channel" /* ParallelChannel */, void 0]
    ]);
    this.lineStyles = /* @__PURE__ */ new Map([
      ["line" /* Line */, void 0],
      ["horizontal-line" /* HorizontalLine */, void 0],
      ["vertical-line" /* VerticalLine */, void 0],
      ["disjoint-channel" /* DisjointChannel */, void 0],
      ["parallel-channel" /* ParallelChannel */, void 0],
      ["arrow" /* Arrow */, void 0]
    ]);
    this.lineTextAlignments = /* @__PURE__ */ new Map([
      ["line" /* Line */, void 0],
      ["horizontal-line" /* HorizontalLine */, void 0],
      ["vertical-line" /* VerticalLine */, void 0],
      ["disjoint-channel" /* DisjointChannel */, void 0],
      ["parallel-channel" /* ParallelChannel */, void 0],
      ["arrow" /* Arrow */, void 0]
    ]);
    this.lineTextPositions = /* @__PURE__ */ new Map([
      ["line" /* Line */, void 0],
      ["horizontal-line" /* HorizontalLine */, void 0],
      ["vertical-line" /* VerticalLine */, void 0],
      ["disjoint-channel" /* DisjointChannel */, void 0],
      ["parallel-channel" /* ParallelChannel */, void 0],
      ["arrow" /* Arrow */, void 0]
    ]);
  }
  createMemento() {
    return {
      colors: _Util23.deepClone(this.colors),
      fontSizes: _Util23.deepClone(this.fontSizes),
      lineStyles: _Util23.deepClone(this.lineStyles),
      lineTextAlignments: _Util23.deepClone(this.lineTextAlignments),
      lineTextPositions: _Util23.deepClone(this.lineTextPositions)
    };
  }
  guardMemento(_blob) {
    return true;
  }
  restoreMemento(_version, _mementoVersion, blob) {
    this.colors = _Util23.deepClone(blob.colors);
    this.fontSizes = _Util23.deepClone(blob.fontSizes);
    this.lineStyles = _Util23.deepClone(blob.lineStyles);
    this.lineTextAlignments = _Util23.deepClone(blob.lineTextAlignments);
    this.lineTextPositions = _Util23.deepClone(blob.lineTextPositions);
  }
  setDefaultColor(type, colorType, colorOpacity, color, opacity) {
    this.colors.get(type)?.set(colorType, [colorOpacity, color, opacity]);
  }
  setDefaultFontSize(type, fontSize) {
    this.fontSizes.set(type, fontSize);
  }
  setDefaultLineStyleType(type, lineStyleType) {
    const defaultStyle = this.lineStyles.get(type);
    if (defaultStyle) {
      defaultStyle.type = lineStyleType;
    } else {
      this.lineStyles.set(type, { type: lineStyleType });
    }
  }
  setDefaultLineStyleWidth(type, strokeWidth) {
    const defaultStyle = this.lineStyles.get(type);
    if (defaultStyle) {
      defaultStyle.strokeWidth = strokeWidth;
    } else {
      this.lineStyles.set(type, { strokeWidth });
    }
  }
  setDefaultLineTextAlignment(type, alignment) {
    this.lineTextAlignments.set(type, alignment);
  }
  setDefaultLineTextPosition(type, position) {
    this.lineTextPositions.set(type, position);
  }
  applyDefaults(datum) {
    for (const [annotationType, colors] of this.colors) {
      if (datum.type !== annotationType)
        continue;
      for (const [colorPickerType, [colorOpacity, color, opacity] = []] of colors) {
        if (colorOpacity && color && opacity != null) {
          setColor(datum, colorPickerType, colorOpacity, color, opacity);
        }
      }
    }
    for (const [annotationType, size] of this.fontSizes) {
      if (datum.type !== annotationType || size == null)
        continue;
      setFontSize(datum, size);
    }
    for (const [annotationType, style] of this.lineStyles) {
      if (datum.type !== annotationType || style == null)
        continue;
      setLineStyle(datum, style);
    }
    for (const [annotationType, position] of this.lineTextPositions) {
      if (datum.type !== annotationType || position == null)
        continue;
      datum.text.position = position;
    }
    for (const [annotationType, alignment] of this.lineTextAlignments) {
      if (datum.type !== annotationType || alignment == null)
        continue;
      datum.text.alignment = alignment;
    }
  }
};

// packages/ag-charts-enterprise/src/features/annotations/annotationsConfig.ts
import "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/states/dragState.ts
import { _ModuleSupport as _ModuleSupport38, _Util as _Util24 } from "ag-charts-community";
var { StateMachine } = _ModuleSupport38;
var { Vec2: Vec23 } = _Util24;
var DragStateMachine = class extends StateMachine {
  constructor(ctx) {
    super("idle", {
      idle: {
        dragStart: {
          target: "dragging",
          action: ({ offset, context }) => {
            this.hasMoved = false;
            this.dragStart = offset;
            ctx.node()?.dragStart(ctx.datum(), offset, context);
          }
        }
      },
      dragging: {
        drag: ({ offset, context }) => {
          this.hasMoved = Vec23.lengthSquared(Vec23.sub(offset, this.dragStart)) > 0;
          ctx.setSelectedWithDrag();
          ctx.node()?.drag(ctx.datum(), offset, context);
          ctx.update();
        },
        dragEnd: {
          target: StateMachine.parent,
          action: () => {
            ctx.node()?.stopDragging();
            ctx.stopInteracting();
            if (this.hasMoved)
              ctx.recordAction("Move annotation");
          }
        }
      }
    });
    this.debug = _Util24.Debug.create(true, "annotations");
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    this.hasMoved = false;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-down/arrowDownProperties.ts
import { _ModuleSupport as _ModuleSupport39 } from "ag-charts-community";
var { STRING: STRING13, Validate: Validate22, isObject: isObject11 } = _ModuleSupport39;
var ArrowDownProperties = class extends ShapePointProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow-down" /* ArrowDown */;
  }
  static is(value) {
    return isObject11(value) && value.type === "arrow-down" /* ArrowDown */;
  }
};
__decorateClass([
  Validate22(STRING13)
], ArrowDownProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/arrow-down/arrowDownScene.ts
import { _Scene as _Scene14 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/pointScene.ts
import { _Util as _Util25 } from "ag-charts-community";
var { Vec2: Vec24 } = _Util25;
var PointScene = class extends AnnotationScene {
  constructor() {
    super(...arguments);
    this.handle = new DivariantHandle();
    this.anchor = {
      x: 0,
      y: 0,
      position: "above"
    };
  }
  update(datum, context) {
    const coords = convertPoint(datum, context);
    this.updateHandle(datum, coords);
    this.anchor = this.updateAnchor(datum, coords, context);
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      handle: convertPoint(datum, context)
    };
  }
  drag(datum, target, context) {
    const { dragState } = this;
    if (datum.locked || !dragState)
      return;
    const coords = Vec24.add(dragState.handle, Vec24.sub(target, dragState.offset));
    const point = invertCoords(coords, context);
    datum.x = point.x;
    datum.y = point.y;
  }
  toggleHandles(show) {
    this.handle.visible = Boolean(show);
    this.handle.toggleHovered(this.activeHandle === "handle");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.handle.toggleActive(active);
  }
  stopDragging() {
    this.handle.toggleDragging(false);
  }
  copy(datum, copiedDatum, context) {
    const coords = convertPoint(datum, context);
    const point = invertCoords({ x: coords.x - 30, y: coords.y - 30 }, context);
    copiedDatum.x = point.x;
    copiedDatum.y = point.y;
    return copiedDatum;
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
  }
  containsPoint(x, y) {
    const { handle: handle2 } = this;
    this.activeHandle = void 0;
    if (handle2.containsPoint(x, y)) {
      this.activeHandle = "handle";
      return true;
    }
    return false;
  }
  updateHandle(datum, point) {
    const { x, y } = this.getHandleCoords(datum, point);
    const styles = this.getHandleStyles(datum);
    this.handle.update({ ...styles, x, y });
    this.handle.toggleLocked(datum.locked ?? false);
  }
  updateAnchor(datum, point, context) {
    const coords = this.getHandleCoords(datum, point);
    return {
      x: coords.x + context.seriesRect.x,
      y: coords.y + context.seriesRect.y,
      position: this.anchor.position
    };
  }
  getHandleCoords(_datum, point) {
    return {
      x: point.x,
      y: point.y
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
};

// packages/ag-charts-enterprise/src/features/annotations/scenes/shapeScene.ts
var ShapeScene = class extends PointScene {
  constructor() {
    super();
    this.type = "arrow-up" /* ArrowUp */;
    this.append([this.handle]);
  }
  update(datum, context) {
    super.update(datum, context);
    const coords = convertPoint(datum, context);
    this.updateShape(datum, coords);
  }
  updateShape(datum, point) {
    this.updateShapeStyles(datum);
    this.updateShapePath(datum, point);
  }
  updateShapeStyles(datum) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
  }
  updateShapePath(datum, point) {
    const { shape } = this;
    shape.x = point.x;
    shape.y = point.y;
    shape.size = datum.size;
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.shape.containsPoint(x, y);
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-down/arrowDownScene.ts
var ArrowDownScene = class extends ShapeScene {
  constructor() {
    super();
    this.type = "arrow-down" /* ArrowDown */;
    this.shape = new _Scene14.ArrowDown();
    this.append([this.shape]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "arrow-down" /* ArrowDown */);
  }
  updateAnchor(datum, point, context) {
    const anchor = super.updateAnchor(datum, point, context);
    anchor.y -= datum.size;
    return anchor;
  }
  getHandleCoords(datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    const handleCoords = super.getHandleCoords(datum, point);
    handleCoords.y += halfSize;
    return handleCoords;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/states/pointState.ts
import { _ModuleSupport as _ModuleSupport42, _Util as _Util27 } from "ag-charts-community";
var { StateMachine: StateMachine2 } = _ModuleSupport42;
var PointStateMachine = class extends StateMachine2 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ x: point.x, y: point.y });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      ctx.node()?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine2.parent,
        reset: StateMachine2.parent
      },
      "waiting-first-render": {
        render: {
          target: StateMachine2.parent,
          action: actionFirstRender
        }
      }
    });
    this.debug = _Util27.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-down/arrowDownState.ts
var ArrowDownStateMachine = class extends PointStateMachine {
  createDatum() {
    return new ArrowDownProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-down/arrowDownConfig.ts
var arrowDownConfig = {
  type: "arrow-down" /* ArrowDown */,
  datum: ArrowDownProperties,
  scene: ArrowDownScene,
  isDatum: ArrowDownProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowDownProperties.is(datum) && ArrowDownProperties.is(copiedDatum) && ArrowDownScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowDownProperties.is(datum) && ArrowDownScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getNode }) => new ArrowDownStateMachine({
    ...ctx,
    create: createDatum("arrow-down" /* ArrowDown */),
    node: getNode(ArrowDownScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(ArrowDownProperties.is),
    node: getNode(ArrowDownScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-up/arrowUpProperties.ts
import { _ModuleSupport as _ModuleSupport43 } from "ag-charts-community";
var { STRING: STRING14, Validate: Validate23, isObject: isObject12 } = _ModuleSupport43;
var ArrowUpProperties = class extends ShapePointProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow-up" /* ArrowUp */;
  }
  static is(value) {
    return isObject12(value) && value.type === "arrow-up" /* ArrowUp */;
  }
};
__decorateClass([
  Validate23(STRING14)
], ArrowUpProperties.prototype, "type", 2);

// packages/ag-charts-enterprise/src/features/annotations/arrow-up/arrowUpScene.ts
import { _Scene as _Scene15 } from "ag-charts-community";
var ArrowUpScene = class extends ShapeScene {
  constructor() {
    super();
    this.type = "arrow-up" /* ArrowUp */;
    this.shape = new _Scene15.ArrowUp();
    this.append([this.shape]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "arrow-up" /* ArrowUp */);
  }
  getHandleCoords(datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    const handleCoords = super.getHandleCoords(datum, point);
    handleCoords.y -= halfSize;
    return handleCoords;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-up/arrowUpState.ts
var ArrowUpStateMachine = class extends PointStateMachine {
  createDatum() {
    return new ArrowUpProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/arrow-up/arrowUpConfig.ts
var arrowUpConfig = {
  type: "arrow-up" /* ArrowUp */,
  datum: ArrowUpProperties,
  scene: ArrowUpScene,
  isDatum: ArrowUpProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowUpProperties.is(datum) && ArrowUpProperties.is(copiedDatum) && ArrowUpScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowUpProperties.is(datum) && ArrowUpScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getNode }) => new ArrowUpStateMachine({
    ...ctx,
    create: createDatum("arrow-up" /* ArrowUp */),
    node: getNode(ArrowUpScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(ArrowUpProperties.is),
    node: getNode(ArrowUpScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutScene.ts
import { _Scene as _Scene17 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/textualStartEndScene.ts
import { _Scene as _Scene16, _Util as _Util30 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/linearScene.ts
import { _Util as _Util29 } from "ag-charts-community";
var { Vec2: Vec25 } = _Util29;
var LinearScene = class extends AnnotationScene {
  extendLine({ x1, y1, x2, y2 }, datum, context) {
    const linePoints = { x1, y1, x2, y2 };
    if (!datum.extendStart && !datum.extendEnd) {
      return linePoints;
    }
    const [left, right] = boundsIntersections(linePoints, context.yAxis.bounds);
    const isFlippedX = linePoints.x2 < linePoints.x1;
    const isFlippedY = linePoints.y1 >= linePoints.y2;
    const isVertical = linePoints.x2 === linePoints.x1;
    if (datum.extendEnd) {
      if (isVertical) {
        linePoints.y2 = isFlippedY ? right.y : left.y;
      } else {
        linePoints.x2 = isFlippedX ? left.x : right.x;
        linePoints.y2 = isFlippedX ? left.y : right.y;
      }
    }
    if (datum.extendStart) {
      if (isVertical) {
        linePoints.y1 = isFlippedY ? left.y : right.y;
      } else {
        linePoints.x1 = isFlippedX ? right.x : left.x;
        linePoints.y1 = isFlippedX ? right.y : left.y;
      }
    }
    return linePoints;
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      start: convertPoint(datum.start, context),
      end: convertPoint(datum.end, context)
    };
  }
  drag(datum, target, context) {
    if (datum.locked)
      return;
    if (this.activeHandle) {
      this.dragHandle(datum, target, context);
    } else {
      this.dragAll(datum, target, context);
    }
  }
  dragAll(datum, target, context) {
    const { dragState } = this;
    if (!dragState)
      return;
    this.translatePoints({
      datum,
      start: dragState.start,
      end: dragState.end,
      translation: Vec25.sub(target, dragState.offset),
      context
    });
  }
  translatePoints({
    datum,
    start,
    end,
    translation,
    context
  }) {
    const translatedStart = Vec25.add(start, translation);
    const translatedEnd = Vec25.add(end, translation);
    const startPoint = invertCoords(translatedStart, context);
    const endPoint = invertCoords(translatedEnd, context);
    const { xAxis, yAxis } = context;
    const within = (min, value, max) => value >= min && value <= max;
    const coords = [translatedStart, translatedEnd].concat(
      ...this.getOtherCoords(datum, translatedStart, translatedEnd, context)
    );
    if (coords.every((coord) => within(xAxis.bounds.x, coord.x, xAxis.bounds.x + xAxis.bounds.width))) {
      datum.start.x = startPoint.x;
      datum.end.x = endPoint.x;
    }
    if (coords.every((coord) => within(yAxis.bounds.y, coord.y, yAxis.bounds.y + yAxis.bounds.height))) {
      datum.start.y = startPoint.y;
      datum.end.y = endPoint.y;
    }
  }
  copy(datum, copiedDatum, context) {
    const coords = convertLine(datum, context);
    if (!coords) {
      return;
    }
    const bbox = this.computeBBoxWithoutHandles();
    this.translatePoints({
      datum: copiedDatum,
      start: { x: coords.x1, y: coords.y1 },
      end: { x: coords.x2, y: coords.y2 },
      translation: { x: -bbox.width / 2, y: -bbox.height / 2 },
      context
    });
    return copiedDatum;
  }
  getOtherCoords(_datum, _topLeft, _topRight, _context) {
    return [];
  }
};

// packages/ag-charts-enterprise/src/features/annotations/scenes/textualStartEndScene.ts
var { Vec2: Vec26 } = _Util30;
var TextualStartEndScene = class extends LinearScene {
  constructor() {
    super(...arguments);
    this.label = new _Scene16.Text({ zIndex: 1 });
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.anchor = {
      x: 0,
      y: 0,
      position: "above-left"
    };
  }
  setTextInputBBox(bbox) {
    this.textInputBBox = bbox;
    this.markDirty(this, _Scene16.RedrawType.MINOR);
  }
  update(datum, context) {
    const coords = convertLine(datum, context);
    if (coords == null) {
      return;
    }
    const bbox = this.getTextBBox(datum, coords);
    this.updateLabel(datum, bbox, coords);
    this.updateHandles(datum, bbox, coords);
    this.updateShape(datum, bbox, coords);
    this.anchor = this.updateAnchor(datum, bbox, context);
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      show = { start: show, end: show };
    }
    this.start.visible = show.start ?? true;
    this.end.visible = show.end ?? true;
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
  }
  dragHandle(datum, target, context) {
    const { activeHandle, dragState } = this;
    if (!activeHandle || !dragState)
      return;
    this[activeHandle].toggleDragging(true);
    const coords = Vec26.add(dragState.end, Vec26.sub(target, dragState.offset));
    const point = invertCoords(coords, context);
    if (!validateDatumPoint(context, point))
      return;
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
  }
  containsPoint(x, y) {
    const { start, end, label } = this;
    this.activeHandle = void 0;
    if (start.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    return label.containsPoint(x, y);
  }
  getTextBBox(datum, coords) {
    const { text: text2 } = datum.getText();
    return getBBox(datum, text2, { x: coords.x2, y: coords.y2 }, this.textInputBBox);
  }
  updateLabel(datum, bbox, coords) {
    const { text: text2, isPlaceholder } = datum.getText();
    const wrappedText = wrapText(datum, text2, bbox.width);
    if (!isPlaceholder) {
      datum.set({ text: wrappedText });
    }
    updateTextNode(this.label, wrappedText, isPlaceholder, datum, this.getLabelCoords(datum, bbox, coords));
  }
  updateHandles(datum, bbox, coords) {
    this.start.update({
      ...this.getHandleStyles(datum, "start"),
      ...this.getHandleCoords(datum, bbox, coords, "start")
    });
    this.end.update({
      ...this.getHandleStyles(datum, "end"),
      ...this.getHandleCoords(datum, bbox, coords, "end")
    });
    this.start.toggleLocked(datum.locked ?? false);
    this.end.toggleLocked(datum.locked ?? false);
  }
  updateShape(_datum, _textBBox, _coords) {
  }
  updateAnchor(_datum, bbox, context) {
    return {
      x: bbox.x + context.seriesRect.x,
      y: bbox.y + context.seriesRect.y - bbox.height,
      position: this.anchor.position
    };
  }
  getLabelCoords(_datum, _bbox, coords) {
    return {
      x: coords.x2,
      y: coords.y2
    };
  }
  getHandleCoords(_datum, _bbox, coords, handle2) {
    return {
      x: handle2 === "start" ? coords.x1 : coords.x2,
      y: handle2 === "start" ? coords.y1 : coords.y2
    };
  }
  getHandleStyles(datum, _handle) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.color,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
};

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutScene.ts
var { drawCorner } = _Scene17;
var CalloutScene = class extends TextualStartEndScene {
  constructor() {
    super();
    this.type = "callout" /* Callout */;
    this.shape = new _Scene17.Path();
    this.append([this.shape, this.label, this.start, this.end]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "callout" /* Callout */);
  }
  drag(datum, target, context) {
    if (datum.locked)
      return;
    if (this.activeHandle === "end") {
      this.dragHandle(datum, target, context);
    } else {
      this.dragAll(datum, target, context);
    }
  }
  getLabelCoords(datum, bbox, coords) {
    const padding = datum.getPadding();
    const {
      bodyBounds = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    } = this.getDimensions(datum, bbox, coords) ?? {};
    return {
      x: bodyBounds.x + padding.left,
      y: bodyBounds.y - padding.bottom
    };
  }
  getHandleStyles(datum, handle2) {
    return handle2 === "start" ? {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    } : { fill: void 0, strokeWidth: 0 };
  }
  updateAnchor(datum, bbox, context) {
    const coords = convertLine(datum, context);
    if (!coords) {
      return this.anchor;
    }
    const { bodyBounds } = this.getDimensions(datum, bbox, coords) ?? {};
    const bounds = bodyBounds ?? bbox;
    return {
      x: bounds.x + context.seriesRect.x,
      y: bounds.y + context.seriesRect.y - bounds.height,
      position: this.anchor.position
    };
  }
  updateShape(datum, textBBox, coords) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
    shape.stroke = datum.stroke;
    shape.strokeWidth = datum.strokeWidth ?? 1;
    shape.strokeOpacity = datum.strokeOpacity ?? 1;
    const { tailPoint, bodyBounds } = this.getDimensions(datum, textBBox, coords) ?? {};
    if (!tailPoint || !bodyBounds) {
      return;
    }
    this.updatePath(tailPoint, bodyBounds);
  }
  updatePath(tailPoint, bodyBounds) {
    const { x: tailX, y: tailY } = tailPoint;
    const { x, y, width, height } = bodyBounds;
    const top = y - height;
    const right = x + width;
    const placement = this.calculateCalloutPlacement({ x: tailX, y: tailY }, bodyBounds);
    const cornerRadius = 8;
    const pathParams = [
      {
        coordinates: {
          x0: x,
          x1: x + cornerRadius,
          y0: top + cornerRadius,
          y1: top,
          cx: placement === `topLeft` ? tailX : x + cornerRadius,
          cy: placement === `topLeft` ? tailY : top + cornerRadius
        },
        type: placement === `topLeft` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: x + cornerRadius,
          x1: right - cornerRadius,
          y0: top,
          y1: top,
          cx: tailX,
          cy: tailY
        },
        type: placement === `top` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: right - cornerRadius,
          x1: right,
          y0: top,
          y1: top + cornerRadius,
          cx: placement === `topRight` ? tailX : right - cornerRadius,
          cy: placement === `topRight` ? tailY : top + cornerRadius
        },
        type: placement === `topRight` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: right,
          x1: right,
          y0: top + cornerRadius,
          y1: y - cornerRadius,
          cx: tailX,
          cy: tailY
        },
        type: placement === `right` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: right,
          x1: right - cornerRadius,
          y0: y - cornerRadius,
          y1: y,
          cx: placement === `bottomRight` ? tailX : right - cornerRadius,
          cy: placement === `bottomRight` ? tailY : y - cornerRadius
        },
        type: placement === `bottomRight` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: right - cornerRadius,
          x1: x + cornerRadius,
          y0: y,
          y1: y,
          cx: tailX,
          cy: tailY
        },
        type: placement === `bottom` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: x + cornerRadius,
          x1: x,
          y0: y,
          y1: y - cornerRadius,
          cx: placement === `bottomLeft` ? tailX : x + cornerRadius,
          cy: placement === `bottomLeft` ? tailY : y - cornerRadius
        },
        type: placement === `bottomLeft` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: x,
          x1: x,
          y0: y - cornerRadius,
          y1: top + cornerRadius,
          cx: tailX,
          cy: tailY
        },
        type: placement === `left` ? "calloutSide" : "side"
      }
    ];
    const { path } = this.shape;
    path.clear();
    path.moveTo(x, top + cornerRadius);
    pathParams.forEach(({ coordinates, type }) => {
      this.drawPath(path, coordinates, cornerRadius, type);
    });
    path.closePath();
  }
  drawPath(path, { x0, y0, x1, y1, cx, cy }, cornerRadius, type) {
    const sideTailRadius = 6;
    switch (type) {
      case "calloutCorner": {
        path.lineTo(cx, cy);
        path.lineTo(x1, y1);
        break;
      }
      case "corner": {
        drawCorner(
          path,
          {
            x0,
            x1,
            y0,
            y1,
            cx,
            cy
          },
          cornerRadius,
          false
        );
        break;
      }
      case "calloutSide": {
        if (x0 !== x1) {
          const direction = x0 > x1 ? -1 : 1;
          const midX = Math.min(x0, x1) + Math.abs(x1 - x0) / 2;
          path.lineTo(midX - sideTailRadius * direction, y0);
          path.lineTo(cx, cy);
          path.lineTo(midX + sideTailRadius * direction, y0);
          path.lineTo(x1, y1);
        } else {
          const direction = y0 > y1 ? -1 : 1;
          const midY = Math.min(y0, y1) + Math.abs(y0 - y1) / 2;
          path.lineTo(x0, midY - sideTailRadius * direction);
          path.lineTo(cx, cy);
          path.lineTo(x0, midY + sideTailRadius * direction);
          path.lineTo(x1, y1);
        }
        break;
      }
      case "side":
      default: {
        path.lineTo(x1, y1);
        break;
      }
    }
  }
  calculateCalloutPlacement(anchorPoint, bounds) {
    const right = bounds.x + bounds.width;
    const top = bounds.y - bounds.height;
    let xPlacement;
    let yPlacement;
    if (anchorPoint.x > right) {
      xPlacement = "right";
    } else if (anchorPoint.x < bounds.x) {
      xPlacement = "left";
    }
    if (anchorPoint.y > bounds.y) {
      yPlacement = "bottom";
    } else if (anchorPoint.y < top) {
      yPlacement = "top";
    }
    if (xPlacement && yPlacement) {
      return `${yPlacement}${xPlacement[0].toUpperCase()}${xPlacement.substring(1)}`;
    } else {
      return yPlacement ?? xPlacement;
    }
  }
  getDimensions(datum, textBBox, coords) {
    const { fontSize } = datum;
    const padding = datum.getPadding();
    const horizontalPadding = padding.left + padding.right;
    const verticalPadding = padding.top + padding.bottom;
    const width = textBBox.width + horizontalPadding;
    const height = Math.max(textBBox.height + verticalPadding, fontSize + verticalPadding);
    return {
      tailPoint: {
        x: coords.x1,
        y: coords.y1
      },
      bodyBounds: {
        x: textBBox.x,
        y: textBBox.y,
        width,
        height
      }
    };
  }
  getCursor() {
    if (this.activeHandle == null || this.activeHandle === "end")
      return "pointer";
  }
  containsPoint(x, y) {
    const { start, end, shape } = this;
    this.activeHandle = void 0;
    if (start.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    const bodyContainsPoint = end.containsPoint(x, y) || shape.containsPoint(x, y);
    if (bodyContainsPoint) {
      this.activeHandle = "end";
    }
    return bodyContainsPoint;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/states/textualStartEndState.ts
import { _ModuleSupport as _ModuleSupport45, _Util as _Util31 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/states/textualStateUtils.ts
function guardCancelAndExit({ key }) {
  return key === "Escape";
}
function guardSaveAndExit({ key, shiftKey }) {
  return !shiftKey && key === "Enter";
}

// packages/ag-charts-enterprise/src/features/annotations/states/textualStartEndState.ts
var { StateMachine: StateMachine3 } = _ModuleSupport45;
var TextualStartEndStateMachine = class extends StateMachine3 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point, visible: true });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      ctx.node()?.toggleActive(true);
    };
    const onStartEditing = () => {
      ctx.showTextInput();
      const datum = ctx.datum();
      if (datum)
        datum.visible = false;
    };
    const onStopEditing = () => {
      ctx.hideTextInput();
      const datum = ctx.datum();
      if (datum)
        datum.visible = true;
      ctx.deselect();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      const node = ctx.node();
      node?.setTextInputBBox(bbox);
      ctx.update();
    };
    const onEndHover = ({ point }) => {
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleActive(true);
      ctx.node()?.toggleHandles({ end: false });
      ctx.update();
    };
    const onEndClick = ({ point }) => {
      ctx.showAnnotationOptions();
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleHandles({ end: true });
    };
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color,
      opacity
    }) => {
      const datum = ctx.datum();
      if (!datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color);
      }
      setColor(datum, colorPickerType, colorOpacity, color, opacity);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const datum = ctx.datum();
      const node = ctx.node();
      if (!datum || !node || !isTextType(datum))
        return;
      datum.fontSize = fontSize;
      ctx.updateTextInputFontSize(fontSize);
      ctx.update();
    };
    const actionCancel = () => {
      ctx.delete();
    };
    const actionSave = ({ textInputValue }) => {
      if (textInputValue != null && textInputValue.length > 0) {
        ctx.datum()?.set({ text: textInputValue });
        ctx.update();
        ctx.recordAction(`Create ${ctx.node()?.type} annotation`);
      } else {
        ctx.delete();
      }
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine3.parent,
        reset: StateMachine3.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: onEndHover,
        click: {
          target: "edit",
          action: onEndClick
        },
        reset: {
          target: StateMachine3.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine3.parent,
          action: actionCancel
        }
      },
      edit: {
        onEnter: onStartEditing,
        updateTextInputBBox: actionUpdateTextInputBBox,
        color: actionColor,
        fontSize: actionFontSize,
        keyDown: [
          {
            guard: guardCancelAndExit,
            target: StateMachine3.parent,
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: StateMachine3.parent,
            action: actionSave
          }
        ],
        click: {
          target: StateMachine3.parent,
          action: actionSave
        },
        onExit: onStopEditing,
        cancel: {
          target: StateMachine3.parent,
          action: actionCancel
        }
      }
    });
    this.debug = _Util31.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutState.ts
var CalloutStateMachine = class extends TextualStartEndStateMachine {
  createDatum() {
    return new CalloutProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/callout/calloutConfig.ts
var calloutConfig = {
  type: "callout" /* Callout */,
  datum: CalloutProperties,
  scene: CalloutScene,
  isDatum: CalloutProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (CalloutProperties.is(datum) && CalloutProperties.is(copiedDatum) && CalloutScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (CalloutProperties.is(datum) && CalloutScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new CalloutStateMachine({
    ...ctx,
    create: createDatum("callout" /* Callout */),
    datum: getDatum(CalloutProperties.is),
    node: getNode(CalloutScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(CalloutProperties.is),
    node: getNode(CalloutScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/comment/commentScene.ts
import { _Scene as _Scene18 } from "ag-charts-community";
var { drawCorner: drawCorner2 } = _Scene18;
var CommentScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "comment" /* Comment */;
    this.shape = new _Scene18.Path();
    this.append([this.shape, this.label, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "comment" /* Comment */);
  }
  updateShape(datum, bbox) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
    shape.stroke = datum.stroke ?? "transparent";
    shape.strokeWidth = datum.strokeWidth ?? 1;
    shape.strokeOpacity = datum.strokeOpacity ?? 1;
    this.updatePath(datum, bbox);
  }
  getLabelCoords(datum, point) {
    const padding = datum.getPadding();
    return {
      x: point.x + padding.left,
      y: point.y - padding.bottom
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke ?? datum.fill,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
  updateAnchor(datum, bbox, context) {
    const anchor = super.updateAnchor(datum, bbox, context);
    const padding = datum.getPadding();
    anchor.y -= padding.bottom + padding.top;
    return anchor;
  }
  updatePath(datum, bbox) {
    const padding = datum.getPadding();
    const { x, y } = bbox;
    let { width, height } = bbox;
    const { fontSize } = datum;
    const horizontalPadding = padding.left + padding.right;
    const verticalPadding = padding.top + padding.bottom;
    width = width + horizontalPadding;
    height = Math.max(height + verticalPadding, fontSize + verticalPadding);
    const top = y - height;
    const right = x + width;
    const cornerRadius = (fontSize * ANNOTATION_TEXT_LINE_HEIGHT + verticalPadding) / 2;
    const { path } = this.shape;
    path.clear();
    path.moveTo(x, y);
    path.lineTo(x, top + cornerRadius);
    drawCorner2(
      path,
      {
        x0: x,
        x1: x + cornerRadius,
        y0: top + cornerRadius,
        y1: top,
        cx: x + cornerRadius,
        cy: top + cornerRadius
      },
      cornerRadius,
      false
    );
    path.lineTo(right - cornerRadius, top);
    drawCorner2(
      path,
      {
        x0: right - cornerRadius,
        x1: right,
        y0: top,
        y1: top + cornerRadius,
        cx: right - cornerRadius,
        cy: top + cornerRadius
      },
      cornerRadius,
      false
    );
    path.lineTo(right, y - cornerRadius);
    drawCorner2(
      path,
      {
        x0: right,
        x1: right - cornerRadius,
        y0: y - cornerRadius,
        y1: y,
        cx: right - cornerRadius,
        cy: y - cornerRadius
      },
      cornerRadius,
      false
    );
    path.closePath();
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.shape.containsPoint(x, y);
  }
};

// packages/ag-charts-enterprise/src/features/annotations/states/textualPointState.ts
import { _ModuleSupport as _ModuleSupport46, _Util as _Util32 } from "ag-charts-community";
var { StateMachine: StateMachine4 } = _ModuleSupport46;
var TextualPointStateMachine = class extends StateMachine4 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ x: point.x, y: point.y });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      ctx.node()?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const onStartEditing = () => {
      ctx.showTextInput();
      const datum = ctx.datum();
      if (datum) {
        datum.visible = false;
      }
    };
    const onStopEditing = () => {
      ctx.hideTextInput();
      const datum = ctx.datum();
      if (datum)
        datum.visible = true;
      ctx.deselect();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      const node = ctx.node();
      node?.setTextInputBBox(bbox);
      ctx.update();
    };
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color,
      opacity
    }) => {
      const datum = ctx.datum();
      if (!datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color);
      }
      setColor(datum, colorPickerType, colorOpacity, color, opacity);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const datum = ctx.datum();
      const node = ctx.node();
      if (!datum || !node || !isTextType(datum))
        return;
      datum.fontSize = fontSize;
      ctx.updateTextInputFontSize(fontSize);
      ctx.update();
    };
    const actionCancel = () => {
      ctx.delete();
    };
    const actionSave = ({ textInputValue }) => {
      if (textInputValue != null && textInputValue.length > 0) {
        ctx.datum()?.set({ text: textInputValue });
        ctx.update();
        ctx.recordAction(`Create ${ctx.node()?.type} annotation`);
      } else {
        ctx.delete();
      }
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine4.parent,
        reset: StateMachine4.parent
      },
      "waiting-first-render": {
        render: {
          target: "edit",
          action: actionFirstRender
        }
      },
      edit: {
        onEnter: onStartEditing,
        updateTextInputBBox: actionUpdateTextInputBBox,
        color: actionColor,
        fontSize: actionFontSize,
        keyDown: [
          {
            guard: guardCancelAndExit,
            target: StateMachine4.parent,
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: StateMachine4.parent,
            action: actionSave
          }
        ],
        click: {
          target: StateMachine4.parent,
          action: actionSave
        },
        onExit: onStopEditing,
        cancel: {
          target: StateMachine4.parent,
          action: actionCancel
        }
      }
    });
    this.debug = _Util32.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/comment/commentState.ts
var CommentStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new CommentProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/comment/commentConfig.ts
var commentConfig = {
  type: "comment" /* Comment */,
  datum: CommentProperties,
  scene: CommentScene,
  isDatum: CommentProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (CommentProperties.is(datum) && CommentProperties.is(copiedDatum) && CommentScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (CommentProperties.is(datum) && CommentScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new CommentStateMachine({
    ...ctx,
    create: createDatum("comment" /* Comment */),
    datum: getDatum(CommentProperties.is),
    node: getNode(CommentScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(CommentProperties.is),
    node: getNode(CommentScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineScene.ts
import { _ModuleSupport as _ModuleSupport49, _Util as _Util35 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/axisLabelScene.ts
import { _ModuleSupport as _ModuleSupport47, _Scene as _Scene19 } from "ag-charts-community";
var { calculateLabelTranslation, ChartAxisDirection: ChartAxisDirection7 } = _ModuleSupport47;
var AxisLabelScene = class extends _Scene19.Group {
  constructor() {
    super({ name: "AnnotationAxisLabelGroup" });
    this.label = new _Scene19.Text({ zIndex: 1 });
    this.rect = new _Scene19.Rect();
    const { label } = this;
    label.fontSize = 12;
    label.fontFamily = "Verdana, sans-serif";
    label.fill = "black";
    label.textBaseline = "middle";
    label.textAlign = "center";
    this.append([this.rect, this.label]);
  }
  update(opts) {
    this.updateLabel(opts);
    this.updateRect(opts);
    this.updatePosition(opts);
  }
  updateLabel({ value, styles, context }) {
    const { label } = this;
    const { fontWeight, fontSize, fontStyle, fontFamily, textAlign, color = "white", formatter } = styles;
    label.setProperties({ fontWeight, fontSize, fontStyle, fontFamily, textAlign, fill: color });
    label.text = this.getFormattedValue(value, formatter ?? context.scaleValueFormatter());
  }
  updateRect({ styles }) {
    const { rect } = this;
    const { cornerRadius, fill, fillOpacity, stroke: stroke2, strokeOpacity } = styles;
    rect.setProperties({ cornerRadius, fill, fillOpacity, stroke: stroke2, strokeOpacity });
  }
  updatePosition({ x, y, context, styles: { padding } }) {
    const { label, rect } = this;
    const labelBBox = label.getBBox()?.clone();
    const horizontalPadding = 8;
    const verticalPadding = 5;
    labelBBox.grow(padding ?? horizontalPadding, "horizontal");
    labelBBox.grow(padding ?? verticalPadding, "vertical");
    const shift = context.direction === ChartAxisDirection7.X ? verticalPadding / 2 : horizontalPadding;
    const { xTranslation, yTranslation } = calculateLabelTranslation({
      yDirection: true,
      padding: context.labelPadding - shift,
      position: context.position ?? "left",
      bbox: labelBBox
    });
    const translationX = x + xTranslation;
    const translationY = y + yTranslation;
    label.x = translationX;
    label.y = translationY;
    rect.x = translationX - labelBBox.width / 2;
    rect.y = translationY - labelBBox.height / 2;
    rect.height = labelBBox.height;
    rect.width = labelBBox.width;
  }
  getFormattedValue(value, formatter) {
    return formatter?.(value) ?? String(value);
  }
};
AxisLabelScene.className = "AxisLabel";

// packages/ag-charts-enterprise/src/features/annotations/scenes/collidableLineScene.ts
import { _ModuleSupport as _ModuleSupport48, _Scene as _Scene20, _Util as _Util33 } from "ag-charts-community";
var { Vec2: Vec27 } = _Util33;
var CollidableLine = class extends _Scene20.Line {
  constructor() {
    super(...arguments);
    this.growCollisionBox = 9;
  }
  setProperties(styles, pickKeys) {
    super.setProperties(styles, pickKeys);
    this.updateCollisionBBox();
    return this;
  }
  updateCollisionBBox() {
    const { growCollisionBox, strokeWidth, x1, y1, x2, y2 } = this;
    let height = strokeWidth + growCollisionBox;
    if (height % 2 === 0)
      height += 1;
    const topLeft = Vec27.from(x1, y1 - Math.floor(height / 2));
    const bottomRight = Vec27.from(x2, y2);
    const width = Vec27.distance(topLeft, bottomRight);
    this.collisionBBox = new _Scene20.BBox(topLeft.x, topLeft.y, width, height);
  }
  isPointInPath(pointX, pointY) {
    const { collisionBBox, x1, y1, x2, y2 } = this;
    if (!collisionBBox)
      return false;
    const v1 = Vec27.from(x1, y1);
    const v2 = Vec27.from(x2, y2);
    const point = Vec27.sub(Vec27.from(pointX, pointY), v1);
    const end = Vec27.sub(v2, v1);
    const rotated = Vec27.rotate(point, Vec27.angle(point, end), v1);
    return collisionBBox.containsPoint(rotated.x, rotated.y) ?? false;
  }
  render(renderCtx) {
    this.applyClipMask(renderCtx.ctx);
    super.render(renderCtx);
    this.closeClipMask(renderCtx.ctx);
  }
  setClipMask(mask) {
    if (_ModuleSupport48.jsonDiff(this.clipMask, mask) != null) {
      this.markDirty(this, _Scene20.RedrawType.MAJOR);
    }
    this.clipMask = mask;
  }
  /**
   * Apply a clipping mask to the shape, this must be called before the shape calls `ctx.beginPath()`.
   */
  applyClipMask(ctx) {
    const { clipMask } = this;
    if (!clipMask)
      return;
    const { x, y, radius } = clipMask;
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.ellipse(x, y, radius, radius, 0, Math.PI * 2, 0, true);
    ctx.clip();
  }
  closeClipMask(ctx) {
    if (!this.clipMask)
      return;
    ctx.restore();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/scenes/lineWithTextScene.ts
import { _Scene as _Scene21, _Util as _Util34 } from "ag-charts-community";
var { Vec2: Vec28 } = _Util34;
var LineWithTextScene = class _LineWithTextScene {
  static updateLineText(datum, coords) {
    if (!datum.text?.label && this.text) {
      this.removeChild(this.text);
      this.line.setClipMask();
      this.text = void 0;
    }
    if (!datum.text?.label)
      return;
    if (this.text == null) {
      this.text = new _Scene21.TransformableText();
      this.appendChild(this.text);
    }
    const { alignment, position } = datum.text;
    const numbers = _LineWithTextScene.getNumbers(coords, datum.text.fontSize, datum.strokeWidth);
    const { point, textBaseline } = _LineWithTextScene.positionAndAlignment(numbers, position, alignment);
    _LineWithTextScene.setProperties(this.text, datum.text, point, numbers.angle, textBaseline);
    if (position === "center") {
      const { x, y, width, height } = this.text.getBBox();
      const diameter = Vec28.length(Vec28.from(width, height));
      this.line.setClipMask({
        x: x + width / 2,
        y: y + height / 2,
        radius: diameter / 2 + Vec28.length(numbers.offset)
      });
    } else {
      this.line.setClipMask();
    }
  }
  static updateChannelText(offsetInsideTextLabel, datum, top, bottom) {
    if (!datum.text?.label && this.text) {
      this.removeChild(this.text);
      this.text = void 0;
    }
    if (!datum.text?.label)
      return;
    if (this.text == null) {
      this.text = new _Scene21.TransformableText();
      this.appendChild(this.text);
    }
    const { alignment, position } = datum.text;
    const [actualTop, actualBottom] = top.y1 <= bottom.y1 ? [top, bottom] : [bottom, top];
    let relativeLine = actualTop;
    if (position === "bottom") {
      relativeLine = actualBottom;
    } else if (position === "inside") {
      relativeLine = {
        x1: (actualTop.x1 + actualBottom.x1) / 2,
        y1: (actualTop.y1 + actualBottom.y1) / 2,
        x2: (actualTop.x2 + actualBottom.x2) / 2,
        y2: (actualTop.y2 + actualBottom.y2) / 2
      };
    }
    const numbers = _LineWithTextScene.getNumbers(relativeLine, datum.text.fontSize, datum.strokeWidth);
    const { point, textBaseline } = _LineWithTextScene.positionAndAlignment(
      numbers,
      position === "inside" ? "center" : position,
      alignment,
      offsetInsideTextLabel
    );
    _LineWithTextScene.setProperties(this.text, datum.text, point, numbers.angle, textBaseline);
  }
  static getNumbers(coords, fontSize, strokeWidth) {
    let [left, right] = Vec28.from(coords);
    if (left.x > right.x)
      [left, right] = [right, left];
    const normal = Vec28.normalized(Vec28.sub(right, left));
    const angle = Vec28.angle(normal);
    const inset = Vec28.multiply(normal, DivariantHandle.HANDLE_SIZE / 2 + (fontSize ?? 14) / 2);
    const offset = Vec28.multiply(normal, (strokeWidth ?? 2) / 2 + (fontSize ?? 14) / 3);
    return { left, right, normal, angle, inset, offset };
  }
  static positionAndAlignment({ left, right, normal, angle, inset, offset }, position, alignment, offsetInsideTextLabel) {
    let point;
    if (alignment === "right") {
      point = Vec28.sub(right, inset);
    } else if (alignment === "center") {
      point = Vec28.add(left, Vec28.multiply(normal, Vec28.distance(left, right) / 2));
    } else {
      point = Vec28.add(left, inset);
    }
    let textBaseline = "bottom";
    if (position === "bottom") {
      point = Vec28.rotate(offset, angle + Math.PI / 2, point);
      textBaseline = "top";
    } else if (position === "center" && !offsetInsideTextLabel) {
      textBaseline = "middle";
    } else {
      point = Vec28.rotate(offset, angle - Math.PI / 2, point);
    }
    return { point, textBaseline };
  }
  static setProperties(scene, datum, point, angle, textBaseline) {
    scene.setProperties({
      text: datum.label,
      x: point.x,
      y: point.y,
      rotation: angle,
      rotationCenterX: point.x,
      rotationCenterY: point.y,
      fill: datum.color,
      fontFamily: datum.fontFamily,
      fontSize: datum.fontSize,
      fontStyle: datum.fontStyle,
      fontWeight: datum.fontWeight,
      textAlign: datum.alignment,
      textBaseline
    });
  }
};

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineScene.ts
var { Vec2: Vec29 } = _Util35;
var { ChartAxisDirection: ChartAxisDirection8 } = _ModuleSupport49;
var CrossLineScene = class extends AnnotationScene {
  constructor() {
    super();
    this.type = "cross-line";
    this.line = new CollidableLine();
    this.middle = new UnivariantHandle();
    this.isHorizontal = false;
    this.updateText = LineWithTextScene.updateLineText.bind(this);
    this.append([this.line, this.middle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "cross-line");
  }
  update(datum, context) {
    const { seriesRect } = context;
    this.seriesRect = seriesRect;
    this.isHorizontal = HorizontalLineProperties.is(datum);
    const axisContext = this.isHorizontal ? context.yAxis : context.xAxis;
    const coords = this.convertCrossLine(datum, axisContext);
    if (coords == null) {
      this.visible = false;
      return;
    }
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    this.updateLine(datum, coords);
    this.updateHandle(datum, coords);
    this.updateText(datum, coords);
    this.updateAxisLabel(datum, axisContext, coords);
  }
  updateLine(datum, coords) {
    const { line } = this;
    const { lineDashOffset, stroke: stroke2, strokeWidth, strokeOpacity } = datum;
    const { x1, y1, x2, y2 } = coords;
    line.setProperties({
      x1,
      y1,
      x2,
      y2,
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0,
      lineCap: datum.getLineCap()
    });
  }
  updateHandle(datum, coords) {
    const { middle } = this;
    const { locked, stroke: stroke2, strokeWidth, strokeOpacity } = datum;
    const { x1, y1, x2, y2 } = coords;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? stroke2,
      strokeOpacity: datum.handle.strokeOpacity ?? strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? strokeWidth
    };
    const x = x1 + (x2 - x1) / 2;
    const y = y1 + (y2 - y1) / 2;
    const { width: handleWidth, height: handleHeight } = middle.handle;
    middle.gradient = this.isHorizontal ? "horizontal" : "vertical";
    middle.update({ ...handleStyles, x: x - handleWidth / 2, y: y - handleHeight / 2 });
    middle.toggleLocked(locked ?? false);
  }
  createAxisLabel(context) {
    const axisLabel2 = new AxisLabelScene();
    context.attachLabel(axisLabel2);
    return axisLabel2;
  }
  updateAxisLabel(datum, axisContext, { x1, y1, x2, y2 }) {
    if (!this.axisLabel) {
      this.axisLabel = this.createAxisLabel(axisContext);
    }
    const { axisLabel: axisLabel2, seriesRect } = this;
    if (datum.axisLabel.enabled) {
      axisLabel2.visible = this.visible;
      const [labelX, labelY] = axisContext.position === "left" || axisContext.position === "top" ? [x1, y1] : [x2, y2];
      const labelPosition = axisContext.direction === ChartAxisDirection8.X ? labelX : labelY;
      if (!axisContext.inRange(labelPosition)) {
        axisLabel2.visible = false;
        return;
      }
      axisLabel2.update({
        x: labelX + (seriesRect?.x ?? 0),
        y: labelY + (seriesRect?.y ?? 0),
        value: datum.value,
        styles: datum.axisLabel,
        context: axisContext
      });
    } else {
      axisLabel2.visible = false;
    }
  }
  toggleHandles(show) {
    this.middle.visible = show;
    this.middle.toggleHovered(this.activeHandle === "middle");
  }
  destroy() {
    super.destroy();
    this.axisLabel?.destroy();
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.middle.toggleActive(active);
  }
  dragStart(datum, target, context) {
    const middle = HorizontalLineProperties.is(datum) ? { x: target.x, y: convert(datum.value, context.yAxis) } : { x: convert(datum.value, context.xAxis), y: target.y };
    this.dragState = {
      offset: target,
      middle
    };
  }
  drag(datum, target, context) {
    const { activeHandle, dragState } = this;
    if (datum.locked)
      return;
    let coords;
    if (activeHandle) {
      this[activeHandle].toggleDragging(true);
      coords = this[activeHandle].drag(target).point;
    } else if (dragState) {
      coords = Vec29.add(dragState.middle, Vec29.sub(target, dragState.offset));
    } else {
      return;
    }
    const point = invertCoords(coords, context);
    const isHorizontal = HorizontalLineProperties.is(datum);
    datum.set({ value: isHorizontal ? point.y : point.x });
  }
  stopDragging() {
    this.middle.toggleDragging(false);
  }
  copy(datum, copiedDatum, context) {
    const isHorizontal = HorizontalLineProperties.is(datum);
    const axisContext = this.isHorizontal ? context.yAxis : context.xAxis;
    const coords = this.convertCrossLine(datum, axisContext);
    if (!coords) {
      return;
    }
    const yOffset = isHorizontal ? -30 : 0;
    const xOffset = isHorizontal ? 0 : -30;
    const point = invertCoords({ x: coords.x1 + xOffset, y: coords.y1 + yOffset }, context);
    copiedDatum.set({ value: isHorizontal ? point.y : point.x });
    return copiedDatum;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return this[this.activeHandle].getCursor();
  }
  containsPoint(x, y) {
    const { middle, line, text: text2 } = this;
    this.activeHandle = void 0;
    if (middle.containsPoint(x, y)) {
      this.activeHandle = "middle";
      return true;
    }
    return line.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getAnchor() {
    const bbox = this.computeBBoxWithoutHandles();
    if (this.isHorizontal) {
      return { x: bbox.x + bbox.width / 2, y: bbox.y };
    }
    return { x: bbox.x + bbox.width, y: bbox.y + bbox.height / 2, position: "right" };
  }
  convertCrossLine(datum, context) {
    if (datum.value == null)
      return;
    let x1 = 0;
    let x2 = 0;
    let y1 = 0;
    let y2 = 0;
    const { bounds, scaleConvert, scaleBandwidth } = context;
    const halfBandwidth = (scaleBandwidth() ?? 0) / 2;
    if (HorizontalLineProperties.is(datum)) {
      const scaledValue = scaleConvert(datum.value) + halfBandwidth;
      x2 = bounds.width;
      y1 = scaledValue;
      y2 = scaledValue;
    } else {
      const scaledValue = scaleConvert(datum.value) + halfBandwidth;
      x1 = scaledValue;
      x2 = scaledValue;
      y2 = bounds.height;
    }
    return { x1, y1, x2, y2 };
  }
};

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineState.ts
import { _ModuleSupport as _ModuleSupport50, _Util as _Util36 } from "ag-charts-community";
var { StateMachine: StateMachine5 } = _ModuleSupport50;
var CrossLineStateMachine = class extends StateMachine5 {
  constructor(direction, ctx) {
    const onClick = ({ point }) => {
      const isHorizontal = direction === "horizontal";
      const datum = isHorizontal ? new HorizontalLineProperties() : new VerticalLineProperties();
      datum.set({ value: isHorizontal ? point.y : point.x });
      ctx.create(datum);
      ctx.recordAction(
        `Create ${isHorizontal ? "horizontal-line" /* HorizontalLine */ : "vertical-line" /* VerticalLine */} annotation`
      );
    };
    const actionFirstRender = () => {
      ctx.node()?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: onClick
        },
        reset: StateMachine5.parent,
        cancel: StateMachine5.parent
      },
      "waiting-first-render": {
        render: {
          target: StateMachine5.parent,
          action: actionFirstRender
        }
      }
    });
    this.debug = _Util36.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineConfig.ts
var horizontalLineConfig = {
  type: "horizontal-line" /* HorizontalLine */,
  datum: HorizontalLineProperties,
  scene: CrossLineScene,
  isDatum: HorizontalLineProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (HorizontalLineProperties.is(datum) && HorizontalLineProperties.is(copiedDatum) && CrossLineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (HorizontalLineProperties.is(datum) && CrossLineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getNode }) => new CrossLineStateMachine("horizontal", {
    ...ctx,
    create: createDatum("horizontal-line" /* HorizontalLine */),
    node: getNode(CrossLineScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(HorizontalLineProperties.is),
    node: getNode(CrossLineScene.is)
  })
};
var verticalLineConfig = {
  type: "vertical-line" /* VerticalLine */,
  datum: VerticalLineProperties,
  scene: CrossLineScene,
  isDatum: VerticalLineProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (VerticalLineProperties.is(datum) && VerticalLineProperties.is(copiedDatum) && CrossLineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (VerticalLineProperties.is(datum) && CrossLineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getNode }) => new CrossLineStateMachine("vertical", {
    ...ctx,
    create: createDatum("vertical-line" /* VerticalLine */),
    node: getNode(CrossLineScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(VerticalLineProperties.is),
    node: getNode(CrossLineScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelScene.ts
import { _Util as _Util38 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/channelScene.ts
import { _Scene as _Scene22 } from "ag-charts-community";
var ChannelScene = class extends LinearScene {
  constructor() {
    super(...arguments);
    this.handles = {};
    this.topLine = new CollidableLine();
    this.bottomLine = new CollidableLine();
    this.background = new _Scene22.Path({ zIndex: -1 });
    this.anchor = { x: 0, y: 0 };
  }
  update(datum, context) {
    const { locked, visible } = datum;
    const top = convertLine(datum, context);
    const bottom = convertLine(datum.bottom, context);
    if (top == null || bottom == null) {
      this.visible = false;
      return;
    } else {
      this.visible = visible ?? true;
    }
    const topLine = this.extendLine(top, datum, context);
    const bottomLine = this.extendLine(bottom, datum, context);
    this.updateLines(datum, topLine, bottomLine, context, top, bottom);
    this.updateHandles(datum, top, bottom);
    this.updateText(datum, top, bottom);
    this.updateBackground(datum, topLine, bottomLine, context);
    this.updateAnchor(top, bottom);
    for (const handle2 of Object.values(this.handles)) {
      handle2.toggleLocked(locked ?? false);
    }
  }
  toggleActive(active) {
    this.toggleHandles(active);
    for (const node of Object.values(this.handles)) {
      node.toggleActive(active);
    }
  }
  stopDragging() {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    handles[activeHandle].toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return this.handles[this.activeHandle].getCursor();
  }
  containsPoint(x, y) {
    const { handles, topLine, bottomLine, text: text2 } = this;
    this.activeHandle = void 0;
    for (const [handle2, child] of Object.entries(handles)) {
      if (child.containsPoint(x, y)) {
        this.activeHandle = handle2;
        return true;
      }
    }
    return topLine.containsPoint(x, y) || bottomLine.containsPoint(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  updateBackground(datum, top, bottom, context) {
    const { background } = this;
    const { seriesRect } = context;
    background.path.clear(true);
    const bounds = {
      x1: 0,
      y1: 0,
      x2: seriesRect.width,
      y2: seriesRect.height
    };
    const points = this.getBackgroundPoints(datum, top, bottom, bounds);
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (i === 0) {
        background.path.moveTo(point.x, point.y);
      } else {
        background.path.lineTo(point.x, point.y);
      }
    }
    background.path.closePath();
    background.checkPathDirty();
    background.setProperties({
      fill: datum.background.fill,
      fillOpacity: datum.background.fillOpacity
    });
  }
  updateAnchor(top, bottom) {
    const { x, y } = _Scene22.Transformable.toCanvasPoint(
      this.topLine,
      (top.x1 + top.x2) / 2,
      Math.min(top.y1, top.y2, bottom.y1, bottom.y2)
    );
    this.anchor.x = x;
    this.anchor.y = y;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelScene.ts
var { Vec2: Vec210 } = _Util38;
var DisjointChannelScene = class extends ChannelScene {
  constructor() {
    super();
    this.type = "disjoint-channel";
    this.handles = {
      topLeft: new DivariantHandle(),
      topRight: new DivariantHandle(),
      bottomLeft: new DivariantHandle(),
      bottomRight: new UnivariantHandle()
    };
    this.updateText = LineWithTextScene.updateChannelText.bind(this, false);
    this.append([this.background, this.topLine, this.bottomLine, ...Object.values(this.handles)]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "disjoint-channel");
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      show = {
        topLeft: show,
        topRight: show,
        bottomLeft: show,
        bottomRight: show
      };
    }
    for (const [handle2, node] of Object.entries(this.handles)) {
      node.visible = show[handle2] ?? true;
      node.toggleHovered(this.activeHandle === handle2);
    }
  }
  toggleActive(active) {
    this.toggleHandles(active);
    for (const node of Object.values(this.handles)) {
      node.toggleActive(active);
    }
  }
  dragHandle(datum, target, context) {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    const { offset } = handles[activeHandle].drag(target);
    handles[activeHandle].toggleDragging(true);
    const invert2 = (coords) => invertCoords(coords, context);
    const prev = datum.toJson();
    switch (activeHandle) {
      case "topLeft":
      case "bottomLeft": {
        const direction = activeHandle === "topLeft" ? 1 : -1;
        const start = invert2({
          x: handles.topLeft.handle.x + offset.x,
          y: handles.topLeft.handle.y + offset.y * direction
        });
        const bottomStart = invert2({
          x: handles.bottomLeft.handle.x + offset.x,
          y: handles.bottomLeft.handle.y + offset.y * -direction
        });
        if (!start || !bottomStart || datum.start.y == null)
          return;
        const startHeight = datum.startHeight + (start.y - datum.start.y) * 2;
        datum.start.x = start.x;
        datum.start.y = start.y;
        datum.startHeight = startHeight;
        break;
      }
      case "topRight": {
        const end = invert2({
          x: handles.topRight.handle.x + offset.x,
          y: handles.topRight.handle.y + offset.y
        });
        if (!end || datum.end.y == null)
          return;
        const endHeight = datum.endHeight + (end.y - datum.end.y) * 2;
        datum.end.x = end.x;
        datum.end.y = end.y;
        datum.endHeight = endHeight;
        break;
      }
      case "bottomRight": {
        const bottomStart = invert2({
          x: handles.bottomLeft.handle.x + offset.x,
          y: handles.bottomLeft.handle.y + offset.y
        });
        const bottomEnd = invert2({
          x: handles.bottomRight.handle.x + offset.x,
          y: handles.bottomRight.handle.y + offset.y
        });
        if (!bottomStart || !bottomEnd || datum.start.y == null || datum.end.y == null)
          return;
        const endHeight = datum.end.y - bottomEnd.y;
        const startHeight = datum.startHeight - (datum.endHeight - endHeight);
        datum.startHeight = startHeight;
        datum.endHeight = endHeight;
      }
    }
    if (!datum.isValidWithContext(context)) {
      datum.set(prev);
    }
  }
  getOtherCoords(datum, topLeft, topRight, context) {
    const { dragState } = this;
    if (!dragState)
      return [];
    const startHeight = convertPoint(datum.bottom.start, context).y - convertPoint(datum.start, context).y;
    const endHeight = convertPoint(datum.bottom.end, context).y - convertPoint(datum.end, context).y;
    const bottomLeft = Vec210.add(topLeft, Vec210.from(0, startHeight));
    const bottomRight = Vec210.add(topRight, Vec210.from(0, endHeight));
    return [bottomLeft, bottomRight];
  }
  updateLines(datum, top, bottom) {
    const { topLine, bottomLine } = this;
    const { lineDashOffset, stroke: stroke2, strokeOpacity, strokeWidth } = datum;
    const lineStyles = {
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke2,
      strokeOpacity,
      strokeWidth,
      lineCap: datum.getLineCap()
    };
    topLine.setProperties({
      x1: top.x1,
      y1: top.y1,
      x2: top.x2,
      y2: top.y2,
      ...lineStyles
    });
    bottomLine.setProperties({
      x1: bottom.x1,
      y1: bottom.y1,
      x2: bottom.x2,
      y2: bottom.y2,
      ...lineStyles
    });
  }
  updateHandles(datum, top, bottom) {
    const {
      handles: { topLeft, topRight, bottomLeft, bottomRight }
    } = this;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
    topLeft.update({ ...handleStyles, x: top.x1, y: top.y1 });
    topRight.update({ ...handleStyles, x: top.x2, y: top.y2 });
    bottomLeft.update({ ...handleStyles, x: bottom.x1, y: bottom.y1 });
    bottomRight.update({
      ...handleStyles,
      x: bottom.x2 - bottomRight.handle.width / 2,
      y: bottom.y2 - bottomRight.handle.height / 2
    });
  }
  getBackgroundPoints(datum, top, bottom, bounds) {
    const isFlippedX = top.x1 > top.x2;
    const isFlippedY = top.y1 > top.y2;
    const topY = isFlippedY ? bounds.y2 : bounds.y1;
    const bottomY = isFlippedY ? bounds.y1 : bounds.y2;
    const points = Vec210.from(top);
    if (datum.extendEnd && top.y2 === bottomY) {
      points.push(Vec210.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y1 : bounds.y2));
    }
    if (datum.extendEnd && bottom.y2 === topY) {
      points.push(Vec210.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y2 : bounds.y1));
    }
    points.push(...Vec210.from(bottom).reverse());
    if (datum.extendStart && bottom.y1 === bottomY) {
      points.push(Vec210.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y1 : bounds.y2));
    }
    if (datum.extendStart && top.y1 === topY) {
      points.push(Vec210.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y2 : bounds.y1));
    }
    return points;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelState.ts
import { _ModuleSupport as _ModuleSupport52, _Util as _Util39 } from "ag-charts-community";
var { StateMachine: StateMachine6 } = _ModuleSupport52;
var DisjointChannelStateMachine = class extends StateMachine6 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = new DisjointChannelProperties();
      datum.set({ start: point, end: point, startHeight: 0, endHeight: 0 });
      ctx.create(datum);
    };
    const actionEndUpdate = ({ point }) => {
      ctx.guardDragClickDoubleEvent.hover();
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleHandles({ topRight: false, bottomLeft: false, bottomRight: false });
      ctx.update();
    };
    const actionEndFinish = ({ point }) => {
      ctx.datum()?.set({ end: point });
    };
    const actionHeightUpdate = ({ point }) => {
      const datum = ctx.datum();
      if (datum?.start.y == null || datum?.end.y == null)
        return;
      const endHeight = datum.end.y - (point.y ?? 0);
      const startHeight = (datum.start.y - datum.end.y) * 2 + endHeight;
      const bottomStart = { x: datum.start.x, y: datum.start.y - startHeight };
      const bottomEnd = { x: datum.end.x, y: point.y };
      ctx.node()?.toggleHandles({ bottomLeft: false });
      if (!ctx.validatePoint(bottomStart) || !ctx.validatePoint(bottomEnd)) {
        return;
      }
      datum.set({ startHeight, endHeight });
      ctx.update();
    };
    const actionHeightFinish = ({ point }) => {
      const datum = ctx.datum();
      if (datum?.start.y == null || datum?.end.y == null)
        return;
      const endHeight = datum.end.y - (point.y ?? 0);
      const startHeight = (datum.start.y - datum.end.y) * 2 + endHeight;
      const bottomStart = { x: datum.start.x, y: datum.start.y - endHeight };
      const bottomEnd = { x: datum.end.x, y: point.y };
      ctx.node()?.toggleHandles(true);
      if (!ctx.validatePoint(bottomStart) || !ctx.validatePoint(bottomEnd)) {
        return;
      }
      datum.set({ startHeight, endHeight });
      ctx.recordAction(`Create ${"disjoint-channel" /* DisjointChannel */} annotation`);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    super("start", {
      start: {
        click: {
          target: "end",
          action: actionCreate
        },
        drag: {
          target: "end",
          action: actionCreate
        },
        reset: StateMachine6.parent
      },
      end: {
        hover: actionEndUpdate,
        drag: actionEndUpdate,
        click: {
          // Ensure that a double event of drag before a single click does not trigger an immediate
          // transition causing the start and end to be at the same point.
          guard: ctx.guardDragClickDoubleEvent.guard,
          target: "height",
          action: actionEndFinish
        },
        reset: {
          target: StateMachine6.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine6.parent,
          action: actionCancel
        },
        onExit: ctx.guardDragClickDoubleEvent.reset
      },
      height: {
        hover: actionHeightUpdate,
        click: {
          target: StateMachine6.parent,
          action: actionHeightFinish
        },
        reset: {
          target: StateMachine6.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine6.parent,
          action: actionCancel
        }
      }
    });
    this.debug = _Util39.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelConfig.ts
var disjointChannelConfig = {
  type: "disjoint-channel" /* DisjointChannel */,
  datum: DisjointChannelProperties,
  scene: DisjointChannelScene,
  isDatum: DisjointChannelProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (DisjointChannelProperties.is(datum) && DisjointChannelProperties.is(copiedDatum) && DisjointChannelScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (DisjointChannelProperties.is(datum) && DisjointChannelScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new DisjointChannelStateMachine({
    ...ctx,
    create: createDatum("disjoint-channel" /* DisjointChannel */),
    datum: getDatum(DisjointChannelProperties.is),
    node: getNode(DisjointChannelScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(DisjointChannelProperties.is),
    node: getNode(DisjointChannelScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/line/lineScene.ts
import { _Scene as _Scene24, _Util as _Util41 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/annotations/scenes/capScene.ts
import { _Scene as _Scene23, _Util as _Util40 } from "ag-charts-community";
var { Vec2: Vec211 } = _Util40;
var CapScene = class extends _Scene23.Group {
};
var ArrowCapScene = class extends CapScene {
  constructor() {
    super();
    this.type = "arrow";
    this.path = new _Scene23.Path();
    this.armLength = 6;
    this.append([this.path]);
  }
  update(options) {
    const { path } = this;
    const { x, y, angle, ...rest } = options;
    const origin = Vec211.from(x, y);
    const offsetAngle = 3 * Math.PI / 4;
    const armLength = this.armLength + (options.strokeWidth ?? 0) * 2;
    const leftEnd = Vec211.rotate(Vec211.from(0, armLength), angle + offsetAngle, origin);
    const rightEnd = Vec211.rotate(Vec211.from(armLength, 0), angle - offsetAngle, origin);
    path.setProperties(rest);
    path.fillOpacity = 0;
    path.path.clear();
    path.path.moveTo(leftEnd.x, leftEnd.y);
    path.path.lineTo(origin.x, origin.y);
    path.path.lineTo(rightEnd.x, rightEnd.y);
  }
};

// packages/ag-charts-enterprise/src/features/annotations/line/lineScene.ts
var { Vec2: Vec212 } = _Util41;
var LineScene = class extends LinearScene {
  constructor() {
    super();
    this.type = "line";
    this.line = new CollidableLine();
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.anchor = { x: 0, y: 0 };
    this.updateText = LineWithTextScene.updateLineText.bind(this);
    this.append([this.line, this.start, this.end]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "line");
  }
  update(datum, context) {
    const locked = datum.locked ?? false;
    const coords = convertLine(datum, context);
    if (coords == null) {
      this.visible = false;
      return;
    }
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    this.updateLine(datum, coords, context);
    this.updateHandles(datum, coords, locked);
    this.updateText(datum, coords);
    this.updateCaps(datum, coords);
    this.updateAnchor(coords);
  }
  updateLine(datum, coords, context) {
    const { line } = this;
    const { lineDashOffset, stroke: stroke2, strokeWidth, strokeOpacity } = datum;
    const linePoints = this.extendLine(coords, datum, context);
    line.setProperties({
      ...linePoints,
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0,
      lineCap: datum.getLineCap()
    });
  }
  updateHandles(datum, coords, locked) {
    const { start, end, startCap, endCap } = this;
    const { stroke: stroke2, strokeWidth, strokeOpacity } = datum;
    let [startPoint, endPoint] = Vec212.from(coords);
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? stroke2,
      strokeOpacity: datum.handle.strokeOpacity ?? strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? strokeWidth
    };
    const angle = Vec212.angle(Vec212.sub(endPoint, startPoint));
    if (startCap) {
      startPoint = Vec212.rotate(Vec212.from(0, -DivariantHandle.HANDLE_SIZE / 2), angle, startPoint);
    }
    if (endCap) {
      endPoint = Vec212.rotate(Vec212.from(0, DivariantHandle.HANDLE_SIZE / 2), angle, endPoint);
    }
    start.update({ ...handleStyles, ...startPoint });
    end.update({ ...handleStyles, ...endPoint });
    start.toggleLocked(locked);
    end.toggleLocked(locked);
  }
  updateCaps(datum, coords) {
    if (!datum.startCap && this.startCap) {
      this.removeChild(this.startCap);
      this.startCap = void 0;
    }
    if (!datum.endCap && this.endCap) {
      this.removeChild(this.endCap);
      this.endCap = void 0;
    }
    if (!datum.startCap && !datum.endCap)
      return;
    const { stroke: stroke2, strokeWidth, strokeOpacity } = datum;
    const [start, end] = Vec212.from(coords);
    const angle = Vec212.angle(Vec212.sub(end, start));
    if (datum.startCap) {
      if (this.startCap && this.startCap.type !== datum.startCap) {
        this.removeChild(this.startCap);
        this.startCap = void 0;
      }
      if (this.startCap == null) {
        this.startCap = new ArrowCapScene();
        this.append([this.startCap]);
      }
      this.startCap.update({
        x: start.x,
        y: start.y,
        angle: angle - Math.PI,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity
      });
    }
    if (datum.endCap) {
      if (this.endCap && this.endCap.type !== datum.endCap) {
        this.removeChild(this.endCap);
        this.endCap = void 0;
      }
      if (this.endCap == null && datum.endCap) {
        this.endCap = new ArrowCapScene();
        this.append([this.endCap]);
      }
      this.endCap.update({
        x: end.x,
        y: end.y,
        angle,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity
      });
    }
  }
  updateAnchor(coords) {
    const { x, y } = _Scene24.Transformable.toCanvasPoint(
      this.line,
      (coords.x1 + coords.x2) / 2,
      Math.min(coords.y1, coords.y2)
    );
    this.anchor.x = x;
    this.anchor.y = y;
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      show = { start: show, end: show };
    }
    this.start.visible = show.start ?? true;
    this.end.visible = show.end ?? true;
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
  }
  dragHandle(datum, target, context) {
    const { activeHandle } = this;
    if (!activeHandle)
      return;
    this[activeHandle].toggleDragging(true);
    const point = invertCoords(this[activeHandle].drag(target).point, context);
    if (!validateDatumPoint(context, point))
      return;
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
  }
  containsPoint(x, y) {
    const { start, end, line, text: text2 } = this;
    this.activeHandle = void 0;
    if (start.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    return line.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
};

// packages/ag-charts-enterprise/src/features/annotations/line/lineState.ts
import { _ModuleSupport as _ModuleSupport53, _Util as _Util42 } from "ag-charts-community";
var { StateMachine: StateMachine7 } = _ModuleSupport53;
var LineTypeStateMachine = class extends StateMachine7 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point });
      ctx.create(datum);
    };
    const actionEndUpdate = ({ point }) => {
      ctx.guardDragClickDoubleEvent.hover();
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleActive(true);
      ctx.node()?.toggleHandles({ end: false });
      ctx.update();
    };
    const actionEndFinish = ({ point }) => {
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleHandles({ end: true });
    };
    const actionCancel = () => ctx.delete();
    const onExitEnd = () => {
      ctx.guardDragClickDoubleEvent.reset();
      ctx.showAnnotationOptions();
      ctx.recordAction(`Create ${ctx.node()?.type} annotation`);
    };
    super("start", {
      start: {
        reset: StateMachine7.parent,
        click: {
          target: "end",
          action: actionCreate
        },
        drag: {
          target: "end",
          action: actionCreate
        }
      },
      end: {
        hover: actionEndUpdate,
        click: {
          guard: ctx.guardDragClickDoubleEvent.guard,
          target: StateMachine7.parent,
          action: actionEndFinish
        },
        drag: actionEndUpdate,
        reset: {
          target: StateMachine7.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine7.parent,
          action: actionCancel
        },
        onExit: onExitEnd
      }
    });
    this.debug = _Util42.Debug.create(true, "annotations");
  }
};
var ArrowStateMachine = class extends LineTypeStateMachine {
  createDatum() {
    return new ArrowProperties();
  }
};
var LineStateMachine = class extends LineTypeStateMachine {
  createDatum() {
    return new LineProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/line/lineConfig.ts
var lineConfig = {
  type: "line" /* Line */,
  datum: LineProperties,
  scene: LineScene,
  isDatum: LineProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (LineProperties.is(datum) && LineProperties.is(copiedDatum) && LineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (LineProperties.is(datum) && LineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new LineStateMachine({
    ...ctx,
    create: createDatum("line" /* Line */),
    datum: getDatum(LineProperties.is),
    node: getNode(LineScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(LineProperties.is),
    node: getNode(LineScene.is)
  })
};
var arrowConfig = {
  type: "arrow" /* Arrow */,
  datum: ArrowProperties,
  scene: LineScene,
  isDatum: ArrowProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowProperties.is(datum) && ArrowProperties.is(copiedDatum) && LineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowProperties.is(datum) && LineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new ArrowStateMachine({
    ...ctx,
    create: createDatum("arrow" /* Arrow */),
    datum: getDatum(ArrowProperties.is),
    node: getNode(LineScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(ArrowProperties.is),
    node: getNode(LineScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/note/noteState.ts
var NoteStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new NoteProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/note/noteConfig.ts
var noteConfig = {
  type: "note" /* Note */,
  datum: NoteProperties,
  scene: NoteScene,
  isDatum: NoteProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (NoteProperties.is(datum) && NoteProperties.is(copiedDatum) && NoteScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (NoteProperties.is(datum) && NoteScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new NoteStateMachine({
    ...ctx,
    create: createDatum("note" /* Note */),
    datum: getDatum(NoteProperties.is),
    node: getNode(NoteScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(NoteProperties.is),
    node: getNode(NoteScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelScene.ts
import { _Util as _Util43 } from "ag-charts-community";
var { Vec2: Vec213 } = _Util43;
var ParallelChannelScene = class extends ChannelScene {
  constructor() {
    super();
    this.type = "parallel-channel";
    this.handles = {
      topLeft: new DivariantHandle(),
      topMiddle: new UnivariantHandle(),
      topRight: new DivariantHandle(),
      bottomLeft: new DivariantHandle(),
      bottomMiddle: new UnivariantHandle(),
      bottomRight: new DivariantHandle()
    };
    this.middleLine = new CollidableLine();
    this.updateText = LineWithTextScene.updateChannelText.bind(this, true);
    this.append([this.background, this.topLine, this.middleLine, this.bottomLine, ...Object.values(this.handles)]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "parallel-channel");
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      show = {
        topLeft: show,
        topMiddle: show,
        topRight: show,
        bottomLeft: show,
        bottomMiddle: show,
        bottomRight: show
      };
    }
    for (const [handle2, node] of Object.entries(this.handles)) {
      node.visible = show[handle2] ?? true;
      node.toggleHovered(this.activeHandle === handle2);
    }
  }
  toggleActive(active) {
    this.toggleHandles(active);
    for (const node of Object.values(this.handles)) {
      node.toggleActive(active);
    }
  }
  dragHandle(datum, target, context) {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    const { offset } = handles[activeHandle].drag(target);
    handles[activeHandle].toggleDragging(true);
    const prev = datum.toJson();
    let moves = [];
    switch (activeHandle) {
      case "topLeft":
      case "bottomLeft":
        moves = ["topLeft", "bottomLeft"];
        break;
      case "topMiddle":
        moves = ["topLeft", "topRight"];
        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;
        break;
      case "topRight":
      case "bottomRight":
        moves = ["topRight", "bottomRight"];
        break;
      case "bottomMiddle":
        moves = ["bottomLeft", "bottomRight"];
        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;
        break;
    }
    const invertedMoves = moves.map((move) => invertCoords(Vec213.add(handles[move].handle, offset), context));
    if (invertedMoves.some((invertedMove) => !validateDatumPoint(context, invertedMove))) {
      return;
    }
    if ((activeHandle === "topMiddle" || activeHandle === "bottomMiddle") && datum.start.y != null) {
      const topLeft = invertCoords(Vec213.add(handles.topLeft.handle, offset), context);
      if (validateDatumPoint(context, topLeft)) {
        if (activeHandle === "topMiddle") {
          datum.height += topLeft.y - datum.start.y;
        } else {
          datum.height -= topLeft.y - datum.start.y;
        }
      }
    }
    for (const [index, invertedMove] of invertedMoves.entries()) {
      switch (moves[index]) {
        case "topLeft":
          datum.start.x = invertedMove.x;
          datum.start.y = invertedMove.y;
          break;
        case "topRight":
          datum.end.x = invertedMove.x;
          datum.end.y = invertedMove.y;
          break;
      }
    }
    if (!datum.isValidWithContext(context)) {
      datum.set(prev);
    }
  }
  getOtherCoords(datum, topLeft, topRight, context) {
    const { dragState } = this;
    if (!dragState)
      return [];
    const height = convertPoint(datum.bottom.start, context).y - convertPoint(datum.start, context).y;
    const bottomLeft = Vec213.add(topLeft, Vec213.from(0, height));
    const bottomRight = Vec213.add(topRight, Vec213.from(0, height));
    return [bottomLeft, bottomRight];
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.middleLine.visible && this.middleLine.strokeWidth > 0 && this.middleLine.containsPoint(x, y);
  }
  updateLines(datum, top, bottom, context, naturalTop, naturalBottom) {
    const { topLine, middleLine, bottomLine } = this;
    const { lineDashOffset, stroke: stroke2, strokeOpacity, strokeWidth } = datum;
    const lineDash = datum.getLineDash();
    const lineStyles = {
      lineCap: datum.getLineCap(),
      lineDash,
      lineDashOffset,
      stroke: stroke2,
      strokeOpacity,
      strokeWidth
    };
    topLine.setProperties({
      x1: top.x1,
      y1: top.y1,
      x2: top.x2,
      y2: top.y2,
      ...lineStyles
    });
    bottomLine.setProperties({
      x1: bottom.x1,
      y1: bottom.y1,
      x2: bottom.x2,
      y2: bottom.y2,
      ...lineStyles
    });
    const middlePoints = this.extendLine(
      {
        x1: naturalTop.x1,
        y1: naturalBottom.y1 + (naturalTop.y1 - naturalBottom.y1) / 2,
        x2: naturalTop.x2,
        y2: naturalBottom.y2 + (naturalTop.y2 - naturalBottom.y2) / 2
      },
      datum,
      context
    );
    middleLine.setProperties({
      ...middlePoints,
      lineDash: datum.middle.lineDash ?? lineDash,
      lineDashOffset: datum.middle.lineDashOffset ?? lineDashOffset,
      stroke: datum.middle.stroke ?? stroke2,
      strokeOpacity: datum.middle.strokeOpacity ?? strokeOpacity,
      strokeWidth: datum.middle.strokeWidth ?? strokeWidth,
      visible: datum.middle.visible ?? true
    });
  }
  updateHandles(datum, top, bottom) {
    const {
      handles: { topLeft, topMiddle, topRight, bottomLeft, bottomMiddle, bottomRight }
    } = this;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
    topLeft.update({ ...handleStyles, x: top.x1, y: top.y1 });
    topRight.update({ ...handleStyles, x: top.x2, y: top.y2 });
    bottomLeft.update({ ...handleStyles, x: bottom.x1, y: bottom.y1 });
    bottomRight.update({ ...handleStyles, x: bottom.x2, y: bottom.y2 });
    topMiddle.update({
      ...handleStyles,
      x: top.x1 + (top.x2 - top.x1) / 2 - topMiddle.handle.width / 2,
      y: top.y1 + (top.y2 - top.y1) / 2 - topMiddle.handle.height / 2
    });
    bottomMiddle.update({
      ...handleStyles,
      x: bottom.x1 + (bottom.x2 - bottom.x1) / 2 - bottomMiddle.handle.width / 2,
      y: bottom.y1 + (bottom.y2 - bottom.y1) / 2 - bottomMiddle.handle.height / 2
    });
  }
  getBackgroundPoints(datum, top, bottom, bounds) {
    const isFlippedX = top.x1 > top.x2;
    const isFlippedY = top.y1 > top.y2;
    const outOfBoundsStart = top.x1 !== bottom.x1 && top.y1 !== bottom.y1;
    const outOfBoundsEnd = top.x2 !== bottom.x2 && top.y2 !== bottom.y2;
    const points = Vec213.from(top);
    if (datum.extendEnd && outOfBoundsEnd) {
      points.push(Vec213.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y1 : bounds.y2));
    }
    points.push(...Vec213.from(bottom).reverse());
    if (datum.extendStart && outOfBoundsStart) {
      points.push(Vec213.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y2 : bounds.y1));
    }
    return points;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelState.ts
import { _ModuleSupport as _ModuleSupport54, _Util as _Util44 } from "ag-charts-community";
var { StateMachine: StateMachine8 } = _ModuleSupport54;
var ParallelChannelStateMachine = class extends StateMachine8 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = new ParallelChannelProperties();
      datum.set({ start: point, end: point, height: 0 });
      ctx.create(datum);
    };
    const actionEndUpdate = ({ point }) => {
      ctx.guardDragClickDoubleEvent.hover();
      ctx.datum()?.set({ end: point, height: 0 });
      ctx.node()?.toggleHandles({
        topMiddle: false,
        topRight: false,
        bottomLeft: false,
        bottomMiddle: false,
        bottomRight: false
      });
      ctx.update();
    };
    const actionEndFinish = ({ point }) => {
      ctx.datum()?.set({ end: point });
      ctx.node()?.toggleHandles({ topMiddle: false, bottomMiddle: false });
      ctx.update();
    };
    const actionHeightUpdate = ({ point }) => {
      const datum = ctx.datum();
      if (datum?.start.y == null || datum?.end.y == null)
        return;
      const height = datum.end.y - (point.y ?? 0);
      const bottomStartY = datum.start.y - height;
      ctx.node()?.toggleHandles({ topMiddle: false, bottomMiddle: false });
      if (!ctx.validatePoint({ x: datum.start.x, y: bottomStartY }) || !ctx.validatePoint({ x: datum.end.x, y: point.y })) {
        return;
      }
      datum.set({ height });
      ctx.update();
    };
    const actionHeightFinish = ({ point }) => {
      const datum = ctx.datum();
      if (datum?.start.y == null || datum?.end.y == null)
        return;
      const height = datum.end.y - (point.y ?? 0);
      const bottomStartY = datum.start.y - height;
      ctx.node()?.toggleHandles(true);
      if (!ctx.validatePoint({ x: datum.start.x, y: bottomStartY }) || !ctx.validatePoint({ x: datum.end.x, y: point.y })) {
        return;
      }
      datum.set({ height });
      ctx.recordAction(`Create ${"parallel-channel" /* ParallelChannel */} annotation`);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    super("start", {
      start: {
        click: {
          target: "end",
          action: actionCreate
        },
        drag: {
          target: "end",
          action: actionCreate
        },
        reset: StateMachine8.parent
      },
      end: {
        hover: actionEndUpdate,
        drag: actionEndUpdate,
        click: {
          guard: ctx.guardDragClickDoubleEvent.guard,
          target: "height",
          action: actionEndFinish
        },
        reset: {
          target: StateMachine8.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine8.parent,
          action: actionCancel
        },
        onExit: ctx.guardDragClickDoubleEvent.reset
      },
      height: {
        hover: actionHeightUpdate,
        click: {
          target: StateMachine8.parent,
          action: actionHeightFinish
        },
        reset: {
          target: StateMachine8.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine8.parent,
          action: actionCancel
        }
      }
    });
    this.debug = _Util44.Debug.create(true, "annotations");
  }
};

// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelConfig.ts
var parallelChannelConfig = {
  type: "parallel-channel" /* ParallelChannel */,
  datum: ParallelChannelProperties,
  scene: ParallelChannelScene,
  isDatum: ParallelChannelProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (ParallelChannelProperties.is(datum) && ParallelChannelProperties.is(copiedDatum) && ParallelChannelScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ParallelChannelProperties.is(datum) && ParallelChannelScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new ParallelChannelStateMachine({
    ...ctx,
    create: createDatum("parallel-channel" /* ParallelChannel */),
    datum: getDatum(ParallelChannelProperties.is),
    node: getNode(ParallelChannelScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(ParallelChannelProperties.is),
    node: getNode(ParallelChannelScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/text/textScene.ts
var TextScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "text" /* Text */;
    this.append([this.label, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "text" /* Text */);
  }
  getHandleCoords(_datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    return {
      x: point.x + halfSize,
      y: point.y + 2 + halfSize
    };
  }
};

// packages/ag-charts-enterprise/src/features/annotations/text/textState.ts
var TextStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new TextProperties();
  }
};

// packages/ag-charts-enterprise/src/features/annotations/text/textConfig.ts
var textConfig = {
  type: "text" /* Text */,
  datum: TextProperties,
  scene: TextScene,
  isDatum: TextProperties.is,
  copy: (node, datum, copiedDatum, context) => {
    if (TextProperties.is(datum) && TextProperties.is(copiedDatum) && TextScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (TextProperties.is(datum) && TextScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum, getDatum, getNode }) => new TextStateMachine({
    ...ctx,
    create: createDatum("text" /* Text */),
    datum: getDatum(TextProperties.is),
    node: getNode(TextScene.is)
  }),
  dragState: (ctx, { getDatum, getNode }) => new DragStateMachine({
    ...ctx,
    datum: getDatum(TextProperties.is),
    node: getNode(TextScene.is)
  })
};

// packages/ag-charts-enterprise/src/features/annotations/annotationsConfig.ts
var annotationConfigs = {
  // Lines
  [lineConfig.type]: lineConfig,
  [horizontalLineConfig.type]: horizontalLineConfig,
  [verticalLineConfig.type]: verticalLineConfig,
  // Channels
  [parallelChannelConfig.type]: parallelChannelConfig,
  [disjointChannelConfig.type]: disjointChannelConfig,
  // Texts
  [calloutConfig.type]: calloutConfig,
  [commentConfig.type]: commentConfig,
  [noteConfig.type]: noteConfig,
  [textConfig.type]: textConfig,
  // Shapes
  [arrowConfig.type]: arrowConfig,
  [arrowUpConfig.type]: arrowUpConfig,
  [arrowDownConfig.type]: arrowDownConfig
};
function getTypedDatum(datum) {
  for (const { isDatum } of Object.values(annotationConfigs)) {
    if (isDatum(datum)) {
      return datum;
    }
  }
}

// packages/ag-charts-enterprise/src/features/annotations/annotationsMenuOptions.ts
var LINE_STROKE_WIDTH_ITEMS = [
  { strokeWidth: 1, label: "1", value: 1 },
  { strokeWidth: 2, label: "2", value: 2 },
  { strokeWidth: 3, label: "3", value: 3 },
  { strokeWidth: 4, label: "4", value: 4 },
  { strokeWidth: 8, label: "8", value: 8 }
];
var LINE_STYLE_TYPE_ITEMS = [
  { icon: "line-style-solid", altText: "iconAltTextLineStyleSolid", value: "solid" },
  { icon: "line-style-dashed", altText: "iconAltTextLineStyleDashed", value: "dashed" },
  { icon: "line-style-dotted", altText: "iconAltTextLineStyleDotted", value: "dotted" }
];
var TEXT_SIZE_ITEMS = [
  { label: "10", value: 10 },
  { label: "12", value: 12 },
  { label: "14", value: 14 },
  { label: "16", value: 16 },
  { label: "18", value: 18 },
  { label: "22", value: 22 },
  { label: "28", value: 28 },
  { label: "36", value: 36 },
  { label: "46", value: 46 }
];

// packages/ag-charts-enterprise/src/features/annotations/annotationsStateMachine.ts
import { _ModuleSupport as _ModuleSupport56, _Util as _Util45 } from "ag-charts-community";
var { StateMachine: StateMachine9 } = _ModuleSupport56;
var AnnotationsStateMachine = class extends StateMachine9 {
  constructor(ctx) {
    let selectedWithDrag = false;
    let hoverEventsCount = 0;
    const guardDragClickDoubleEvent = {
      guard: () => hoverEventsCount > 0,
      hover: () => {
        hoverEventsCount++;
      },
      reset: () => {
        hoverEventsCount = 0;
      }
    };
    const getDatum = (is) => () => {
      if (this.active == null)
        return;
      const datum = ctx.datum(this.active);
      if (is(datum))
        return datum;
    };
    const getNode = (is) => () => {
      if (this.active == null)
        return;
      const node = ctx.node(this.active);
      if (is(node))
        return node;
    };
    const createDatum = (type) => (datum) => {
      ctx.create(type, datum);
      this.active = ctx.selectLast();
    };
    const deleteDatum = () => {
      if (this.active != null)
        ctx.delete(this.active);
      this.active = void 0;
      ctx.select();
    };
    const stateMachineHelpers = {
      createDatum,
      getDatum,
      // TODO
      getNode
      // TODO
    };
    const createStateMachineContext = {
      ...ctx,
      delete: deleteDatum,
      guardDragClickDoubleEvent,
      showTextInput: () => {
        if (this.active != null)
          ctx.showTextInput(this.active);
      },
      deselect: () => {
        const prevActive = this.active;
        this.active = void 0;
        this.hovered = void 0;
        ctx.select(this.active, prevActive);
      },
      showAnnotationOptions: () => {
        if (this.active != null)
          ctx.showAnnotationOptions(this.active);
      }
    };
    const createStateMachines = Object.fromEntries(
      Object.entries(annotationConfigs).map(([type, config]) => [
        type,
        config.createState(createStateMachineContext, stateMachineHelpers)
      ])
    );
    const dragStateMachineContext = {
      ...ctx,
      setSelectedWithDrag: () => {
        selectedWithDrag = true;
      }
    };
    const dragStateMachines = Object.fromEntries(
      Object.entries(annotationConfigs).map(([type, config]) => [
        type,
        config.dragState(dragStateMachineContext, stateMachineHelpers)
      ])
    );
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color,
      opacity
    }) => {
      const datum = ctx.datum(this.active);
      if (!datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color);
      }
      setColor(datum, colorPickerType, colorOpacity, color, opacity);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const datum = ctx.datum(this.active);
      const node = ctx.node(this.active);
      if (!datum || !node)
        return;
      if (isTextType(datum)) {
        datum.fontSize = fontSize;
        ctx.updateTextInputFontSize(fontSize);
      } else if (hasLineText(datum)) {
        datum.text.fontSize = fontSize;
      }
      ctx.update();
    };
    const actionLineStyle = (lineStyle) => {
      const datum = ctx.datum(this.active);
      const node = ctx.node(this.active);
      if (!datum || !node || !hasLineStyle(datum))
        return;
      setLineStyle(datum, lineStyle);
      ctx.update();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      const node = ctx.node(this.active);
      if (!node || !("setTextInputBBox" in node))
        return;
      node.setTextInputBBox(bbox);
      ctx.update();
    };
    const actionSaveText = ({ textInputValue }) => {
      const datum = ctx.datum(this.active);
      if (textInputValue != null && textInputValue.length > 0) {
        datum?.set({ text: textInputValue });
        ctx.update();
        ctx.recordAction(`Change ${datum?.type} annotation text`);
      } else {
        ctx.delete(this.active);
        ctx.recordAction(`Delete ${datum?.type} annotation`);
      }
    };
    const actionCancel = () => {
      ctx.updateTextInputBBox(void 0);
    };
    const guardActive = () => this.active != null;
    const guardCopied = () => this.copied != null;
    const guardActiveHasLineText = () => {
      if (this.active == null)
        return false;
      const datum = ctx.datum(this.active);
      if (!datum)
        return false;
      return hasLineText(datum) && !datum.locked;
    };
    const guardHovered = () => this.hovered != null;
    super("idle" /* Idle */, {
      ["idle" /* Idle */]: {
        onEnter: () => {
          ctx.select(this.active, this.active);
        },
        hover: ({ offset }) => {
          this.hovered = ctx.hoverAtCoords(offset, this.active);
        },
        copy: {
          guard: guardActive,
          action: () => {
            this.copied = ctx.copy(this.active);
          }
        },
        cut: {
          guard: guardActive,
          action: () => {
            this.copied = ctx.copy(this.active);
            deleteDatum();
          }
        },
        paste: {
          guard: guardCopied,
          action: () => {
            ctx.paste(this.copied);
          }
        },
        selectLast: () => {
          const previousActive = this.active;
          this.active = ctx.selectLast();
          ctx.select(this.active, previousActive);
        },
        click: [
          {
            guard: () => {
              if (this.active == null || this.hovered !== this.active || selectedWithDrag)
                return false;
              const datum = ctx.datum(this.active);
              if (!datum)
                return false;
              return isTextType(datum) && !datum.locked;
            },
            target: "text-input" /* TextInput */
          },
          {
            action: () => {
              const prevActive = this.active;
              this.active = this.hovered;
              ctx.select(this.hovered, prevActive);
              selectedWithDrag = false;
            }
          }
        ],
        dblclick: {
          guard: guardActiveHasLineText,
          action: () => {
            ctx.showAnnotationSettings(this.active, void 0);
          }
        },
        drag: {
          guard: guardHovered,
          action: () => {
            const prevActive = this.active;
            this.active = this.hovered;
            ctx.select(this.hovered, prevActive);
          }
        },
        dragStart: {
          guard: guardHovered,
          target: "dragging" /* Dragging */,
          action: () => {
            selectedWithDrag = this.active == null || this.hovered != this.active;
            const prevActive = this.active;
            this.active = this.hovered;
            ctx.select(this.hovered, prevActive);
            ctx.startInteracting();
          }
        },
        color: {
          guard: guardActive,
          action: actionColor
        },
        fontSize: {
          guard: guardActive,
          action: actionFontSize
        },
        lineProps: {
          guard: guardActive,
          action: (props) => {
            const datum = getTypedDatum(ctx.datum(this.active));
            datum?.set(props);
            ctx.update();
            ctx.recordAction(
              `Change ${datum?.type} ${Object.entries(props).map(([key, value]) => `${key} to ${value}`).join(", ")}`
            );
          }
        },
        lineStyle: {
          guard: guardActive,
          action: actionLineStyle
        },
        lineText: {
          guard: guardActive,
          action: (props) => {
            const datum = getTypedDatum(ctx.datum(this.active));
            if (!hasLineText(datum))
              return;
            if (isChannelType(datum) && props.position === "center") {
              props.position = "inside";
            }
            datum.text.set(props);
            ctx.update();
          }
        },
        updateTextInputBBox: {
          guard: guardActive,
          action: actionUpdateTextInputBBox
        },
        toolbarPressSettings: {
          guard: guardActiveHasLineText,
          action: (sourceEvent) => {
            ctx.showAnnotationSettings(this.active, sourceEvent);
          }
        },
        reset: () => {
          if (this.active != null) {
            ctx.node(this.active)?.toggleActive(false);
          }
          this.hovered = void 0;
          this.active = void 0;
          ctx.resetToIdle();
        },
        delete: () => {
          if (this.active == null)
            return;
          ctx.delete(this.active);
          ctx.recordAction(`Delete ${ctx.datum(this.active)?.type} annotation`);
        },
        deleteAll: () => {
          ctx.deleteAll();
        },
        ...createStateMachines
      },
      ["dragging" /* Dragging */]: {
        onEnter: (_, data) => {
          if (this.active == null)
            return;
          const type = ctx.getAnnotationType(this.active);
          if (!type)
            return;
          this.transition(type);
          this.transition("dragStart", data);
        },
        ...dragStateMachines
      },
      ["text-input" /* TextInput */]: {
        onEnter: () => {
          if (this.active == null)
            return;
          const datum = getTypedDatum(ctx.datum(this.active));
          if (!datum || !("getTextInputCoords" in datum))
            return;
          ctx.startInteracting();
          ctx.showTextInput(this.active);
          datum.visible = false;
          ctx.update();
        },
        updateTextInputBBox: {
          guard: guardActive,
          action: actionUpdateTextInputBBox
        },
        click: {
          target: "idle" /* Idle */,
          action: actionSaveText
        },
        keyDown: [
          {
            guard: guardCancelAndExit,
            target: "idle" /* Idle */,
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: "idle" /* Idle */,
            action: actionSaveText
          }
        ],
        color: {
          guard: guardActive,
          action: actionColor
        },
        fontSize: {
          guard: guardActive,
          action: actionFontSize
        },
        cancel: {
          target: "idle" /* Idle */,
          action: actionCancel
        },
        onExit: () => {
          ctx.stopInteracting();
          ctx.hideTextInput();
          const wasActive = this.active;
          const prevActive = this.active;
          this.active = this.hovered = void 0;
          ctx.select(this.active, prevActive);
          if (wasActive == null)
            return;
          const datum = ctx.datum(wasActive);
          const node = ctx.node(wasActive);
          if (!datum || !node)
            return;
          datum.visible = true;
        }
      }
    });
    this.debug = _Util45.Debug.create(true, "annotations");
  }
  // TODO: remove this leak
  getActive() {
    return this.active;
  }
  // TODO: remove this leak
  isActive(index) {
    return index === this.active;
  }
};

// packages/ag-charts-enterprise/src/features/annotations/axisButton.ts
import { _ModuleSupport as _ModuleSupport57 } from "ag-charts-community";
var { BaseModuleInstance: BaseModuleInstance2, InteractionState, Validate: Validate24, BOOLEAN: BOOLEAN5, createElement: createElement4, REGIONS, ChartAxisDirection: ChartAxisDirection9 } = _ModuleSupport57;
var DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS = `ag-charts-annotations__axis-button`;
var AxisButton = class extends BaseModuleInstance2 {
  constructor(ctx, axisCtx, onButtonClick, seriesRect) {
    super();
    this.ctx = ctx;
    this.axisCtx = axisCtx;
    this.onButtonClick = onButtonClick;
    this.seriesRect = seriesRect;
    this.enabled = true;
    this.snap = false;
    this.padding = 0;
    const { button, wrapper } = this.setup();
    this.wrapper = wrapper;
    this.button = button;
    this.toggleVisibility(false);
    this.updateButtonElement();
    this.snap = axisCtx.scaleBandwidth() > 0;
    const seriesRegion = this.ctx.regionManager.getRegion(REGIONS.SERIES);
    const mouseMoveStates = InteractionState.Default | InteractionState.Annotations;
    this.destroyFns.push(
      seriesRegion.addListener("hover", (event) => this.show(event), mouseMoveStates),
      seriesRegion.addListener("drag", (event) => this.show(event), InteractionState.Annotations),
      seriesRegion.addListener("drag", () => this.hide(), InteractionState.ZoomDrag),
      seriesRegion.addListener("leave", () => this.hide(), InteractionState.Default),
      ctx.zoomManager.addListener("zoom-change", () => this.hide()),
      () => this.destroyElements(),
      () => this.wrapper.remove(),
      () => this.button.remove()
    );
  }
  update(seriesRect, padding) {
    this.seriesRect = seriesRect;
    this.padding = padding;
  }
  setup() {
    const wrapper = this.ctx.domManager.addChild(
      "canvas-overlay",
      `${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-${this.axisCtx.axisId}`
    );
    wrapper.classList.add(`${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-wrapper`);
    const button = createElement4("button");
    button.classList.add(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);
    wrapper.appendChild(button);
    return {
      wrapper,
      button
    };
  }
  destroyElements() {
    this.ctx.domManager.removeChild("canvas-overlay", DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);
  }
  show(event) {
    if (!this.enabled)
      return;
    this.toggleVisibility(true);
    const buttonCoords = this.getButtonCoordinates({ x: event.offsetX, y: event.offsetY });
    this.coords = this.getAxisCoordinates(buttonCoords);
    this.updatePosition(buttonCoords);
  }
  hide() {
    this.toggleVisibility(false);
  }
  getButtonCoordinates({ x, y }) {
    const {
      axisCtx: { direction, position },
      seriesRect,
      snap,
      axisCtx,
      padding
    } = this;
    const { clientWidth: buttonWidth, clientHeight: buttonHeight } = this.button;
    const [minY, maxY] = [seriesRect.y, seriesRect.y + seriesRect.height];
    const [minX, maxX] = [seriesRect.x, seriesRect.x + seriesRect.width];
    if (snap) {
      x = convert(invert(x - seriesRect.x, axisCtx), axisCtx) + seriesRect.x;
      y = convert(invert(y - seriesRect.y, axisCtx), axisCtx) + seriesRect.y;
    }
    if (direction === ChartAxisDirection9.X) {
      const crosshairLabelPadding = 5;
      const offset = buttonHeight - Math.max(0, padding - crosshairLabelPadding);
      x = x - buttonWidth / 2;
      y = position === "top" ? minY - buttonHeight + offset : maxY - offset;
    } else {
      const crosshairLabelPadding = 9;
      const offset = buttonWidth - Math.max(0, padding - crosshairLabelPadding);
      x = position === "left" ? minX - buttonWidth + offset : maxX - offset;
      y = y - buttonHeight / 2;
    }
    return { x, y };
  }
  getAxisCoordinates(coords) {
    const { seriesRect } = this;
    const { clientWidth: buttonWidth, clientHeight: buttonHeight } = this.button;
    const x = coords.x - seriesRect.x + buttonWidth / 2;
    const y = coords.y - seriesRect.y + buttonHeight / 2;
    return {
      x,
      y
    };
  }
  toggleVisibility(visible) {
    const { button } = this;
    if (button == null)
      return;
    const isVisible = this.enabled && visible;
    this.toggleClass("-hidden", !isVisible);
  }
  toggleClass(name, include) {
    this.wrapper.classList.toggle(`${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-wrapper-${name}`, include);
  }
  updatePosition({ x, y }) {
    this.wrapper.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
  }
  updateButtonElement() {
    const { button, ctx } = this;
    button.onclick = _ModuleSupport57.makeAccessibleClickListener(button, () => this.onButtonClick(this.coords));
    button.innerHTML = `<span class="${ctx.domManager.getIconClassNames("zoom-in")} ${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-icon"></span>`;
  }
};
__decorateClass([
  Validate24(BOOLEAN5)
], AxisButton.prototype, "enabled", 2);

// packages/ag-charts-enterprise/src/features/annotations/settings-dialog/settingsDialog.ts
import { _ModuleSupport as _ModuleSupport59 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/components/dialog/dialog.ts
import { _ModuleSupport as _ModuleSupport58, _Util as _Util46 } from "ag-charts-community";
var {
  createButton,
  createCheckbox,
  createElement: createElement5,
  createElementId,
  createIcon,
  createSelect,
  createTextArea,
  initRovingTabIndex,
  getWindow,
  mapValues
} = _ModuleSupport58;
var { Vec2: Vec214, setAttribute, setAttributes } = _Util46;
var _Dialog = class _Dialog extends Popover {
  constructor(ctx, id) {
    super(ctx, id);
    this.colorPicker = new ColorPicker(this.ctx, { detached: true });
    this.destroyFns.push(ctx.layoutManager.addListener("layout:complete", this.onLayoutComplete.bind(this)));
  }
  showWithChildren(children, options) {
    options.initialFocus ?? (options.initialFocus = this.initialFocus);
    const popover = super.showWithChildren(children, options);
    popover.classList.add("ag-charts-dialog");
    popover.setAttribute("role", "dialog");
    popover.addEventListener("mousedown", (event) => {
      if (event.target.classList?.contains("ag-charts-dialog__color-picker-button"))
        return;
      this.colorPicker.hide();
    });
    popover.addEventListener("keydown", this.onKeyDown.bind(this));
    getWindow().requestAnimationFrame(() => this.reposition());
    this.colorPicker.attachTo(this);
    return popover;
  }
  updatePosition(position) {
    super.updatePosition(position);
    const { anchor, fallbackAnchor } = this.getColorPickerAnchors() ?? {};
    if (!anchor)
      return;
    this.colorPicker.setAnchor(anchor, fallbackAnchor);
  }
  /**************
   * Containers *
   **************/
  createTabs(tablistLabel, initial, tabs) {
    const element = createElement5("div", "ag-charts-dialog__tabs");
    const tabButtonIds = mapValues(tabs, () => createElementId("ag-charts-dialog__tab"));
    const tabPanelIds = mapValues(tabs, () => createElementId("ag-charts-dialog__tab-panel"));
    for (const [key, tab] of Object.entries(tabs)) {
      setAttributes(tab.panel, {
        id: tabPanelIds[key],
        role: "tabpanel",
        "aria-labelledby": tabButtonIds[key]
      });
    }
    const onPressTab = (active) => {
      for (const [key, tab] of Object.entries(tabs)) {
        tab.panel.classList.toggle("ag-charts-dialog__tab-panel--active", key === active);
        tabButtons[key].classList.toggle("ag-charts-dialog__tab-button--active", key === active);
        setAttribute(tabButtons[key], "aria-selected", key === active);
        if (key === active)
          tab.onShow?.();
      }
    };
    const header = createElement5("div", "ag-charts-dialog__header");
    header.addEventListener("mousedown", (event) => {
      if (event.target instanceof Element && event.target.classList.contains("ag-charts-dialog__header")) {
        this.onDragStart(event);
      }
    });
    const dragHandle = this.createHeaderDragHandle();
    const tabButtons = mapValues(
      tabs,
      (tab, key) => createButton(
        {
          label: this.ctx.localeManager.t(tab.label),
          onPress: () => onPressTab(key)
        },
        {
          id: tabButtonIds[key],
          class: "ag-charts-dialog__tab-button",
          role: "tab",
          "aria-controls": tabPanelIds[key]
        }
      )
    );
    const tablist = createElement5("div");
    setAttributes(tablist, { role: "tablist", "aria-label": this.ctx.localeManager.t(tablistLabel) });
    tablist.append(...Object.values(tabButtons));
    const closeButton = this.createHeaderCloseButton();
    header.append(dragHandle, tablist, closeButton);
    element.append(header, ...Object.values(tabs).map((t) => t.panel));
    onPressTab(initial);
    initRovingTabIndex({ orientation: "horizontal", buttons: Object.values(tabButtons) });
    this.initialFocus = tabButtons[initial];
    return element;
  }
  createTabPanel() {
    return createElement5("div", "ag-charts-dialog__tab-panel");
  }
  /**********
   * Inputs *
   **********/
  createInputGroupLine() {
    return createElement5("div", "ag-charts-dialog__input-group-line");
  }
  createRadioGroup({ label, options, value, onChange }) {
    const group = this.createInputGroup(label);
    setAttributes(group, {
      role: "radiogroup",
      tabindex: -1,
      "aria-label": this.ctx.localeManager.t(label)
    });
    const activeClass = "ag-charts-dialog__button--active";
    const buttons2 = [];
    for (const button of options) {
      const { icon, altText: altTextKey } = button;
      const altText = this.ctx.localeManager.t(altTextKey);
      const buttonEl = createButton(
        {
          icon,
          altText,
          onPress: () => {
            for (const b of Array.from(group.children)) {
              b.classList.remove(activeClass);
              b.ariaChecked = "false";
            }
            buttonEl.classList.add(activeClass);
            buttonEl.ariaChecked = "true";
            onChange(button.value);
          }
        },
        {
          "aria-checked": button.value === value,
          class: "ag-charts-dialog__button",
          role: "radio",
          title: altText
        }
      );
      if (button.value === value) {
        buttonEl.classList.add(activeClass);
      }
      group.appendChild(buttonEl);
      buttons2.push(buttonEl);
    }
    initRovingTabIndex({ orientation: "horizontal", buttons: buttons2 });
    return group;
  }
  createSelect({ altText, label, options, value, onChange }) {
    const group = this.createInputGroup(label);
    const altTextT = this.ctx.localeManager.t(altText);
    const select = createSelect(
      { value, options, onChange },
      { class: "ag-charts-dialog__select", "aria-label": altTextT, title: altTextT }
    );
    group.append(select);
    return group;
  }
  createTextArea({ placeholder, value, onChange }) {
    const placeholderT = placeholder ? this.ctx.localeManager.t(placeholder) : void 0;
    return createTextArea({ value, onChange }, { placeholder: placeholderT });
  }
  createCheckbox({ label, checked, onChange }) {
    const id = `ag-charts__${label}`;
    const group = this.createInputGroup(label, { for: id });
    const checkbox = createCheckbox(
      { checked, onChange },
      { class: "ag-charts-dialog__checkbox", role: "switch", id }
    );
    group.append(checkbox);
    return group;
  }
  createColorPicker({ value, label, altText, onChange, onChangeHide }) {
    const group = this.createInputGroup(label);
    const altTextT = this.ctx.localeManager.t(altText);
    const colorEl = createButton(
      {
        label: altTextT,
        onPress: (event) => {
          const { anchor, fallbackAnchor } = this.getColorPickerAnchors(colorEl) ?? {};
          this.colorPicker.show({
            anchor,
            fallbackAnchor,
            color: defaultColor,
            opacity: 1,
            sourceEvent: event,
            onChange: (colorOpacity, color, opacity) => {
              defaultColor = colorOpacity;
              colorEl.style.setProperty("--color", colorOpacity);
              onChange(colorOpacity, color, opacity);
            },
            onChangeHide
          });
        }
      },
      {
        "aria-label": altTextT,
        tabindex: 0,
        class: "ag-charts-dialog__color-picker-button",
        title: altTextT
      }
    );
    if (value)
      colorEl.style.setProperty("--color", value);
    let defaultColor = value;
    group.append(colorEl);
    this.hideFns.push(() => {
      this.colorPicker.hide();
    });
    return group;
  }
  /***********
   * Private *
   ***********/
  createHeaderDragHandle() {
    const dragHandle = createElement5("div", "ag-charts-dialog__drag-handle");
    const dragHandleIcon = createIcon("drag-handle");
    dragHandle.append(dragHandleIcon);
    dragHandle.addEventListener("mousedown", (event) => this.onDragStart(event, dragHandle));
    return dragHandle;
  }
  createHeaderCloseButton() {
    return createButton(
      { icon: "close", altText: this.ctx.localeManager.t("iconAltTextClose"), onPress: () => this.hide() },
      { class: "ag-charts-dialog__close-button" }
    );
  }
  createInputGroup(label, options) {
    const group = createElement5("div", "ag-charts-dialog__input-group");
    const labelEl = createElement5("label", "ag-charts-dialog__input-group-label");
    labelEl.innerText = this.ctx.localeManager.t(label);
    if (options?.for)
      labelEl.setAttribute("for", options.for);
    group.appendChild(labelEl);
    return group;
  }
  onLayoutComplete(event) {
    this.seriesRect = event.series.paddedRect;
    this.reposition();
  }
  onKeyDown(event) {
    if (event.altKey || event.ctrlKey || event.metaKey || event.isComposing || event.key !== "Escape")
      return;
    this.hide();
  }
  onDragStart(event, dragHandle) {
    const popover = this.getPopoverElement();
    if (!popover)
      return;
    const {
      ctx: { domManager }
    } = this;
    event.preventDefault();
    this.dragStartState = {
      client: Vec214.from(event.clientX, event.clientY),
      position: Vec214.from(
        Number(popover.style.getPropertyValue("left").replace("px", "")),
        Number(popover.style.getPropertyValue("top").replace("px", ""))
      )
    };
    dragHandle?.classList.add("ag-charts-dialog__drag-handle--dragging");
    const onDrag = this.onDrag.bind(this);
    const onDragEnd = () => {
      domManager.removeEventListener("mousemove", onDrag);
      dragHandle?.classList.remove("ag-charts-dialog__drag-handle--dragging");
    };
    domManager.addEventListener("mousemove", onDrag);
    domManager.addEventListener("mouseup", onDragEnd, { once: true });
    popover.addEventListener("mouseup", () => onDragEnd, { once: true });
  }
  onDrag(event) {
    const { dragStartState } = this;
    const popover = this.getPopoverElement();
    if (!dragStartState || !popover)
      return;
    const offset = Vec214.sub(Vec214.from(event.clientX, event.clientY), dragStartState.client);
    const position = Vec214.add(dragStartState.position, offset);
    const bounds = this.ctx.domManager.getBoundingClientRect();
    if (position.x >= bounds.x && position.x + popover.offsetWidth <= bounds.width) {
      popover.style.setProperty("left", `${position.x}px`);
    }
    if (position.y >= bounds.y && position.y + popover.offsetHeight <= bounds.height) {
      popover.style.setProperty("top", `${position.y}px`);
    }
  }
  reposition() {
    const { seriesRect, ctx } = this;
    const clientRect = ctx.domManager.getBoundingClientRect();
    const popover = this.getPopoverElement();
    if (!seriesRect || !popover)
      return;
    const outerOffset = Vec214.from(0, seriesRect.y);
    const outerSize = Vec214.from(clientRect.width, seriesRect.height);
    const popoverSize = Vec214.from(popover);
    const halfWidth = Vec214.from(0.5, 1);
    let position;
    if (seriesRect.width > 1e3) {
      const bottomCenter = Vec214.sub(
        Vec214.add(outerOffset, Vec214.multiply(outerSize, halfWidth)),
        Vec214.multiply(popoverSize, halfWidth)
      );
      position = Vec214.sub(bottomCenter, Vec214.from(0, _Dialog.offset));
    } else {
      const bottomRight = Vec214.sub(Vec214.add(outerOffset, outerSize), popoverSize);
      position = Vec214.sub(bottomRight, _Dialog.offset);
    }
    this.updatePosition(position);
  }
  getColorPickerAnchors(element) {
    if (element)
      this.colorPickerAnchorElement = element;
    if (!this.colorPickerAnchorElement)
      return;
    const rect = this.colorPickerAnchorElement.getBoundingClientRect();
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    const topLeft = Vec214.sub(Vec214.from(rect.x, rect.y), Vec214.from(canvasRect.left, canvasRect.top));
    const anchor = Vec214.add(topLeft, Vec214.from(0, rect.height + 5));
    const fallbackAnchor = Vec214.sub(topLeft, Vec214.from(0, 5));
    return { anchor, fallbackAnchor };
  }
};
_Dialog.offset = 60;
var Dialog = _Dialog;

// packages/ag-charts-enterprise/src/features/annotations/settings-dialog/settingsDialog.ts
var { focusCursorAtEnd: focusCursorAtEnd2 } = _ModuleSupport59;
var AnnotationSettingsDialog = class extends Dialog {
  constructor(ctx) {
    super(ctx, "settings");
  }
  showLineOrChannel(datum, options) {
    const lineTab = this.createLinearLineTab(datum, options);
    const textTab = this.createLinearTextTab(datum, options);
    const tabs = this.createTabs("ariaLabelSettingsTabBar", "line", {
      line: {
        label: isChannelType(datum) ? "dialogHeaderChannel" : "dialogHeaderLine",
        panel: lineTab
      },
      text: {
        label: "dialogHeaderText",
        panel: textTab.panel,
        onShow: textTab.onShow
      }
    });
    const popover = this.showWithChildren([tabs], options);
    popover.classList.add("ag-charts-dialog--annotation-settings");
  }
  createLinearLineTab(datum, options) {
    const panel = this.createTabPanel();
    const colorAndStrokeWidth = this.createInputGroupLine();
    const colorPicker = this.createColorPickerInput(
      datum.getDefaultColor("line-color"),
      options.onChangeLineColor,
      options.onChangeHideLineColor
    );
    const strokeWidth = this.createStrokeWidthSelect(datum.strokeWidth ?? 2, options.onChangeLineStyleWidth);
    colorAndStrokeWidth.append(colorPicker, strokeWidth);
    const lineStyle = this.createLineStyleRadioGroup(datum.lineStyle ?? "solid", options.onChangeLineStyleType);
    panel.append(colorAndStrokeWidth, lineStyle);
    if ("extendStart" in datum && "extendEnd" in datum) {
      panel.append(
        this.createCheckbox({
          label: isChannelType(datum) ? "dialogInputExtendChannelStart" : "dialogInputExtendLineStart",
          checked: datum.extendStart ?? false,
          onChange: (extendStart) => options.onChangeLine({ extendStart })
        }),
        this.createCheckbox({
          label: isChannelType(datum) ? "dialogInputExtendChannelEnd" : "dialogInputExtendLineEnd",
          checked: datum.extendEnd ?? false,
          onChange: (extendEnd) => options.onChangeLine({ extendEnd })
        })
      );
    }
    return panel;
  }
  createLinearTextTab(datum, options) {
    const panel = this.createTabPanel();
    const textArea = this.createTextArea({
      placeholder: "inputTextareaPlaceholder",
      value: datum.text.label,
      onChange: (value) => options.onChangeText({ label: value })
    });
    const fontSizeAndColor = this.createInputGroupLine();
    const fontSize = this.createFontSizeSelect(datum.text.fontSize, options.onChangeTextFontSize);
    const colorPicker = this.createColorPickerInput(
      datum.text.color,
      options.onChangeTextColor,
      options.onChangeHideTextColor
    );
    fontSizeAndColor.append(fontSize, colorPicker);
    const positionAndAlignment = this.createInputGroupLine();
    const textPosition = datum.text.position === "inside" ? "center" : datum.text.position;
    const position = this.createPositionRadioGroup(
      textPosition ?? "top",
      (value) => options.onChangeText({ position: value })
    );
    const alignment = this.createAlignmentRadioGroup(
      datum.text.alignment ?? "center",
      (value) => options.onChangeText({ alignment: value })
    );
    positionAndAlignment.append(position, alignment);
    panel.append(textArea, fontSizeAndColor, positionAndAlignment);
    return { panel, onShow: () => focusCursorAtEnd2(textArea) };
  }
  createColorPickerInput(color, onChange, onChangeHide) {
    return this.createColorPicker({
      label: "dialogInputColorPicker",
      altText: "dialogInputColorPickerAltText",
      value: color,
      onChange,
      onChangeHide
    });
  }
  createStrokeWidthSelect(strokeWidth, onChange) {
    return this.createSelect({
      label: "dialogInputStrokeWidth",
      altText: "dialogInputStrokeWidthAltText",
      options: LINE_STROKE_WIDTH_ITEMS.map(({ label, value }) => ({ label, value: `${value}` })),
      value: String(strokeWidth),
      onChange: (value) => onChange(Number(value))
    });
  }
  createLineStyleRadioGroup(lineStyle, onChange) {
    return this.createRadioGroup({
      label: "dialogInputLineStyle",
      options: [
        { icon: "line-style-solid", altText: "iconAltTextLineStyleSolid", value: "solid" },
        { icon: "line-style-dashed", altText: "iconAltTextLineStyleDashed", value: "dashed" },
        { icon: "line-style-dotted", altText: "iconAltTextLineStyleDotted", value: "dotted" }
      ],
      value: lineStyle,
      onChange
    });
  }
  createFontSizeSelect(fontSize, onChange) {
    return this.createSelect({
      label: "dialogInputFontSize",
      altText: "dialogInputFontSizeAltText",
      options: TEXT_SIZE_ITEMS.map(({ label, value }) => ({ label, value: String(value) })),
      value: String(fontSize),
      onChange: (value) => onChange(Number(value))
    });
  }
  createPositionRadioGroup(position, onChange) {
    return this.createRadioGroup({
      label: "dialogInputPosition",
      options: [
        { icon: "position-top", altText: "iconAltTextPositionTop", value: "top" },
        { icon: "position-center", altText: "iconAltTextPositionCenter", value: "center" },
        { icon: "position-bottom", altText: "iconAltTextPositionBottom", value: "bottom" }
      ],
      value: position,
      onChange
    });
  }
  createAlignmentRadioGroup(alignment, onChange) {
    return this.createRadioGroup({
      label: "dialogInputAlign",
      options: [
        { icon: "align-left", altText: "iconAltTextAlignLeft", value: "left" },
        { icon: "align-center", altText: "iconAltTextAlignCenter", value: "center" },
        { icon: "align-right", altText: "iconAltTextAlignRight", value: "right" }
      ],
      value: alignment,
      onChange
    });
  }
};

// packages/ag-charts-enterprise/src/features/annotations/utils/axis.ts
function calculateAxisLabelPadding(axisLayout) {
  return axisLayout.gridPadding + axisLayout.seriesAreaPadding + axisLayout.tickSize + axisLayout.label.padding;
}

// packages/ag-charts-enterprise/src/features/annotations/utils/update.ts
function updateAnnotation(node, datum, context) {
  for (const { update } of Object.values(annotationConfigs)) {
    update(node, datum, context);
  }
}

// packages/ag-charts-enterprise/src/features/annotations/annotations.ts
var {
  BOOLEAN: BOOLEAN6,
  ChartUpdateType,
  InteractionState: InteractionState2,
  ObserveChanges: ObserveChanges2,
  PropertiesArray,
  ToolbarManager,
  Validate: Validate25,
  REGIONS: REGIONS2,
  UNION: UNION4,
  ChartAxisDirection: ChartAxisDirection10
} = _ModuleSupport60;
var { Vec2: Vec215 } = _Util47;
var AXIS_TYPE = UNION4(["x", "y", "xy"], "an axis type");
var LINE_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsTrendLine",
    icon: "trend-line-drawing",
    value: "line" /* Line */
  },
  {
    label: "toolbarAnnotationsHorizontalLine",
    icon: "horizontal-line-drawing",
    value: "horizontal-line" /* HorizontalLine */
  },
  {
    label: "toolbarAnnotationsVerticalLine",
    icon: "vertical-line-drawing",
    value: "vertical-line" /* VerticalLine */
  },
  {
    label: "toolbarAnnotationsParallelChannel",
    icon: "parallel-channel-drawing",
    value: "parallel-channel" /* ParallelChannel */
  },
  {
    label: "toolbarAnnotationsDisjointChannel",
    icon: "disjoint-channel-drawing",
    value: "disjoint-channel" /* DisjointChannel */
  }
];
var TEXT_ANNOTATION_ITEMS = [
  { label: "toolbarAnnotationsText", icon: "text-annotation", value: "text" /* Text */ },
  { label: "toolbarAnnotationsComment", icon: "comment-annotation", value: "comment" /* Comment */ },
  { label: "toolbarAnnotationsCallout", icon: "callout-annotation", value: "callout" /* Callout */ },
  { label: "toolbarAnnotationsNote", icon: "note-annotation", value: "note" /* Note */ }
];
var SHAPE_ANNOTATION_ITEMS = [
  { label: "toolbarAnnotationsArrow", icon: "arrow-drawing", value: "arrow" /* Arrow */ },
  { label: "toolbarAnnotationsArrowUp", icon: "arrow-up-drawing", value: "arrow-up" /* ArrowUp */ },
  { label: "toolbarAnnotationsArrowDown", icon: "arrow-down-drawing", value: "arrow-down" /* ArrowDown */ }
];
var AxesButtons = class {
  constructor() {
    this.enabled = true;
    this.axes = "y";
  }
};
__decorateClass([
  Validate25(BOOLEAN6)
], AxesButtons.prototype, "enabled", 2);
__decorateClass([
  Validate25(AXIS_TYPE, { optional: true })
], AxesButtons.prototype, "axes", 2);
var Annotations = class extends _ModuleSupport60.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.axesButtons = new AxesButtons();
    this.annotationData = new PropertiesArray(
      this.createAnnotationDatum
    );
    this.defaults = new AnnotationDefaults();
    this.container = new _Scene25.Group({ name: "static-annotations" });
    this.annotations = new _Scene25.Selection(
      this.container,
      this.createAnnotationScene.bind(this)
    );
    this.colorPicker = new ColorPicker(this.ctx);
    this.textSizeMenu = new Menu(this.ctx, "text-size");
    this.lineStyleTypeMenu = new Menu(this.ctx, "annotations-line-style-type");
    this.lineStrokeWidthMenu = new Menu(this.ctx, "annotations-line-stroke-width");
    this.annotationMenu = new Menu(this.ctx, "annotations");
    this.settingsDialog = new AnnotationSettingsDialog(this.ctx);
    this.textInput = new TextInput(this.ctx);
    this.removeAmbientKeyboardListener = void 0;
    this.postUpdateFns = [];
    this.state = this.setupStateMachine();
    this.setupListeners();
    this.ctx.historyManager.addMementoOriginator(ctx.annotationManager);
    this.ctx.historyManager.addMementoOriginator(this.defaults);
  }
  setupStateMachine() {
    const { ctx } = this;
    return new AnnotationsStateMachine({
      resetToIdle: () => {
        ctx.cursorManager.updateCursor("annotations");
        ctx.interactionManager.popState(InteractionState2.Annotations);
        ctx.toolbarManager.toggleGroup("annotations", "annotationOptions", { visible: false });
        ctx.tooltipManager.unsuppressTooltip("annotations");
        this.hideOverlays();
        this.resetToolbarButtonStates();
        this.toggleAnnotationOptionsButtons();
        this.update();
      },
      hoverAtCoords: (coords, active) => {
        let hovered;
        this.annotations.each((annotation, _, index) => {
          const contains = annotation.containsPoint(coords.x, coords.y);
          if (contains)
            hovered ?? (hovered = index);
          annotation.toggleHovered(contains || active === index);
        });
        this.ctx.cursorManager.updateCursor(
          "annotations",
          hovered == null ? void 0 : this.annotations.at(hovered)?.getCursor()
        );
        return hovered;
      },
      copy: (index) => {
        const node = this.annotations.at(index);
        const datum = getTypedDatum(this.annotationData.at(index));
        if (!node || !datum) {
          return;
        }
        return this.createAnnotationDatumCopy({ node, datum });
      },
      paste: (datum) => {
        this.createAnnotation(datum.type, datum, false);
        this.postUpdateFns.push(() => {
          this.state.transitionAsync("selectLast");
          this.state.transitionAsync("copy");
        });
      },
      select: (index, previous) => {
        const {
          annotations,
          ctx: { toolbarManager, tooltipManager }
        } = this;
        this.hideOverlays();
        const selectedNode = index != null ? annotations.at(index) : null;
        const previousNode = previous != null ? annotations.at(previous) : null;
        if (previousNode === selectedNode && selectedNode != null) {
          return;
        }
        previousNode?.toggleActive(false);
        toolbarManager.toggleGroup("annotations", "annotationOptions", { visible: false });
        if (selectedNode) {
          selectedNode.toggleActive(true);
          tooltipManager.suppressTooltip("annotations");
          this.toggleAnnotationOptionsButtons();
          this.postUpdateFns.push(() => {
            toolbarManager.toggleGroup("annotations", "annotationOptions", { visible: true });
            toolbarManager.changeFloatingAnchor("annotationOptions", selectedNode.getAnchor());
          });
        } else {
          tooltipManager.unsuppressTooltip("annotations");
        }
        toolbarManager.updateButton("annotations", "line-menu", { icon: void 0 });
        toolbarManager.updateButton("annotations", "text-menu", { icon: void 0 });
        toolbarManager.updateButton("annotations", "shape-menu", { icon: void 0 });
        this.update();
      },
      selectLast: () => {
        return this.annotationData.length - 1;
      },
      startInteracting: () => {
        this.ctx.interactionManager.pushState(InteractionState2.Annotations);
      },
      stopInteracting: () => {
        this.ctx.interactionManager.popState(InteractionState2.Annotations);
      },
      create: (type, datum) => {
        this.createAnnotation(type, datum);
      },
      delete: (index) => {
        this.annotationData.splice(index, 1);
      },
      deleteAll: () => {
        this.annotationData.splice(0, this.annotationData.length);
      },
      validatePoint: (point) => {
        const context = this.getAnnotationContext();
        return context ? validateDatumPoint(context, point) : true;
      },
      getAnnotationType: (index) => {
        return stringToAnnotationType(this.annotationData[index].type);
      },
      datum: (index) => {
        return this.annotationData.at(index);
      },
      node: (index) => {
        return this.annotations.at(index);
      },
      recordAction: (label) => {
        this.recordActionAfterNextUpdate(label);
      },
      update: () => {
        this.postUpdateFns.push(() => {
          const active = this.state.getActive();
          const node = active != null ? this.annotations.at(active) : null;
          if (node == null)
            return;
          ctx.toolbarManager.changeFloatingAnchor("annotationOptions", node.getAnchor());
        });
        this.update();
      },
      showTextInput: (active) => {
        const datum = getTypedDatum(this.annotationData.at(active));
        const node = this.annotations.at(active);
        if (!node || !datum || !("getTextInputCoords" in datum))
          return;
        const styles = {
          color: datum.color,
          fontFamily: datum.fontFamily,
          fontSize: datum.fontSize,
          fontStyle: datum.fontStyle,
          fontWeight: datum.fontWeight,
          placeholderColor: datum.getPlaceholderColor()
        };
        const context = this.getAnnotationContext();
        const getTextInputCoords = () => Vec215.add(datum.getTextInputCoords(context), Vec215.required(this.seriesRect));
        this.textInput.show({
          styles,
          layout: {
            getTextInputCoords,
            position: datum.position,
            alignment: datum.alignment,
            textAlign: datum.textAlign,
            width: datum.width
          },
          text: datum.text,
          placeholderText: datum.placeholderText,
          onChange: (_text, bbox) => {
            this.state.transition("updateTextInputBBox", bbox);
          }
        });
      },
      hideTextInput: () => {
        this.textInput.hide();
      },
      updateTextInputColor: (color) => {
        this.textInput.updateColor(color);
      },
      updateTextInputFontSize: (fontSize) => {
        const bbox = this.textInput.updateFontSize(fontSize);
        this.state.transition("updateTextInputBBox", bbox);
      },
      updateTextInputBBox: (bbox) => {
        this.state.transition("updateTextInputBBox", bbox);
      },
      showAnnotationOptions: (active) => {
        const node = this.annotations.at(active);
        if (!node)
          return;
        this.toggleAnnotationOptionsButtons();
        ctx.toolbarManager.toggleGroup("annotations", "annotationOptions", { visible: true });
        ctx.toolbarManager.changeFloatingAnchor("annotationOptions", node.getAnchor());
      },
      showAnnotationSettings: (active, sourceEvent) => {
        const datum = this.annotationData.at(active);
        if (!isLineType(datum) && !isChannelType(datum))
          return;
        this.settingsDialog.showLineOrChannel(datum, {
          ariaLabel: this.ctx.localeManager.t("ariaLabelAnnotationSettingsDialog"),
          sourceEvent,
          onChangeLine: (props) => {
            this.state.transition("lineProps", props);
          },
          onChangeText: (props) => {
            this.state.transition("lineText", props);
            if (props.alignment)
              this.defaults.setDefaultLineTextAlignment(datum.type, props.alignment);
            if (props.position)
              this.defaults.setDefaultLineTextPosition(datum.type, props.position);
            this.recordActionAfterNextUpdate(
              `Change ${datum.type} text ${Object.entries(props).map(([key, value]) => `${key} to ${value}`).join(", ")}`
            );
          },
          onChangeLineColor: (colorOpacity, color, opacity) => {
            this.setColorAndDefault(datum.type, "line-color", colorOpacity, color, opacity);
            this.updateToolbarColorPickerFill("line-color", color, opacity);
          },
          onChangeHideLineColor: () => {
            this.recordActionAfterNextUpdate(
              `Change ${datum.type} line-color to ${datum.getDefaultColor("line-color")}`,
              ["annotations", "defaults"]
            );
            this.update();
          },
          onChangeLineStyleType: (lineStyleType) => {
            this.setLineStyleTypeAndDefault(datum.type, lineStyleType);
            this.updateToolbarLineStyleType(
              LINE_STYLE_TYPE_ITEMS.find((item) => item.value === lineStyleType) ?? LINE_STYLE_TYPE_ITEMS[0]
            );
          },
          onChangeLineStyleWidth: (strokeWidth) => {
            this.setLineStyleWidthAndDefault(datum.type, strokeWidth);
            this.updateToolbarStrokeWidth({ strokeWidth, value: strokeWidth, label: String(strokeWidth) });
          },
          onChangeTextColor: (colorOpacity, color, opacity) => {
            this.setColorAndDefault(datum.type, "text-color", colorOpacity, color, opacity);
            this.updateToolbarColorPickerFill("text-color", color, opacity);
          },
          onChangeHideTextColor: () => {
            this.recordActionAfterNextUpdate(
              `Change ${datum.type} text-color to ${datum.getDefaultColor("text-color")}`,
              ["annotations", "defaults"]
            );
            this.update();
          },
          onChangeTextFontSize: (fontSize) => {
            this.setFontSizeAndDefault(datum.type, fontSize);
          }
        });
      }
    });
  }
  setupListeners() {
    const { ctx } = this;
    const { All, Default: Default4, Annotations: AnnotationsState, ZoomDrag } = InteractionState2;
    const seriesRegion = ctx.regionManager.getRegion(REGIONS2.SERIES);
    const otherRegions = Object.values(REGIONS2).filter(
      (region) => ![
        REGIONS2.SERIES,
        // TODO: Navigator wrongly enchroaches on the top of the chart, even if it is disabled. We
        // have to ignore it to prevent it immediately calling `onCancel()` when the top-left
        // annotations toolbar button is clicked.
        REGIONS2.NAVIGATOR
      ].includes(region)
    ).map((region) => ctx.regionManager.getRegion(region));
    this.destroyFns.push(
      // Interactions
      seriesRegion.addListener("hover", this.onHover.bind(this), All),
      seriesRegion.addListener("click", this.onClick.bind(this), All),
      seriesRegion.addListener("dblclick", this.onDoubleClick.bind(this), All),
      seriesRegion.addListener("drag-start", this.onDragStart.bind(this), Default4 | ZoomDrag | AnnotationsState),
      seriesRegion.addListener("drag", this.onDrag.bind(this), Default4 | ZoomDrag | AnnotationsState),
      seriesRegion.addListener("drag-end", this.onDragEnd.bind(this), All),
      ctx.keyNavManager.addListener("cancel", this.onCancel.bind(this), Default4 | AnnotationsState),
      ctx.keyNavManager.addListener("delete", this.onDelete.bind(this), Default4 | AnnotationsState),
      ctx.interactionManager.addListener("keydown", this.onKeyDown.bind(this), AnnotationsState),
      ctx.interactionManager.addListener("keydown", this.onCopyPaste.bind(this), All),
      ...otherRegions.map((region) => region.addListener("click", this.onCancel.bind(this), All)),
      // Services
      ctx.annotationManager.addListener("restore-annotations", this.onRestoreAnnotations.bind(this)),
      ctx.toolbarManager.addListener("button-pressed", this.onToolbarButtonPress.bind(this)),
      ctx.toolbarManager.addListener("button-moved", this.onToolbarButtonMoved.bind(this)),
      ctx.toolbarManager.addListener("group-moved", this.onToolbarGroupMoved.bind(this)),
      ctx.toolbarManager.addListener("cancelled", this.onToolbarCancelled.bind(this)),
      ctx.layoutManager.addListener("layout:complete", this.onLayoutComplete.bind(this)),
      ctx.updateService.addListener("pre-scene-render", this.onPreRender.bind(this)),
      // DOM
      ctx.annotationManager.attachNode(this.container),
      () => this.colorPicker.destroy(),
      () => ctx.domManager.removeStyles(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS)
    );
  }
  destroy() {
    super.destroy();
    this.removeAmbientKeyboardListener?.();
    this.removeAmbientKeyboardListener = void 0;
  }
  createAnnotationScene(datum) {
    return new annotationConfigs[datum.type].scene();
  }
  createAnnotationDatum(params) {
    if (params.type in annotationConfigs) {
      return new annotationConfigs[params.type].datum().set(params);
    }
    throw new Error(
      `AG Charts - Cannot set property of unknown type [${params.type}], expected one of [${Object.keys(annotationConfigs)}], ignoring.`
    );
  }
  createAnnotationDatumCopy({
    node,
    datum
  }) {
    const { type } = datum;
    if (!(type in annotationConfigs)) {
      throw new Error(
        `AG Charts - Cannot set property of unknown type [${type}], expected one of [${Object.keys(annotationConfigs)}], ignoring.`
      );
    }
    const config = annotationConfigs[type];
    const newDatum = new config.datum();
    newDatum.set(datum.toJson());
    const context = this.getAnnotationContext();
    if (!context) {
      return;
    }
    return config.copy(node, datum, newDatum, context);
  }
  createAnnotation(type, datum, applyDefaults = true) {
    this.annotationData.push(datum);
    if (applyDefaults) {
      const styles = this.ctx.annotationManager.getAnnotationTypeStyles(type);
      if (styles)
        datum.set(styles);
      this.defaults.applyDefaults(datum);
    }
    if ("setLocaleManager" in datum)
      datum.setLocaleManager(this.ctx.localeManager);
    this.resetToolbarButtonStates();
    this.removeAmbientKeyboardListener?.();
    this.removeAmbientKeyboardListener = void 0;
    this.update();
  }
  onRestoreAnnotations(event) {
    if (!this.enabled)
      return;
    this.clear();
    this.annotationData.set(event.annotations);
    this.update();
  }
  onToolbarButtonPress(event) {
    if (ToolbarManager.isGroup("annotationOptions", event)) {
      this.onToolbarAnnotationOptionButtonPress(event);
      return;
    }
    if (!ToolbarManager.isGroup("annotations", event)) {
      this.reset();
      return;
    }
    if (event.value === "clear") {
      this.clear();
      this.recordActionAfterNextUpdate("Clear all annotations");
      return;
    }
    if (event.value === "line-menu") {
      this.onToolbarButtonPressMenu(event, "toolbarAnnotationsLineAnnotations", LINE_ANNOTATION_ITEMS);
      return;
    }
    if (event.value === "text-menu") {
      this.onToolbarButtonPressMenu(event, "toolbarAnnotationsTextAnnotations", TEXT_ANNOTATION_ITEMS);
      return;
    }
    if (event.value === "shape-menu") {
      this.onToolbarButtonPressMenu(event, "toolbarAnnotationsShapeAnnotations", SHAPE_ANNOTATION_ITEMS);
      return;
    }
    this.onToolbarButtonPressAnnotation(event);
  }
  onToolbarAnnotationOptionButtonPress(event) {
    if (!ToolbarManager.isGroup("annotationOptions", event))
      return;
    const { annotationData, state } = this;
    const active = state.getActive();
    if (active == null)
      return;
    this.hideOverlays();
    const datum = getTypedDatum(annotationData[active]);
    const node = this.annotations.at(active);
    switch (event.value) {
      case "line-style-type" /* LineStyleType */: {
        const lineStyle = hasLineStyle(datum) ? getLineStyle(datum.lineDash, datum.lineStyle) : void 0;
        this.lineStyleTypeMenu.show({
          items: LINE_STYLE_TYPE_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsLineStyle"),
          value: lineStyle,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onLineStyleTypeMenuPress(item, datum),
          class: "annotations__line-style-type"
        });
        break;
      }
      case "line-stroke-width" /* LineStrokeWidth */: {
        const strokeWidth = hasLineStyle(datum) ? datum.strokeWidth : void 0;
        this.lineStrokeWidthMenu.show({
          items: LINE_STROKE_WIDTH_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsLineStrokeWidth"),
          value: strokeWidth,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onLineStrokeWidthMenuPress(item, datum),
          class: "annotations__line-stroke-width"
        });
        break;
      }
      case "line-color" /* LineColor */:
      case "fill-color" /* FillColor */:
      case "text-color" /* TextColor */: {
        this.colorPicker.show({
          color: datum?.getDefaultColor(event.value),
          opacity: datum?.getDefaultOpacity(event.value),
          sourceEvent: event.sourceEvent,
          onChange: datum != null ? this.onColorPickerChange.bind(this, event.value, datum) : void 0,
          onChangeHide: ((type) => {
            this.recordActionAfterNextUpdate(
              `Change ${node?.type} ${event.value} to ${datum?.getDefaultColor(type)}`,
              ["annotations", "defaults"]
            );
          }).bind(this, event.value)
        });
        break;
      }
      case "text-size" /* TextSize */: {
        const fontSize = isTextType(datum) ? datum.fontSize : void 0;
        this.textSizeMenu.show({
          items: TEXT_SIZE_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsTextSize"),
          value: fontSize,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onTextSizeMenuPress(item, datum),
          class: "ag-charts-annotations-text-size-menu"
        });
        break;
      }
      case "delete" /* Delete */: {
        this.cancel();
        this.delete();
        this.reset();
        break;
      }
      case "lock" /* Lock */: {
        annotationData[active].locked = !annotationData[active].locked;
        this.toggleAnnotationOptionsButtons();
        break;
      }
      case "settings" /* Settings */: {
        state.transition("toolbarPressSettings", event.sourceEvent);
        break;
      }
    }
    this.update();
  }
  onToolbarButtonPressMenu(event, ariaLabel, items) {
    const { x, y, width } = event.rect;
    this.cancel();
    this.reset();
    this.annotationMenu.setAnchor({ x: x + width + 6, y });
    this.annotationMenu.show({
      items,
      ariaLabel: this.ctx.localeManager.t(ariaLabel),
      sourceEvent: event.sourceEvent,
      onPress: this.onAnnotationsMenuPress.bind(this, event)
    });
  }
  onToolbarButtonPressAnnotation(event) {
    this.ctx.tooltipManager.suppressTooltip("annotations");
    const annotation = stringToAnnotationType(event.value);
    if (annotation) {
      this.beginAnnotationPlacement(annotation);
    } else {
      _Util47.Logger.errorOnce(`Can not create unknown annotation type [${event.value}], ignoring.`);
      this.update();
    }
  }
  onToolbarButtonMoved(event) {
    const { group, rect, groupRect, value } = event;
    if (group !== "annotationOptions")
      return;
    const anchor = { x: rect.x, y: rect.y + rect.height - 1 };
    switch (value) {
      case "fill-color" /* FillColor */:
      case "line-color" /* LineColor */:
      case "text-color" /* TextColor */: {
        const colorPickerAnchor = Vec215.add(groupRect, Vec215.from(0, groupRect.height + 4));
        const fallback = { y: groupRect.y - 4 };
        this.colorPicker.setAnchor(colorPickerAnchor, fallback);
        break;
      }
      case "line-stroke-width" /* LineStrokeWidth */: {
        this.lineStrokeWidthMenu.setAnchor(anchor);
        break;
      }
      case "line-style-type" /* LineStyleType */: {
        this.lineStyleTypeMenu.setAnchor(anchor);
        break;
      }
      case "text-size" /* TextSize */: {
        this.textSizeMenu.setAnchor(anchor);
        break;
      }
      default:
        break;
    }
  }
  onToolbarGroupMoved(_event) {
    this.hideOverlays();
  }
  onColorPickerChange(colorPickerType, datum, colorOpacity, color, opacity) {
    this.setColorAndDefault(datum.type, colorPickerType, colorOpacity, color, opacity);
    this.updateToolbarColorPickerFill(colorPickerType, colorOpacity);
  }
  updateToolbarColorPickerFill(colorPickerType, color, opacity) {
    if (color != null && opacity != null) {
      const { r, g, b } = _Util47.Color.fromString(color);
      color = _Util47.Color.fromArray([r, g, b, opacity]).toHexString();
    }
    this.ctx.toolbarManager.updateButton("annotationOptions", colorPickerType, {
      fill: color
    });
  }
  updateToolbarFills() {
    const active = this.state.getActive();
    const annotation = active != null ? this.annotationData[active] : void 0;
    const datum = getTypedDatum(annotation);
    this.updateToolbarColorPickerFill(
      "line-color" /* LineColor */,
      datum?.getDefaultColor("line-color" /* LineColor */),
      datum?.getDefaultOpacity("line-color" /* LineColor */)
    );
    this.updateToolbarColorPickerFill(
      "fill-color" /* FillColor */,
      datum?.getDefaultColor("fill-color" /* FillColor */),
      datum?.getDefaultOpacity("fill-color" /* FillColor */)
    );
    this.updateToolbarColorPickerFill(
      "text-color" /* TextColor */,
      datum?.getDefaultColor("text-color" /* TextColor */),
      datum?.getDefaultOpacity("text-color" /* TextColor */)
    );
  }
  updateToolbarFontSize(fontSize) {
    this.ctx.toolbarManager.updateButton("annotationOptions", "text-size" /* TextSize */, {
      label: fontSize != null ? String(fontSize) : void 0
    });
  }
  updateToolbarLineStyleType(item) {
    this.ctx.toolbarManager.updateButton("annotationOptions", "line-style-type" /* LineStyleType */, {
      icon: item.icon
    });
  }
  updateToolbarStrokeWidth(item) {
    this.ctx.toolbarManager.updateButton("annotationOptions", "line-stroke-width" /* LineStrokeWidth */, {
      label: item.label,
      strokeWidth: item.value
    });
  }
  onTextSizeMenuPress(item, datum) {
    if (!hasFontSize(datum))
      return;
    const fontSize = item.value;
    this.setFontSizeAndDefault(datum.type, fontSize);
    this.textSizeMenu.hide();
    this.updateToolbarFontSize(fontSize);
  }
  onLineStyleTypeMenuPress(item, datum) {
    if (!hasLineStyle(datum))
      return;
    const type = item.value;
    this.setLineStyleTypeAndDefault(datum.type, type);
    this.lineStyleTypeMenu.hide();
    this.updateToolbarLineStyleType(item);
  }
  onLineStrokeWidthMenuPress(item, datum) {
    if (!hasLineStyle(datum)) {
      return;
    }
    const strokeWidth = item.value;
    this.setLineStyleWidthAndDefault(datum.type, strokeWidth);
    this.lineStrokeWidthMenu.hide();
    this.updateToolbarStrokeWidth(item);
  }
  onAnnotationsMenuPress(event, item) {
    const { toolbarManager } = this.ctx;
    toolbarManager.toggleButton("annotations", event.id, {
      active: true
    });
    toolbarManager.updateButton("annotations", event.id, {
      icon: item.icon
    });
    this.beginAnnotationPlacement(item.value);
    this.annotationMenu.hide();
    this.removeAmbientKeyboardListener?.();
    this.removeAmbientKeyboardListener = this.ctx.interactionManager.addListener(
      "keydown",
      (e) => this.handleAmbientKeyboardEvent(e),
      InteractionState2.All
    );
  }
  handleAmbientKeyboardEvent(e) {
    if (e.sourceEvent.key !== "Escape")
      return;
    this.cancelPlacementInteraction();
    e.preventDefault();
    e.sourceEvent.stopPropagation();
    this.removeAmbientKeyboardListener?.();
    this.removeAmbientKeyboardListener = void 0;
  }
  onToolbarCancelled(event) {
    if (event.group === "annotations") {
      this.cancelPlacementInteraction();
    }
  }
  cancelPlacementInteraction() {
    this.cancel();
    this.resetToolbarButtonStates();
    this.reset();
    this.update();
  }
  onLayoutComplete(event) {
    const seriesRect = event.series.paddedRect;
    this.seriesRect = seriesRect;
    for (const axisLayout of event.axes ?? []) {
      if (axisLayout.direction === _ModuleSupport60.ChartAxisDirection.X) {
        this.xAxis = this.getAxis(axisLayout, seriesRect, this.xAxis?.button);
      } else {
        this.yAxis = this.getAxis(axisLayout, seriesRect, this.yAxis?.button);
      }
    }
  }
  onPreRender() {
    this.updateAnnotations();
    this.state.transition("render");
  }
  getAxis(axisLayout, seriesRect, button) {
    const axisCtx = this.ctx.axisManager.getAxisContext(axisLayout.direction)[0];
    const { position: axisPosition = "bottom", direction } = axisCtx;
    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;
    const bounds = buildBounds(new _Scene25.BBox(0, 0, seriesRect.width, seriesRect.height), axisPosition, padding);
    const lineDirection = axisCtx.direction === ChartAxisDirection10.X ? "vertical" : "horizontal";
    const { axesButtons } = this;
    const buttonEnabled = this.enabled && axesButtons.enabled && (axesButtons.axes === "xy" || axesButtons.axes === direction);
    if (buttonEnabled) {
      button ?? (button = new AxisButton(
        this.ctx,
        axisCtx,
        (coords) => this.onAxisButtonClick(coords, lineDirection),
        seriesRect
      ));
      const axisLabelPadding = calculateAxisLabelPadding(axisLayout);
      button.update(seriesRect, axisLabelPadding);
    } else {
      button?.destroy();
      button = void 0;
    }
    return { layout: axisLayout, context: axisCtx, bounds, button };
  }
  recordActionAfterNextUpdate(label, types = ["annotations"]) {
    const {
      defaults,
      ctx: { annotationManager, historyManager }
    } = this;
    const originators = types.map((type) => type === "defaults" ? defaults : annotationManager);
    this.postUpdateFns.push(() => {
      historyManager.record(label, ...originators);
    });
  }
  setColorAndDefault(datumType, colorPickerType, colorOpacity, color, opacity) {
    this.state.transition("color", { colorPickerType, colorOpacity, color, opacity });
    this.defaults.setDefaultColor(datumType, colorPickerType, colorOpacity, color, opacity);
  }
  setFontSizeAndDefault(datumType, fontSize) {
    this.state.transition("fontSize", fontSize);
    this.defaults.setDefaultFontSize(datumType, fontSize);
    this.recordActionAfterNextUpdate(`Change ${datumType} font size to ${fontSize}`, ["annotations", "defaults"]);
  }
  setLineStyleTypeAndDefault(datumType, styleType) {
    this.state.transition("lineStyle", { type: styleType });
    this.defaults.setDefaultLineStyleType(datumType, styleType);
    this.recordActionAfterNextUpdate(`Change ${datumType} line style to ${styleType}`, ["annotations", "defaults"]);
  }
  setLineStyleWidthAndDefault(datumType, strokeWidth) {
    this.state.transition("lineStyle", { strokeWidth });
    this.defaults.setDefaultLineStyleWidth(datumType, strokeWidth);
    this.recordActionAfterNextUpdate(`Change ${datumType} stroke width to ${strokeWidth}`, [
      "annotations",
      "defaults"
    ]);
  }
  updateAnnotations() {
    const {
      annotationData,
      annotations,
      seriesRect,
      ctx: { annotationManager, toolbarManager }
    } = this;
    const context = this.getAnnotationContext();
    if (!seriesRect || !context) {
      return;
    }
    annotationManager.updateData(annotationData.toJson());
    const clearAllEnabled = annotationData.length > 0;
    toolbarManager.toggleButton("annotations", "clear", { enabled: clearAllEnabled });
    annotations.update(annotationData ?? [], void 0, (datum) => datum.id).each((node, datum) => {
      if (!this.validateDatum(datum)) {
        node.visible = false;
        return;
      }
      updateAnnotation(node, datum, context);
    });
    this.postUpdateFns.forEach((fn) => fn());
    this.postUpdateFns = [];
  }
  // Validation of the options beyond the scope of the @Validate decorator
  validateDatum(datum) {
    const context = this.getAnnotationContext();
    return context ? datum.isValidWithContext(context, `Annotation [${datum.type}] `) : true;
  }
  getAnnotationContext() {
    const { seriesRect, xAxis, yAxis } = this;
    if (!(seriesRect && xAxis && yAxis)) {
      return;
    }
    return {
      seriesRect,
      xAxis: {
        ...xAxis.context,
        bounds: xAxis.bounds,
        labelPadding: calculateAxisLabelPadding(xAxis.layout)
      },
      yAxis: {
        ...yAxis.context,
        bounds: yAxis.bounds,
        labelPadding: calculateAxisLabelPadding(xAxis.layout)
      }
    };
  }
  onHover(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec215.from(event);
    const point = invertCoords(offset, context);
    state.transition("hover", { offset, point });
  }
  onClick(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec215.from(event);
    const point = invertCoords(offset, context);
    const textInputValue = this.textInput.getValue();
    state.transition("click", { offset, point, textInputValue });
  }
  onDoubleClick() {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    state.transition("dblclick");
  }
  onAxisButtonClick(coords, direction) {
    this.cancel();
    this.reset();
    const context = this.getAnnotationContext();
    if (!this.annotationData || !context)
      return;
    const {
      state,
      ctx: { toolbarManager, interactionManager }
    } = this;
    interactionManager.pushState(InteractionState2.Annotations);
    const isHorizontal = direction === "horizontal";
    state.transition(isHorizontal ? "horizontal-line" /* HorizontalLine */ : "vertical-line" /* VerticalLine */);
    toolbarManager.toggleGroup("annotations", "annotationOptions", { visible: false });
    if (!coords) {
      return;
    }
    const point = invertCoords(coords, context);
    if (!validateDatumPoint(context, point)) {
      return;
    }
    state.transition("click", { point });
    this.update();
  }
  onDragStart(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec215.from(event);
    state.transition("dragStart", { context, offset });
  }
  onDrag(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec215.from(event);
    const point = invertCoords(offset, context);
    state.transition("drag", { context, offset, point });
  }
  onDragEnd() {
    this.state.transition("dragEnd");
  }
  onCancel() {
    this.cancel();
    this.reset();
  }
  onDelete() {
    this.cancel();
    this.delete();
    this.reset();
    this.update();
  }
  onKeyDown(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const { key, shiftKey } = event.sourceEvent;
    const textInputValue = this.textInput.getValue();
    state.transition("keyDown", { key, shiftKey, textInputValue });
  }
  onCopyPaste(event) {
    const { sourceEvent } = event;
    const modifierKey = sourceEvent.ctrlKey || sourceEvent.metaKey;
    if (modifierKey && sourceEvent.key === "c") {
      this.state.transition("copy");
    } else if (modifierKey && sourceEvent.key === "x") {
      this.state.transition("cut");
      this.recordActionAfterNextUpdate("Cut annotation");
    } else if (modifierKey && sourceEvent.key === "v") {
      this.state.transition("paste");
      this.recordActionAfterNextUpdate("Paste annotation");
    }
  }
  beginAnnotationPlacement(annotation) {
    this.cancel();
    this.ctx.interactionManager.pushState(InteractionState2.Annotations);
    this.state.transition(annotation);
    this.update();
  }
  toggleAnnotationOptionsButtons() {
    const {
      annotationData,
      state,
      ctx: { toolbarManager }
    } = this;
    const active = state.getActive();
    if (active == null)
      return;
    const datum = getTypedDatum(annotationData.at(active));
    const locked = datum?.locked ?? false;
    toolbarManager.toggleButton("annotationOptions", "line-style-type" /* LineStyleType */, {
      enabled: !locked,
      visible: hasLineStyle(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "line-stroke-width" /* LineStrokeWidth */, {
      enabled: !locked,
      visible: hasLineStyle(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "line-color" /* LineColor */, {
      enabled: !locked,
      visible: hasLineColor(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "text-color" /* TextColor */, {
      enabled: !locked,
      visible: hasTextColor(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "fill-color" /* FillColor */, {
      enabled: !locked,
      visible: hasFillColor(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "text-size" /* TextSize */, {
      enabled: !locked,
      visible: hasFontSize(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "settings" /* Settings */, {
      enabled: !locked,
      visible: hasLineText(datum)
    });
    toolbarManager.toggleButton("annotationOptions", "delete" /* Delete */, { enabled: !locked });
    toolbarManager.toggleButton("annotationOptions", "lock" /* Lock */, { checked: locked });
    toolbarManager.updateGroup("annotationOptions");
    this.updateToolbarFontSize(datum != null && "fontSize" in datum ? datum.fontSize : void 0);
    this.updateToolbarFills();
    this.updateToolbarLineStyles(datum);
  }
  updateToolbarLineStyles(datum) {
    if (!hasLineStyle(datum)) {
      return;
    }
    const strokeWidth = datum.strokeWidth ?? 1;
    const lineStyleType = getLineStyle(datum.lineDash, datum.lineStyle);
    this.updateToolbarStrokeWidth({
      strokeWidth,
      value: strokeWidth,
      label: String(strokeWidth)
    });
    this.updateToolbarLineStyleType(
      LINE_STYLE_TYPE_ITEMS.find((item) => item.value === lineStyleType) ?? LINE_STYLE_TYPE_ITEMS[0]
    );
  }
  clear() {
    this.cancel();
    this.deleteAll();
    this.reset();
  }
  reset() {
    this.state.transition("reset");
  }
  cancel() {
    this.state.transition("cancel");
  }
  delete() {
    this.state.transition("delete");
  }
  deleteAll() {
    this.state.transition("deleteAll");
  }
  hideOverlays() {
    this.colorPicker.hide({ lastFocus: null });
    this.textSizeMenu.hide();
    this.lineStyleTypeMenu.hide();
    this.lineStrokeWidthMenu.hide();
    this.annotationMenu.hide();
    this.settingsDialog.hide();
  }
  resetToolbarButtonStates() {
    const {
      ctx: { toolbarManager }
    } = this;
    for (const annotationType of ANNOTATION_BUTTONS) {
      toolbarManager.toggleButton("annotations", annotationType, { active: false });
    }
    for (const annotationGroup of ANNOTATION_BUTTON_GROUPS) {
      toolbarManager.toggleButton("annotations", annotationGroup, { active: false });
    }
  }
  update(status = ChartUpdateType.PRE_SCENE_RENDER) {
    this.ctx.updateService.update(status, { skipAnimations: true });
  }
};
__decorateClass([
  ObserveChanges2((target, newValue, oldValue) => {
    const {
      ctx: { annotationManager, stateManager, toolbarManager }
    } = target;
    if (newValue === oldValue)
      return;
    toolbarManager.toggleGroup("annotations", "annotations", { visible: Boolean(newValue) });
    if (oldValue === false && newValue === true) {
      stateManager.restoreState(annotationManager);
    } else if (newValue === false) {
      target.clear();
    }
  }),
  Validate25(BOOLEAN6)
], Annotations.prototype, "enabled", 2);

// packages/ag-charts-enterprise/src/features/annotations/annotationsModule.ts
var stroke = {
  stroke: _Theme.DEFAULT_ANNOTATION_COLOR,
  strokeOpacity: 1,
  strokeWidth: 2
};
var handle = {
  fill: _Theme.DEFAULT_ANNOTATION_HANDLE_FILL,
  strokeOpacity: 1,
  strokeWidth: 2
};
var font = {
  color: _Theme.DEFAULT_TEXT_ANNOTATION_COLOR,
  fontSize: 14,
  fontFamily: _Theme.DEFAULT_FONT_FAMILY
};
var axisLabel = {
  ...font,
  enabled: true,
  color: "white",
  fill: _Theme.DEFAULT_ANNOTATION_COLOR,
  fontSize: 12
};
var text = {
  ...font,
  color: _Theme.DEFAULT_TEXT_ANNOTATION_COLOR,
  textAlign: "left"
};
var lineText = {
  ...font,
  position: "top",
  alignment: "center",
  color: _Theme.DEFAULT_ANNOTATION_COLOR
};
var AnnotationsModule = {
  type: "root",
  optionsKey: "annotations",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  dependencies: ["toolbar"],
  moduleFactory: (ctx) => new Annotations(ctx),
  themeTemplate: {
    annotations: {
      // Lines
      line: {
        ...stroke,
        handle: { ...handle },
        text: { ...lineText }
      },
      "horizontal-line": {
        ...stroke,
        handle: { ...handle },
        axisLabel: { ...axisLabel },
        text: { ...lineText }
      },
      "vertical-line": {
        ...stroke,
        handle: { ...handle },
        axisLabel: { ...axisLabel },
        text: { ...lineText }
      },
      // Channels
      "disjoint-channel": {
        ...stroke,
        background: {
          fill: _Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,
          fillOpacity: 0.2
        },
        handle: { ...handle },
        text: { ...lineText }
      },
      "parallel-channel": {
        ...stroke,
        middle: {
          lineDash: [6, 5],
          strokeWidth: 1
        },
        background: {
          fill: _Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,
          fillOpacity: 0.2
        },
        handle: { ...handle },
        text: { ...lineText }
      },
      // Texts
      callout: {
        ...stroke,
        ...text,
        color: _Theme.DEFAULT_LABEL_COLOUR,
        handle: { ...handle },
        fill: _Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,
        fillOpacity: 0.2
      },
      comment: {
        ...text,
        color: "white",
        fontWeight: 700,
        handle: { ...handle },
        fill: _Theme.DEFAULT_ANNOTATION_COLOR
      },
      note: {
        ...text,
        color: _Theme.DEFAULT_TEXTBOX_COLOR,
        fill: _Theme.DEFAULT_ANNOTATION_COLOR,
        stroke: _Theme.DEFAULT_ANNOTATION_HANDLE_FILL,
        strokeWidth: 1,
        strokeOpacity: 1,
        handle: { ...handle },
        background: {
          fill: _Theme.DEFAULT_TEXTBOX_FILL,
          stroke: _Theme.DEFAULT_TEXTBOX_STROKE,
          strokeWidth: 1
        }
      },
      text: {
        ...text,
        handle: { ...handle }
      },
      // Shapes
      arrow: {
        ...stroke,
        handle: { ...handle },
        text: { ...lineText }
      },
      "arrow-up": {
        fill: _Theme.PALETTE_UP_FILL,
        handle: { ...handle, stroke: _Theme.DEFAULT_ANNOTATION_COLOR }
      },
      "arrow-down": {
        fill: _Theme.PALETTE_DOWN_FILL,
        handle: { ...handle, stroke: _Theme.DEFAULT_ANNOTATION_COLOR }
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/background/background.ts
import { _ModuleSupport as _ModuleSupport62 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/image/image.ts
import { _ModuleSupport as _ModuleSupport61, _Scene as _Scene26 } from "ag-charts-community";
var {
  BaseProperties: BaseProperties11,
  ObserveChanges: ObserveChanges3,
  ProxyProperty,
  Validate: Validate26,
  NUMBER: NUMBER6,
  POSITIVE_NUMBER: POSITIVE_NUMBER5,
  RATIO: RATIO5,
  createElement: createElement6,
  calculatePlacement
} = _ModuleSupport61;
var Image = class extends BaseProperties11 {
  constructor() {
    super();
    this.opacity = 1;
    this.loadedSynchronously = true;
    this.containerWidth = 0;
    this.containerHeight = 0;
    this.onLoad = void 0;
    this.onImageLoad = () => {
      if (this.loadedSynchronously) {
        return;
      }
      this.node.visible = false;
      this.performLayout(this.containerWidth, this.containerHeight);
      this.onLoad?.();
    };
    this.imageElement = createElement6("img");
    this.imageElement.onload = this.onImageLoad;
    this.node = new _Scene26.Image(this.imageElement);
  }
  get complete() {
    return this.imageElement.width > 0 && this.imageElement.height > 0;
  }
  performLayout(containerWidth, containerHeight) {
    this.containerWidth = containerWidth;
    this.containerHeight = containerHeight;
    const container = { x: 0, y: 0, width: containerWidth, height: containerHeight };
    const placement = calculatePlacement(this.imageElement.width, this.imageElement.height, container, this);
    this.node.setProperties(
      this.complete ? {
        visible: true,
        opacity: this.opacity,
        ...placement
      } : { visible: false }
    );
    return placement;
  }
};
__decorateClass([
  Validate26(NUMBER6, { optional: true })
], Image.prototype, "top", 2);
__decorateClass([
  Validate26(NUMBER6, { optional: true })
], Image.prototype, "right", 2);
__decorateClass([
  Validate26(NUMBER6, { optional: true })
], Image.prototype, "bottom", 2);
__decorateClass([
  Validate26(NUMBER6, { optional: true })
], Image.prototype, "left", 2);
__decorateClass([
  Validate26(POSITIVE_NUMBER5, { optional: true })
], Image.prototype, "width", 2);
__decorateClass([
  Validate26(POSITIVE_NUMBER5, { optional: true })
], Image.prototype, "height", 2);
__decorateClass([
  Validate26(RATIO5)
], Image.prototype, "opacity", 2);
__decorateClass([
  ProxyProperty("imageElement.src"),
  ObserveChanges3((target) => target.loadedSynchronously = target.complete)
], Image.prototype, "url", 2);

// packages/ag-charts-enterprise/src/features/background/background.ts
var { ActionOnSet, OBJECT: OBJECT10, Validate: Validate27 } = _ModuleSupport62;
var Background2 = class extends _ModuleSupport62.Background {
  constructor(ctx) {
    super(ctx);
    this.ctx = ctx;
    this.image = new Image();
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    if (this.image) {
      const { width, height } = event.chart;
      this.image.performLayout(width, height);
    }
  }
  onImageLoad() {
    this.ctx.updateService.update(_ModuleSupport62.ChartUpdateType.SCENE_RENDER);
  }
};
__decorateClass([
  Validate27(OBJECT10, { optional: true }),
  ActionOnSet({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Background2.prototype, "image", 2);

// packages/ag-charts-enterprise/src/features/background/backgroundModule.ts
var BackgroundModule = {
  type: "root",
  optionsKey: "background",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "gauge"],
  moduleFactory: (ctx) => new Background2(ctx)
};

// packages/ag-charts-enterprise/src/features/chart-toolbar/chartToolbarModule.ts
import "ag-charts-community";

// packages/ag-charts-enterprise/src/features/chart-toolbar/chartToolbar.ts
import { _ModuleSupport as _ModuleSupport63 } from "ag-charts-community";
var { ActionOnSet: ActionOnSet2, Validate: Validate28, BOOLEAN: BOOLEAN7 } = _ModuleSupport63;
var menuItems = [
  { label: "toolbarSeriesTypeOHLC", icon: "ohlc-series", value: "ohlc" },
  { label: "toolbarSeriesTypeCandles", icon: "candlestick-series", value: "candlestick" },
  { label: "toolbarSeriesTypeHollowCandles", icon: "hollow-candlestick-series", value: "hollow-candlestick" },
  { label: "toolbarSeriesTypeLine", icon: "line-series", value: "line" },
  { label: "toolbarSeriesTypeStepLine", icon: "step-line-series", value: "step-line" },
  { label: "toolbarSeriesTypeHLC", icon: "hlc-series", value: "hlc" },
  { label: "toolbarSeriesTypeHighLow", icon: "high-low-series", value: "high-low" }
];
var BUTTON_GROUP = "seriesType";
var BUTTON_VALUE = "type";
var ChartToolbar = class extends _ModuleSupport63.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.menu = new Menu(this.ctx, "chart-toolbar");
    this.destroyFns.push(
      ctx.layoutManager.addListener("layout:complete", this.onLayoutComplete.bind(this)),
      ctx.toolbarManager.addListener("button-moved", this.onToolbarButtonMoved.bind(this)),
      ctx.toolbarManager.addListener("button-pressed", this.onToolbarButtonPressed.bind(this))
    );
  }
  onEnableChanged(enabled) {
    this.ctx.toolbarManager.toggleGroup("chart-toolbar", BUTTON_GROUP, { visible: enabled });
  }
  onLayoutComplete() {
    if (!this.enabled)
      return;
    const chartType = this.getChartType();
    const icon = menuItems.find((item) => item.value === chartType)?.icon;
    if (icon != null) {
      this.ctx.toolbarManager.updateButton(BUTTON_GROUP, BUTTON_VALUE, { icon });
    }
  }
  setAnchor(anchor) {
    this.menu.setAnchor({ x: anchor.x + anchor.width + 6, y: anchor.y });
  }
  onToolbarButtonMoved(e) {
    if (e.group !== BUTTON_GROUP)
      return;
    this.setAnchor(e.rect);
  }
  onToolbarButtonPressed(e) {
    if (e.group !== BUTTON_GROUP)
      return;
    this.setAnchor(e.rect);
    this.menu.show({
      items: menuItems,
      menuItemRole: "menuitemradio",
      ariaLabel: this.ctx.localeManager.t("toolbarSeriesTypeDropdown"),
      value: this.getChartType(),
      sourceEvent: e.sourceEvent,
      onPress: (item) => {
        this.setChartType(item.value);
        this.hidePopover();
      },
      onHide: () => {
        this.ctx.toolbarManager.toggleButton(BUTTON_GROUP, BUTTON_VALUE, { active: false });
      }
    });
    this.ctx.toolbarManager.toggleButton(BUTTON_GROUP, BUTTON_VALUE, { active: true });
  }
  hidePopover() {
    this.ctx.toolbarManager.toggleButton(BUTTON_GROUP, BUTTON_VALUE, { active: false });
    this.menu.hide();
  }
  setChartType(chartType) {
    const options = { chartType };
    void this.ctx.chartService.publicApi?.updateDelta(options);
  }
  getChartType() {
    const chartType = this.ctx.chartService.publicApi?.getOptions()?.chartType;
    if (chartType == null || !menuItems.some((item) => item.value === chartType)) {
      return "candlestick";
    }
    return chartType;
  }
};
__decorateClass([
  Validate28(BOOLEAN7),
  ActionOnSet2({
    changeValue: function(enabled) {
      this.onEnableChanged(enabled);
    }
  })
], ChartToolbar.prototype, "enabled", 2);

// packages/ag-charts-enterprise/src/features/chart-toolbar/chartToolbarModule.ts
var ChartToolbarModule = {
  type: "root",
  optionsKey: "chartToolbar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new ChartToolbar(ctx)
};

// packages/ag-charts-enterprise/src/features/context-menu/contextMenuModule.ts
import { _Theme as _Theme3 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/context-menu/contextMenu.ts
import { _ModuleSupport as _ModuleSupport64, _Util as _Util48 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/context-menu/contextMenuStyles.ts
var DEFAULT_CONTEXT_MENU_CLASS = "ag-chart-context-menu";
var DEFAULT_CONTEXT_MENU_DARK_CLASS = "ag-charts-dark-context-menu";

// packages/ag-charts-enterprise/src/features/context-menu/contextMenu.ts
var { BOOLEAN: BOOLEAN8, Validate: Validate29, createElement: createElement7, initMenuKeyNav: initMenuKeyNav2, makeAccessibleClickListener, ContextMenuRegistry } = _ModuleSupport64;
var { Logger: Logger2 } = _Util48;
var moduleId2 = "context-menu";
function getChildrenOfType(parent, ctor) {
  const { children } = parent ?? {};
  if (!children)
    return [];
  const result = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child instanceof ctor) {
      result.push(child);
    }
  }
  return result;
}
var ContextMenu = class extends _ModuleSupport64.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.darkTheme = false;
    /**
     * Extra menu actions with a label and callback.
     */
    this.extraActions = [];
    /**
     * Extra menu actions that only appear when clicking on a node.
     */
    this.extraNodeActions = [];
    /**
     * Extra menu actions that only appear when clicking on a legend item
     */
    this.extraLegendItemActions = [];
    this.x = 0;
    this.y = 0;
    this.interactionManager = ctx.interactionManager;
    this.registry = ctx.contextMenuRegistry;
    this.groups = { default: [], extra: [], extraSeries: [], extraNode: [], extraLegendItem: [] };
    this.element = ctx.domManager.addChild("canvas-overlay", moduleId2);
    this.element.classList.add(DEFAULT_CONTEXT_MENU_CLASS);
    this.element.addEventListener("contextmenu", (event) => event.preventDefault());
    this.destroyFns.push(() => this.element.parentNode?.removeChild(this.element));
    this.doClose();
    this.destroyFns.push(ctx.domManager.addListener("hidden", () => this.hide()));
    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(() => {
        if (this.menuElement && this.element.contains(this.menuElement)) {
          this.reposition();
        }
      });
      observer.observe(this.element, { childList: true });
      this.mutationObserver = observer;
      this.destroyFns.push(() => observer.disconnect());
    }
    this.destroyFns.push(
      this.registry.registerDefaultAction({
        id: "download",
        type: "all",
        label: "contextMenuDownload",
        action: () => {
          const title = ctx.chartService.title;
          let fileName = "image";
          if (title?.enabled && title?.text !== void 0) {
            fileName = title.text.replace(/\.+/, "");
          }
          this.ctx.chartService.publicApi?.download({ fileName }).catch((e) => {
            Logger2.error("Unable to download chart", e);
          });
        }
      })
    );
    this.destroyFns.push(this.registry.addListener((e) => this.onContext(e)));
  }
  onContext(event) {
    if (!this.enabled)
      return;
    event.preventDefault();
    this.showEvent = event.sourceEvent;
    this.x = event.x;
    this.y = event.y;
    this.groups.default = this.registry.filterActions(event.type);
    this.pickedNode = void 0;
    this.pickedLegendItem = void 0;
    this.groups.extra = this.extraActions.map(({ label, action }) => {
      return { type: "all", label, action };
    });
    if (ContextMenuRegistry.check("series", event)) {
      this.pickedNode = event.context.pickedNode;
      if (this.pickedNode) {
        this.groups.extraNode = this.extraNodeActions.map(({ label, action }) => {
          return { type: "node", label, action };
        });
      }
    }
    if (ContextMenuRegistry.check("legend", event)) {
      this.pickedLegendItem = event.context.legendItem;
      if (this.pickedLegendItem) {
        this.groups.extraLegendItem = this.extraLegendItemActions.map(({ label, action }) => {
          return { type: "legend", label, action };
        });
      }
    }
    const { default: def, extra, extraNode, extraLegendItem } = this.groups;
    const groupCount = [def, extra, extraNode, extraLegendItem].reduce((count, e) => {
      return e.length + count;
    }, 0);
    if (groupCount === 0)
      return;
    this.show(event.sourceEvent);
  }
  show(sourceEvent) {
    this.interactionManager.pushState(_ModuleSupport64.InteractionState.ContextMenu);
    this.element.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    const newMenuElement = this.renderMenu();
    if (this.menuElement) {
      this.element.replaceChild(newMenuElement, this.menuElement);
      this.menuCloser?.close();
    } else {
      this.element.appendChild(newMenuElement);
    }
    this.menuElement = newMenuElement;
    this.element.style.display = "block";
    const buttons2 = getChildrenOfType(newMenuElement, HTMLButtonElement);
    this.menuCloser = initMenuKeyNav2({
      menu: newMenuElement,
      buttons: buttons2,
      orientation: "vertical",
      device: this.ctx.focusIndicator.guessDevice(sourceEvent),
      autoCloseOnBlur: true,
      skipMouseFocusRestore: true,
      // AG-12849: Avoid series node focus after context-menu item click.
      closeCallback: () => this.doClose()
    });
  }
  hide() {
    this.menuCloser?.close();
  }
  doClose() {
    this.interactionManager.popState(_ModuleSupport64.InteractionState.ContextMenu);
    if (this.menuElement) {
      this.element.removeChild(this.menuElement);
      this.menuElement = void 0;
      this.menuCloser = void 0;
    }
    this.element.style.display = "none";
  }
  renderMenu() {
    const menuElement = createElement7("div");
    menuElement.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);
    menuElement.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    menuElement.role = "menu";
    this.appendMenuGroup(menuElement, this.groups.default, false);
    this.appendMenuGroup(menuElement, this.groups.extra);
    if (this.pickedNode) {
      this.appendMenuGroup(menuElement, this.groups.extraNode);
    }
    if (this.pickedLegendItem) {
      this.appendMenuGroup(menuElement, this.groups.extraLegendItem);
    }
    return menuElement;
  }
  appendMenuGroup(menuElement, group, divider = true) {
    if (group.length === 0)
      return;
    if (divider)
      menuElement.appendChild(this.createDividerElement());
    group.forEach((i) => {
      const item = this.renderItem(i);
      if (item)
        menuElement.appendChild(item);
    });
  }
  renderItem(item) {
    if (item && typeof item === "object" && item.constructor === Object) {
      return this.createActionElement(item);
    }
  }
  createDividerElement() {
    const el = createElement7("div");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__divider`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.role = "separator";
    return el;
  }
  createActionElement({ id, label, type, action }) {
    const disabled = !!(id && this.registry.isDisabled(id));
    return this.createButtonElement(type, label, action, disabled);
  }
  createButtonOnClick(type, callback) {
    if (ContextMenuRegistry.checkCallback("legend", type, callback)) {
      return () => {
        if (this.pickedLegendItem) {
          const { seriesId, itemId, enabled } = this.pickedLegendItem;
          callback({ type: "contextmenu", seriesId, itemId, enabled });
          this.hide();
        }
      };
    } else if (ContextMenuRegistry.checkCallback("node", type, callback)) {
      return () => {
        const { pickedNode, showEvent } = this;
        const event = pickedNode?.series.createNodeContextMenuActionEvent(showEvent, pickedNode);
        if (event) {
          callback(event);
        } else {
          _Util48.Logger.error("series node not found");
        }
        this.hide();
      };
    }
    return () => {
      callback({ type: "contextMenuEvent", event: this.showEvent });
      this.hide();
    };
  }
  createButtonElement(type, label, callback, disabled) {
    const el = createElement7("button");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.ariaDisabled = disabled.toString();
    el.textContent = this.ctx.localeManager.t(label);
    el.role = "menuitem";
    el.onclick = makeAccessibleClickListener(el, this.createButtonOnClick(type, callback));
    el.addEventListener("mouseover", () => el.focus());
    return el;
  }
  reposition() {
    let { x, y } = this;
    this.element.style.top = "unset";
    this.element.style.bottom = "unset";
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    const { offsetWidth: width, offsetHeight: height } = this.element;
    x = _ModuleSupport64.clamp(0, x, canvasRect.width - width);
    y = _ModuleSupport64.clamp(0, y, canvasRect.height - height);
    this.element.style.left = `${x}px`;
    this.element.style.top = `calc(${y}px - 0.5em)`;
  }
  destroy() {
    super.destroy();
    this.mutationObserver?.disconnect();
    this.ctx.domManager.removeStyles(moduleId2);
    this.ctx.domManager.removeChild("canvas-overlay", moduleId2);
  }
};
__decorateClass([
  Validate29(BOOLEAN8)
], ContextMenu.prototype, "enabled", 2);
__decorateClass([
  Validate29(BOOLEAN8)
], ContextMenu.prototype, "darkTheme", 2);

// packages/ag-charts-enterprise/src/features/context-menu/contextMenuModule.ts
var ContextMenuModule = {
  type: "root",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "gauge"],
  optionsKey: "contextMenu",
  moduleFactory: (ctx) => new ContextMenu(ctx),
  themeTemplate: {
    contextMenu: {
      enabled: true,
      darkTheme: _Theme3.IS_DARK_THEME
    }
  }
};

// packages/ag-charts-enterprise/src/features/crosshair/crosshairModule.ts
import { _Theme as _Theme4 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/crosshair/crosshair.ts
import { _ModuleSupport as _ModuleSupport66, _Scene as _Scene29, _Util as _Util50 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/crosshair/crosshairLabel.ts
import { _ModuleSupport as _ModuleSupport65, _Scene as _Scene28, _Util as _Util49 } from "ag-charts-community";
var { ActionOnSet: ActionOnSet3, BaseProperties: BaseProperties12, BOOLEAN: BOOLEAN9, FUNCTION: FUNCTION2, NUMBER: NUMBER7, STRING: STRING15, Validate: Validate30 } = _ModuleSupport65;
var { setAttribute: setAttribute2 } = _Util49;
var DEFAULT_LABEL_CLASS = "ag-crosshair-label";
var CrosshairLabelProperties = class extends _Scene28.ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.format = void 0;
    this.renderer = void 0;
  }
};
__decorateClass([
  Validate30(BOOLEAN9)
], CrosshairLabelProperties.prototype, "enabled", 2);
__decorateClass([
  Validate30(STRING15, { optional: true })
], CrosshairLabelProperties.prototype, "className", 2);
__decorateClass([
  Validate30(NUMBER7)
], CrosshairLabelProperties.prototype, "xOffset", 2);
__decorateClass([
  Validate30(NUMBER7)
], CrosshairLabelProperties.prototype, "yOffset", 2);
__decorateClass([
  Validate30(STRING15, { optional: true })
], CrosshairLabelProperties.prototype, "format", 2);
__decorateClass([
  Validate30(FUNCTION2, { optional: true })
], CrosshairLabelProperties.prototype, "renderer", 2);
var CrosshairLabel = class extends BaseProperties12 {
  constructor(domManager, key, axisId) {
    super();
    this.domManager = domManager;
    this.id = _Util49.createId(this);
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.renderer = void 0;
    this.element = domManager.addChild("canvas-overlay", `crosshair-label-${this.id}`);
    this.element.classList.add(DEFAULT_LABEL_CLASS);
    setAttribute2(this.element, "aria-hidden", true);
    this.element.setAttribute("data-key", key);
    this.element.setAttribute("data-axis-id", axisId);
  }
  show(meta) {
    const { element } = this;
    const left = meta.x + this.xOffset;
    const top = meta.y + this.yOffset;
    element.style.top = `${Math.round(top)}px`;
    element.style.left = `${Math.round(left)}px`;
    this.toggle(true);
  }
  setLabelHtml(html) {
    if (html !== void 0) {
      this.element.innerHTML = html;
    }
  }
  getBBox() {
    const { element } = this;
    return new _Scene28.BBox(element.clientLeft, element.clientTop, element.clientWidth, element.clientHeight);
  }
  toggle(visible) {
    this.element.classList.toggle(`ag-crosshair-label-hidden`, !visible);
  }
  destroy() {
    this.domManager.removeChild("canvas-overlay", `crosshair-label-${this.id}`);
  }
  toLabelHtml(input, defaults) {
    if (typeof input === "string") {
      return input;
    }
    defaults = defaults ?? {};
    const {
      text: text2 = defaults.text ?? "",
      color = defaults.color,
      backgroundColor = defaults.backgroundColor,
      opacity = defaults.opacity ?? 1
    } = input;
    const style = `opacity: ${opacity}; background-color: ${backgroundColor?.toLowerCase()}; color: ${color}`;
    return `<div class="ag-crosshair-label-content" style="${style}">
                    <span>${text2}</span>
                </div>`;
  }
};
__decorateClass([
  Validate30(BOOLEAN9)
], CrosshairLabel.prototype, "enabled", 2);
__decorateClass([
  Validate30(STRING15, { optional: true }),
  ActionOnSet3({
    changeValue(newValue, oldValue) {
      if (newValue !== oldValue) {
        if (oldValue) {
          this.element.classList.remove(oldValue);
        }
        if (newValue) {
          this.element.classList.add(newValue);
        }
      }
    }
  })
], CrosshairLabel.prototype, "className", 2);
__decorateClass([
  Validate30(NUMBER7)
], CrosshairLabel.prototype, "xOffset", 2);
__decorateClass([
  Validate30(NUMBER7)
], CrosshairLabel.prototype, "yOffset", 2);
__decorateClass([
  Validate30(STRING15, { optional: true })
], CrosshairLabel.prototype, "format", 2);
__decorateClass([
  Validate30(FUNCTION2, { optional: true })
], CrosshairLabel.prototype, "renderer", 2);

// packages/ag-charts-enterprise/src/features/crosshair/crosshair.ts
var { Group: Group3, TranslatableGroup, Line: Line2, BBox: BBox2 } = _Scene29;
var { createId: createId2 } = _Util50;
var { POSITIVE_NUMBER: POSITIVE_NUMBER6, RATIO: RATIO6, BOOLEAN: BOOLEAN10, COLOR_STRING: COLOR_STRING3, LINE_DASH: LINE_DASH3, OBJECT: OBJECT11, InteractionState: InteractionState3, Validate: Validate31, Layers: Layers5 } = _ModuleSupport66;
var Crosshair = class extends _ModuleSupport66.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId2(this);
    this.enabled = false;
    this.stroke = "rgb(195, 195, 195)";
    this.lineDash = [6, 3];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.snap = true;
    this.label = new CrosshairLabelProperties();
    this.seriesRect = new BBox2(0, 0, 0, 0);
    this.hoverRect = new BBox2(0, 0, 0, 0);
    this.bounds = new BBox2(0, 0, 0, 0);
    this.crosshairGroup = new TranslatableGroup({
      name: "crosshairs",
      layer: true,
      zIndex: Layers5.SERIES_CROSSHAIR_ZINDEX
    });
    this.lineGroup = this.crosshairGroup.appendChild(
      new Group3({
        name: `${this.id}-crosshair-lines`,
        zIndex: Layers5.SERIES_CROSSHAIR_ZINDEX
      })
    );
    this.lineGroupSelection = _Scene29.Selection.select(this.lineGroup, Line2, false);
    this.activeHighlight = void 0;
    this.axisCtx = ctx.parent;
    this.labels = {};
    const seriesRegion = ctx.regionManager.getRegion("series");
    const mouseMoveStates = InteractionState3.Default | InteractionState3.Annotations;
    this.hideCrosshairs();
    this.destroyFns.push(
      ctx.scene.attachNode(this.crosshairGroup),
      seriesRegion.addListener("hover", (event) => this.onMouseMove(event), mouseMoveStates),
      seriesRegion.addListener("drag", (event) => this.onMouseMove(event), InteractionState3.Annotations),
      seriesRegion.addListener("wheel", () => this.onMouseOut(), InteractionState3.Default),
      seriesRegion.addListener("leave", () => this.onMouseOut(), InteractionState3.Default),
      ctx.zoomManager.addListener("zoom-pan-start", () => this.onMouseOut()),
      ctx.zoomManager.addListener("zoom-change", () => this.onMouseOut()),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      ctx.layoutManager.addListener("layout:complete", (event) => this.layout(event)),
      () => Object.entries(this.labels).forEach(([_, label]) => label.destroy())
    );
  }
  layout({ series: { rect, paddedRect, visible }, axes }) {
    if (!(visible && axes && this.enabled)) {
      return;
    }
    this.seriesRect = rect;
    this.hoverRect = paddedRect;
    const { position: axisPosition = "left", axisId } = this.axisCtx;
    const axisLayout = axes.find((a) => a.id === axisId);
    if (!axisLayout) {
      return;
    }
    this.axisLayout = axisLayout;
    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;
    this.bounds = buildBounds(rect, axisPosition, padding);
    const { crosshairGroup, bounds } = this;
    crosshairGroup.translationX = Math.round(bounds.x);
    crosshairGroup.translationY = Math.round(bounds.y);
    const crosshairKeys = ["pointer", ...this.axisCtx.seriesKeyProperties()];
    this.updateSelections(crosshairKeys);
    this.updateLines();
    this.updateLabels(crosshairKeys);
  }
  updateSelections(data) {
    this.lineGroupSelection.update(
      data,
      (group) => group.append(new Line2()),
      (key) => key
    );
  }
  updateLabels(keys) {
    const { labels, ctx } = this;
    keys.forEach((key) => {
      labels[key] ?? (labels[key] = new CrosshairLabel(ctx.domManager, key, this.axisCtx.axisId));
      this.updateLabel(labels[key]);
    });
    this.labelFormatter = this.axisCtx.scaleValueFormatter(this.label.format);
  }
  updateLabel(label) {
    const { enabled, className, xOffset, yOffset, format, renderer } = this.label;
    label.enabled = enabled;
    label.className = className;
    label.xOffset = xOffset;
    label.yOffset = yOffset;
    label.format = format;
    label.renderer = renderer;
  }
  updateLines() {
    const { lineGroupSelection, bounds, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, axisLayout } = this;
    if (!axisLayout) {
      return;
    }
    const isVertical = this.isVertical();
    lineGroupSelection.each((line) => {
      line.stroke = stroke2;
      line.strokeWidth = strokeWidth;
      line.strokeOpacity = strokeOpacity;
      line.lineDash = lineDash;
      line.lineDashOffset = lineDashOffset;
      line.y1 = 0;
      line.y2 = isVertical ? bounds.height : 0;
      line.x1 = 0;
      line.x2 = isVertical ? 0 : bounds.width;
    });
  }
  isVertical() {
    return this.axisCtx.direction === "x";
  }
  formatValue(val) {
    const {
      labelFormatter,
      axisLayout,
      ctx: { callbackCache }
    } = this;
    if (labelFormatter) {
      const result = callbackCache.call(labelFormatter, val);
      if (result !== void 0)
        return result;
    }
    const isInteger = val % 1 === 0;
    const fractionDigits = (axisLayout?.label.fractionDigits ?? 0) + (isInteger ? 0 : 1);
    return typeof val === "number" ? val.toFixed(fractionDigits) : String(val);
  }
  onMouseMove(event) {
    if (!this.enabled || this.snap) {
      return;
    }
    const { crosshairGroup, hoverRect } = this;
    const { offsetX, offsetY } = event;
    if (hoverRect.containsPoint(offsetX, offsetY)) {
      const lineData = this.getData(event);
      this.updatePositions(lineData);
      crosshairGroup.visible = true;
    } else {
      this.hideCrosshairs();
    }
    this.ctx.updateService.update(_ModuleSupport66.ChartUpdateType.SCENE_RENDER);
  }
  onMouseOut() {
    this.hideCrosshairs();
    this.ctx.updateService.update(_ModuleSupport66.ChartUpdateType.SCENE_RENDER);
  }
  onHighlightChange(event) {
    if (!this.enabled) {
      return;
    }
    const { crosshairGroup, axisCtx } = this;
    const { datum, series } = event.currentHighlight ?? {};
    const hasCrosshair = datum && (series?.axes.x?.id === axisCtx.axisId || series?.axes.y?.id === axisCtx.axisId);
    this.activeHighlight = hasCrosshair ? event.currentHighlight : void 0;
    if (this.snap) {
      if (!this.activeHighlight) {
        this.hideCrosshairs();
        return;
      }
      const activeHighlightData = this.getActiveHighlightData(this.activeHighlight);
      this.updatePositions(activeHighlightData);
      crosshairGroup.visible = true;
    }
  }
  isInRange(value) {
    return this.axisCtx.inRange(value);
  }
  updatePositions(data) {
    const { seriesRect, lineGroupSelection } = this;
    lineGroupSelection.each((line, key) => {
      const lineData = data[key];
      if (!lineData) {
        line.visible = false;
        return;
      }
      line.visible = true;
      const { value, position } = lineData;
      let x = 0;
      let y = 0;
      if (this.isVertical()) {
        x = position;
        line.x = Math.round(x);
      } else {
        y = position;
        line.y = Math.round(y);
      }
      if (this.label.enabled) {
        this.showLabel(x + seriesRect.x, y + seriesRect.y, value, key);
      } else {
        this.hideLabel(key);
      }
    });
  }
  getData(event) {
    const { axisCtx } = this;
    const key = "pointer";
    const { datum, xKey = "", yKey = "" } = this.activeHighlight ?? {};
    const { regionOffsetX, regionOffsetY } = event;
    const isVertical = this.isVertical();
    const position = isVertical ? regionOffsetX : regionOffsetY;
    return {
      [key]: {
        position,
        value: axisCtx.continuous ? axisCtx.scaleInvert(position) : datum?.[isVertical ? xKey : yKey] ?? ""
      }
    };
  }
  getActiveHighlightData(activeHighlight) {
    const { axisCtx } = this;
    const { datum, series, xKey = "", aggregatedValue, cumulativeValue, midPoint } = activeHighlight;
    const seriesKeyProperties = series.getKeyProperties(axisCtx.direction);
    const halfBandwidth = axisCtx.scaleBandwidth() / 2;
    const matchingAxisId = series.axes[axisCtx.direction]?.id === axisCtx.axisId;
    const isYKey = seriesKeyProperties.indexOf("yKey") > -1 && matchingAxisId;
    const isXKey = seriesKeyProperties.indexOf("xKey") > -1 && matchingAxisId;
    const datumValue = aggregatedValue ?? cumulativeValue;
    if (isYKey && datumValue !== void 0) {
      const position = axisCtx.scaleConvert(datumValue) + halfBandwidth;
      const isInRange = this.isInRange(position);
      return isInRange ? {
        yKey: { value: datumValue, position }
      } : {};
    }
    if (isXKey) {
      const position = (this.isVertical() ? midPoint?.x : midPoint?.y) ?? 0;
      const value = axisCtx.continuous ? axisCtx.scaleInvert(position) : datum[xKey];
      const isInRange = this.isInRange(position);
      return isInRange ? {
        xKey: {
          value,
          position
        }
      } : {};
    }
    const activeHighlightData = {};
    seriesKeyProperties.forEach((key) => {
      const keyValue = series.properties[key];
      const value = datum[keyValue];
      const position = axisCtx.scaleConvert(value) + halfBandwidth;
      const isInRange = this.isInRange(position);
      if (isInRange) {
        activeHighlightData[key] = { value, position };
      }
    });
    return activeHighlightData;
  }
  getLabelHtml(value, label) {
    const {
      label: { renderer: labelRenderer },
      axisLayout: { label: { fractionDigits = 0 } = {} } = {}
    } = this;
    const defaults = {
      text: this.formatValue(value)
    };
    if (labelRenderer) {
      const params = {
        value,
        fractionDigits
      };
      return label.toLabelHtml(labelRenderer(params), defaults);
    }
    return label.toLabelHtml(defaults);
  }
  showLabel(x, y, value, key) {
    const {
      axisCtx: { position: axisPosition, direction: axisDirection },
      bounds,
      axisLayout
    } = this;
    if (!axisLayout) {
      return;
    }
    const {
      label: { padding: labelPadding },
      tickSize
    } = axisLayout;
    const padding = labelPadding + tickSize;
    const label = this.labels[key];
    const html = this.getLabelHtml(value, label);
    label.setLabelHtml(html);
    const labelBBox = label.getBBox();
    const labelMeta = calculateAxisLabelPosition({
      x,
      y,
      labelBBox,
      bounds,
      axisPosition,
      axisDirection,
      padding
    });
    label.show(labelMeta);
  }
  hideCrosshairs() {
    this.crosshairGroup.visible = false;
    for (const key in this.labels) {
      this.hideLabel(key);
    }
  }
  hideLabel(key) {
    this.labels[key].toggle(false);
  }
};
__decorateClass([
  Validate31(BOOLEAN10)
], Crosshair.prototype, "enabled", 2);
__decorateClass([
  Validate31(COLOR_STRING3, { optional: true })
], Crosshair.prototype, "stroke", 2);
__decorateClass([
  Validate31(LINE_DASH3, { optional: true })
], Crosshair.prototype, "lineDash", 2);
__decorateClass([
  Validate31(POSITIVE_NUMBER6)
], Crosshair.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate31(POSITIVE_NUMBER6)
], Crosshair.prototype, "strokeWidth", 2);
__decorateClass([
  Validate31(RATIO6)
], Crosshair.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate31(BOOLEAN10)
], Crosshair.prototype, "snap", 2);
__decorateClass([
  Validate31(OBJECT11)
], Crosshair.prototype, "label", 2);

// packages/ag-charts-enterprise/src/features/crosshair/crosshairModule.ts
var CrosshairModule = {
  type: "axis-option",
  optionsKey: "crosshair",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  axisTypes: ["category", "ordinal-time", "number", "log", "time"],
  moduleFactory: (ctx) => new Crosshair(ctx),
  themeTemplate: {
    crosshair: {
      snap: true,
      stroke: _Theme4.DEFAULT_MUTED_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      lineDash: [5, 6],
      lineDashOffset: 0,
      label: {
        enabled: true
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/data-source/dataSource.ts
import { _ModuleSupport as _ModuleSupport67 } from "ag-charts-community";
var { BOOLEAN: BOOLEAN11, FUNCTION: FUNCTION3, ActionOnSet: ActionOnSet4, Validate: Validate32 } = _ModuleSupport67;
var DataSource = class extends _ModuleSupport67.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.enabled = false;
    this.getData = () => Promise.resolve();
    this.dataService = ctx.dataService;
  }
  updateCallback(enabled, getData) {
    if (!this.dataService)
      return;
    if (enabled && getData != null) {
      this.dataService.updateCallback(getData);
    } else {
      this.dataService.clearCallback();
    }
  }
};
__decorateClass([
  ActionOnSet4({
    newValue(enabled) {
      this.updateCallback(enabled, this.getData);
    }
  }),
  Validate32(BOOLEAN11)
], DataSource.prototype, "enabled", 2);
__decorateClass([
  ActionOnSet4({
    newValue(getData) {
      this.updateCallback(this.enabled, getData);
    }
  }),
  Validate32(FUNCTION3)
], DataSource.prototype, "getData", 2);
__decorateClass([
  ActionOnSet4({
    newValue(requestThrottle) {
      this.dataService.requestThrottle = requestThrottle;
    }
  })
], DataSource.prototype, "requestThrottle", 2);
__decorateClass([
  ActionOnSet4({
    newValue(updateThrottle) {
      this.dataService.dispatchThrottle = updateThrottle;
    }
  })
], DataSource.prototype, "updateThrottle", 2);
__decorateClass([
  ActionOnSet4({
    newValue(updateDuringInteraction) {
      this.dataService.dispatchOnlyLatest = !updateDuringInteraction;
    }
  })
], DataSource.prototype, "updateDuringInteraction", 2);

// packages/ag-charts-enterprise/src/features/data-source/dataSourceModule.ts
var DataSourceModule = {
  type: "root",
  optionsKey: "dataSource",
  packageType: "enterprise",
  chartTypes: ["cartesian", "hierarchy", "polar", "topology", "flow-proportion", "gauge"],
  moduleFactory: (ctx) => new DataSource(ctx),
  themeTemplate: {
    dataSource: { enabled: false }
  }
};

// packages/ag-charts-enterprise/src/features/error-bar/errorBarModule.ts
import { AgErrorBarSupportedSeriesTypes as AgErrorBarSupportedSeriesTypes2 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/error-bar/errorBar.ts
import { AgErrorBarSupportedSeriesTypes, _ModuleSupport as _ModuleSupport70, _Scene as _Scene31, _Util as _Util51 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/error-bar/errorBarNode.ts
import { _ModuleSupport as _ModuleSupport68, _Scene as _Scene30 } from "ag-charts-community";
var { nearestSquaredInContainer, partialAssign, mergeDefaults } = _ModuleSupport68;
var { BBox: BBox3 } = _Scene30;
var HierarchicalBBox = class {
  constructor(components) {
    this.components = components;
    this.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    if (!this.union.containsPoint(x, y)) {
      return false;
    }
    for (const bbox of this.components) {
      if (bbox.containsPoint(x, y)) {
        return true;
      }
    }
    return false;
  }
};
var ErrorBarNode = class extends _Scene30.Group {
  constructor() {
    super();
    this.capLength = NaN;
    this._datum = void 0;
    this.whiskerPath = new _Scene30.Path();
    this.capsPath = new _Scene30.Path();
    this.bboxes = new HierarchicalBBox([]);
    this.append([this.whiskerPath, this.capsPath]);
  }
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  calculateCapLength(capsTheme, capDefaults) {
    const { lengthRatio = 1, length } = capsTheme;
    const { lengthRatioMultiplier, lengthMax } = capDefaults;
    const desiredLength = length ?? lengthRatio * lengthRatioMultiplier;
    return Math.min(desiredLength, lengthMax);
  }
  getItemStylerParams(options, style, highlighted) {
    const { datum } = this;
    if (datum == null || options.itemStyler == null)
      return;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = options;
    return {
      ...style,
      datum: datum.datum,
      seriesId: datum.datum.seriesId,
      xKey: datum.xKey,
      yKey: datum.yKey,
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      highlighted
    };
  }
  formatStyles(style, options, highlighted) {
    let { cap: capsStyle, ...whiskerStyle } = style;
    const params = this.getItemStylerParams(options, style, highlighted);
    if (params != null && options.itemStyler != null) {
      const result = options.itemStyler(params);
      whiskerStyle = mergeDefaults(result, whiskerStyle);
      capsStyle = mergeDefaults(result?.cap, result, capsStyle);
    }
    return { whiskerStyle, capsStyle };
  }
  applyStyling(target, source) {
    partialAssign(
      ["visible", "stroke", "strokeWidth", "strokeOpacity", "lineDash", "lineDashOffset"],
      target,
      source
    );
  }
  update(style, formatters, highlighted) {
    if (this.datum === void 0) {
      return;
    }
    const { whiskerStyle, capsStyle } = this.formatStyles(style, formatters, highlighted);
    const { xBar, yBar, capDefaults } = this.datum;
    const whisker = this.whiskerPath;
    this.applyStyling(whisker, whiskerStyle);
    whisker.path.clear(true);
    if (yBar !== void 0) {
      whisker.path.moveTo(yBar.lowerPoint.x, yBar.lowerPoint.y);
      whisker.path.lineTo(yBar.upperPoint.x, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      whisker.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y);
      whisker.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y);
    }
    whisker.path.closePath();
    this.capLength = this.calculateCapLength(capsStyle ?? {}, capDefaults);
    const capOffset = this.capLength / 2;
    const caps = this.capsPath;
    this.applyStyling(caps, capsStyle);
    caps.path.clear(true);
    if (yBar !== void 0) {
      caps.path.moveTo(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y);
      caps.path.lineTo(yBar.lowerPoint.x + capOffset, yBar.lowerPoint.y);
      caps.path.moveTo(yBar.upperPoint.x - capOffset, yBar.upperPoint.y);
      caps.path.lineTo(yBar.upperPoint.x + capOffset, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      caps.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset);
      caps.path.lineTo(xBar.lowerPoint.x, xBar.lowerPoint.y + capOffset);
      caps.path.moveTo(xBar.upperPoint.x, xBar.upperPoint.y - capOffset);
      caps.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y + capOffset);
    }
    caps.path.closePath();
  }
  updateBBoxes() {
    const { capLength, whiskerPath: whisker, capsPath: caps } = this;
    const { yBar, xBar } = this.datum ?? {};
    const capOffset = capLength / 2;
    const components = [];
    if (yBar !== void 0) {
      const whiskerHeight = yBar.lowerPoint.y - yBar.upperPoint.y;
      components.push(
        new BBox3(yBar.lowerPoint.x, yBar.upperPoint.y, whisker.strokeWidth, whiskerHeight),
        new BBox3(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y, capLength, caps.strokeWidth),
        new BBox3(yBar.upperPoint.x - capOffset, yBar.upperPoint.y, capLength, caps.strokeWidth)
      );
    }
    if (xBar !== void 0) {
      const whiskerWidth = xBar.upperPoint.x - xBar.lowerPoint.x;
      components.push(
        new BBox3(xBar.lowerPoint.x, xBar.upperPoint.y, whiskerWidth, whisker.strokeWidth),
        new BBox3(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset, caps.strokeWidth, capLength),
        new BBox3(xBar.upperPoint.x, xBar.upperPoint.y - capOffset, caps.strokeWidth, capLength)
      );
    }
    this.bboxes.components = components;
    this.bboxes.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    return this.bboxes.containsPoint(x, y);
  }
  pickNode(x, y) {
    return this.containsPoint(x, y) ? this : void 0;
  }
  nearestSquared(x, y, maxDistance) {
    const { bboxes } = this;
    if (bboxes.union.distanceSquared(x, y) > maxDistance) {
      return { nearest: void 0, distanceSquared: Infinity };
    }
    const { distanceSquared } = BBox3.nearestBox(x, y, bboxes.components);
    return { nearest: this, distanceSquared };
  }
};
var ErrorBarGroup = class extends _Scene30.Group {
  get children() {
    return super.children;
  }
  nearestSquared(x, y) {
    const { nearest, distanceSquared } = nearestSquaredInContainer(x, y, {
      children: this.children
    });
    if (nearest !== void 0 && !isNaN(distanceSquared)) {
      return { datum: nearest.datum, distanceSquared };
    }
  }
};

// packages/ag-charts-enterprise/src/features/error-bar/errorBarProperties.ts
import {
  _ModuleSupport as _ModuleSupport69
} from "ag-charts-community";
var {
  BaseProperties: BaseProperties13,
  Validate: Validate33,
  BOOLEAN: BOOLEAN12,
  COLOR_STRING: COLOR_STRING4,
  FUNCTION: FUNCTION4,
  LINE_DASH: LINE_DASH4,
  NUMBER: NUMBER8,
  OBJECT: OBJECT12,
  POSITIVE_NUMBER: POSITIVE_NUMBER7,
  RATIO: RATIO7,
  STRING: STRING16
} = _ModuleSupport69;
var ErrorBarCap = class extends BaseProperties13 {
};
__decorateClass([
  Validate33(BOOLEAN12, { optional: true })
], ErrorBarCap.prototype, "visible", 2);
__decorateClass([
  Validate33(COLOR_STRING4, { optional: true })
], ErrorBarCap.prototype, "stroke", 2);
__decorateClass([
  Validate33(POSITIVE_NUMBER7, { optional: true })
], ErrorBarCap.prototype, "strokeWidth", 2);
__decorateClass([
  Validate33(RATIO7, { optional: true })
], ErrorBarCap.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate33(LINE_DASH4, { optional: true })
], ErrorBarCap.prototype, "lineDash", 2);
__decorateClass([
  Validate33(POSITIVE_NUMBER7, { optional: true })
], ErrorBarCap.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate33(NUMBER8, { optional: true })
], ErrorBarCap.prototype, "length", 2);
__decorateClass([
  Validate33(RATIO7, { optional: true })
], ErrorBarCap.prototype, "lengthRatio", 2);
var ErrorBarProperties = class extends BaseProperties13 {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cap = new ErrorBarCap();
  }
};
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "yLowerKey", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "yLowerName", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "yUpperKey", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "yUpperName", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "xLowerKey", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "xLowerName", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "xUpperKey", 2);
__decorateClass([
  Validate33(STRING16, { optional: true })
], ErrorBarProperties.prototype, "xUpperName", 2);
__decorateClass([
  Validate33(BOOLEAN12, { optional: true })
], ErrorBarProperties.prototype, "visible", 2);
__decorateClass([
  Validate33(COLOR_STRING4, { optional: true })
], ErrorBarProperties.prototype, "stroke", 2);
__decorateClass([
  Validate33(POSITIVE_NUMBER7, { optional: true })
], ErrorBarProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate33(RATIO7, { optional: true })
], ErrorBarProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate33(LINE_DASH4, { optional: true })
], ErrorBarProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate33(POSITIVE_NUMBER7, { optional: true })
], ErrorBarProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate33(FUNCTION4, { optional: true })
], ErrorBarProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate33(OBJECT12)
], ErrorBarProperties.prototype, "cap", 2);

// packages/ag-charts-enterprise/src/features/error-bar/errorBar.ts
var {
  fixNumericExtent,
  groupAccumulativeValueProperty,
  isDefined,
  mergeDefaults: mergeDefaults2,
  valueProperty,
  ChartAxisDirection: ChartAxisDirection11
} = _ModuleSupport70;
function toErrorBoundCartesianSeries(ctx) {
  for (const supportedType of AgErrorBarSupportedSeriesTypes) {
    if (supportedType === ctx.series.type) {
      return ctx.series;
    }
  }
  throw new Error(
    `AG Charts - unsupported series type '${ctx.series.type}', error bars supported series types: ${AgErrorBarSupportedSeriesTypes.join(", ")}`
  );
}
var ErrorBars = class _ErrorBars extends _ModuleSupport70.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.properties = new ErrorBarProperties();
    const series = toErrorBoundCartesianSeries(ctx);
    const { annotationGroup, annotationSelections } = series;
    this.cartesianSeries = series;
    this.groupNode = new ErrorBarGroup({
      name: `${annotationGroup.id}-errorBars`,
      zIndex: _ModuleSupport70.Layers.SERIES_LAYER_ZINDEX,
      zIndexSubOrder: series.getGroupZIndexSubOrder("annotation")
    });
    annotationGroup.appendChild(this.groupNode);
    this.selection = _Scene31.Selection.select(this.groupNode, () => this.errorBarFactory());
    annotationSelections.add(this.selection);
    this.destroyFns.push(
      series.addListener("data-processed", (e) => this.onDataProcessed(e)),
      series.addListener("data-update", (e) => this.onDataUpdate(e)),
      series.addListener("visibility-changed", (e) => this.onToggleSeriesItem(e)),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      () => annotationGroup.removeChild(this.groupNode),
      () => annotationSelections.delete(this.selection)
    );
  }
  hasErrorBars() {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    return isDefined(xLowerKey) && isDefined(xUpperKey) || isDefined(yLowerKey) && isDefined(yUpperKey);
  }
  isStacked() {
    const stackCount = this.cartesianSeries.seriesGrouping?.stackCount;
    return stackCount == null ? false : stackCount > 0;
  }
  getUnstackPropertyDefinition(opts) {
    const props = [];
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    if (yLowerKey != null && yUpperKey != null) {
      props.push(
        valueProperty(yLowerKey, yScaleType, { id: `${yErrorsID}-lower` }),
        valueProperty(yUpperKey, yScaleType, { id: `${yErrorsID}-upper` })
      );
    }
    if (xLowerKey != null && xUpperKey != null) {
      props.push(
        valueProperty(xLowerKey, xScaleType, { id: `${xErrorsID}-lower` }),
        valueProperty(xUpperKey, xScaleType, { id: `${xErrorsID}-upper` })
      );
    }
    return props;
  }
  getStackPropertyDefinition(opts) {
    const props = [];
    const { cartesianSeries } = this;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    const groupIndex = cartesianSeries.seriesGrouping?.groupIndex ?? cartesianSeries.id;
    const groupOpts = {
      invalidValue: null,
      missingValue: 0,
      separateNegative: true,
      ...cartesianSeries.visible ? {} : { forceValue: 0 }
    };
    const makeErrorProperty = (key, id, type, scaleType) => {
      return groupAccumulativeValueProperty(
        key,
        "normal",
        "current",
        {
          id: `${id}-${type}`,
          groupId: `errorGroup-${groupIndex}-${type}`,
          ...groupOpts
        },
        scaleType
      );
    };
    const pushErrorProperties = (lowerKey, upperKey, id, scaleType) => {
      props.push(
        ...makeErrorProperty(lowerKey, id, "lower", scaleType),
        ...makeErrorProperty(upperKey, id, "upper", scaleType)
      );
    };
    if (yLowerKey != null && yUpperKey != null) {
      pushErrorProperties(yLowerKey, yUpperKey, yErrorsID, yScaleType);
    }
    if (xLowerKey != null && xUpperKey != null) {
      pushErrorProperties(xLowerKey, xUpperKey, xErrorsID, xScaleType);
    }
    return props;
  }
  getPropertyDefinitions(opts) {
    if (this.isStacked()) {
      return this.getStackPropertyDefinition(opts);
    } else {
      return this.getUnstackPropertyDefinition(opts);
    }
  }
  onDataProcessed(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
  }
  getDomain(direction) {
    const { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID } = this.getMaybeFlippedKeys();
    const hasAxisErrors = direction === ChartAxisDirection11.X ? isDefined(xLowerKey) && isDefined(xUpperKey) : isDefined(yLowerKey) && isDefined(yUpperKey);
    if (hasAxisErrors) {
      const { dataModel, processedData, cartesianSeries: series } = this;
      if (dataModel != null && processedData != null) {
        const id = { x: xErrorsID, y: yErrorsID }[direction];
        const lowerDomain = dataModel.getDomain(series, `${id}-lower`, "value", processedData);
        const upperDomain = dataModel.getDomain(series, `${id}-upper`, "value", processedData);
        const domain = [Math.min(...lowerDomain, ...upperDomain), Math.max(...lowerDomain, ...upperDomain)];
        return fixNumericExtent(domain);
      }
    }
    return [];
  }
  onDataUpdate(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
    if (isDefined(event.dataModel) && isDefined(event.processedData)) {
      this.createNodeData();
      this.update();
    }
  }
  getNodeData() {
    return this.cartesianSeries.contextNodeData?.nodeData;
  }
  createNodeData() {
    const nodeData = this.getNodeData();
    const xScale = this.cartesianSeries.axes[ChartAxisDirection11.X]?.scale;
    const yScale = this.cartesianSeries.axes[ChartAxisDirection11.Y]?.scale;
    if (!this.hasErrorBars() || !xScale || !yScale || !nodeData) {
      return;
    }
    for (let i = 0; i < nodeData.length; i++) {
      const { midPoint, xLower, xUpper, yLower, yUpper } = this.getDatum(nodeData, i);
      if (midPoint != null) {
        let xBar, yBar;
        if (isDefined(xLower) && isDefined(xUpper)) {
          xBar = {
            lowerPoint: { x: this.convert(xScale, xLower), y: midPoint.y },
            upperPoint: { x: this.convert(xScale, xUpper), y: midPoint.y }
          };
        }
        if (isDefined(yLower) && isDefined(yUpper)) {
          yBar = {
            lowerPoint: { x: midPoint.x, y: this.convert(yScale, yLower) },
            upperPoint: { x: midPoint.x, y: this.convert(yScale, yUpper) }
          };
        }
        nodeData[i].xBar = xBar;
        nodeData[i].yBar = yBar;
      }
    }
  }
  getMaybeFlippedKeys() {
    let { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    let [xErrorsID, yErrorsID] = ["xValue-errors", "yValue-errors"];
    if (this.cartesianSeries.shouldFlipXY()) {
      [xLowerKey, yLowerKey] = [yLowerKey, xLowerKey];
      [xUpperKey, yUpperKey] = [yUpperKey, xUpperKey];
      [xErrorsID, yErrorsID] = [yErrorsID, xErrorsID];
    }
    return { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID };
  }
  static getDatumKey(datum, key, offset) {
    if (key == null) {
      return;
    }
    const value = datum.datum[key];
    if (value == null) {
      return;
    }
    if (typeof value !== "number") {
      _Util51.Logger.warnOnce(`Found [${key}] error value of type ${typeof value}. Expected number type`);
      return;
    }
    return value + offset;
  }
  getDatum(nodeData, datumIndex) {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.getMaybeFlippedKeys();
    const datum = nodeData[datumIndex];
    const d = datum.cumulativeValue == null || !this.isStacked() ? 0 : datum.cumulativeValue - datum.yValue;
    const [xOffset, yOffset] = this.cartesianSeries.shouldFlipXY() ? [d, 0] : [0, d];
    return {
      midPoint: datum.midPoint,
      xLower: _ErrorBars.getDatumKey(datum, xLowerKey, xOffset),
      xUpper: _ErrorBars.getDatumKey(datum, xUpperKey, xOffset),
      yLower: _ErrorBars.getDatumKey(datum, yLowerKey, yOffset),
      yUpper: _ErrorBars.getDatumKey(datum, yUpperKey, yOffset)
    };
  }
  convert(scale, value) {
    const offset = (scale.bandwidth ?? 0) / 2;
    return scale.convert(value) + offset;
  }
  update() {
    const nodeData = this.getNodeData();
    if (nodeData != null) {
      this.selection.update(nodeData);
      this.selection.each((node, datum, i) => this.updateNode(node, datum, i));
    }
  }
  updateNode(node, datum, _index) {
    node.datum = datum;
    node.update(this.getDefaultStyle(), this.properties, false);
    node.updateBBoxes();
  }
  pickNodeExact(point) {
    const { x, y } = point;
    const node = this.groupNode.pickNode(x, y);
    if (node != null) {
      return { datum: node.datum, distanceSquared: 0 };
    }
  }
  pickNodeNearest(point) {
    return this.groupNode.nearestSquared(point.x, point.y);
  }
  pickNodeMainAxisFirst(point) {
    return this.groupNode.nearestSquared(point.x, point.y);
  }
  getTooltipParams() {
    const {
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      xLowerName = xLowerKey,
      xUpperName = xUpperKey,
      yLowerName = yLowerKey,
      yUpperName = yUpperKey
    } = this.properties;
    return { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName };
  }
  onToggleSeriesItem(event) {
    this.groupNode.visible = event.enabled;
  }
  makeStyle(baseStyle) {
    return {
      visible: baseStyle.visible,
      lineDash: baseStyle.lineDash,
      lineDashOffset: baseStyle.lineDashOffset,
      stroke: baseStyle.stroke,
      strokeWidth: baseStyle.strokeWidth,
      strokeOpacity: baseStyle.strokeOpacity,
      cap: mergeDefaults2(this.properties.cap, baseStyle)
    };
  }
  getDefaultStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  getHighlightStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  restyleHighlightChange(highlightChange, style, highlighted) {
    const nodeData = this.getNodeData();
    if (nodeData == null)
      return;
    for (let i = 0; i < nodeData.length; i++) {
      if (highlightChange === nodeData[i]) {
        this.selection.at(i)?.update(style, this.properties, highlighted);
        break;
      }
    }
  }
  onHighlightChange(event) {
    const { previousHighlight, currentHighlight } = event;
    if (currentHighlight?.series === this.cartesianSeries) {
      this.restyleHighlightChange(currentHighlight, this.getHighlightStyle(), true);
    }
    if (previousHighlight?.series === this.cartesianSeries) {
      this.restyleHighlightChange(previousHighlight, this.getDefaultStyle(), false);
    }
    this.groupNode.opacity = this.cartesianSeries.getOpacity();
  }
  errorBarFactory() {
    return new ErrorBarNode();
  }
  getWhiskerProperties() {
    const { stroke: stroke2, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset } = this.properties;
    return { stroke: stroke2, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset };
  }
};

// packages/ag-charts-enterprise/src/features/error-bar/errorBarTheme.ts
import { _Theme as _Theme5 } from "ag-charts-community";
var ERROR_BARS_THEME = {
  series: {
    errorBar: {
      visible: true,
      stroke: _Theme5.DEFAULT_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      cap: {
        length: void 0,
        lengthRatio: void 0
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/error-bar/errorBarModule.ts
var ErrorBarsModule = {
  type: "series-option",
  identifier: "error-bars",
  optionsKey: "errorBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  seriesTypes: AgErrorBarSupportedSeriesTypes2,
  moduleFactory: (ctx) => new ErrorBars(ctx),
  themeTemplate: ERROR_BARS_THEME
};

// packages/ag-charts-enterprise/src/features/foreground/foreground.ts
import { _ModuleSupport as _ModuleSupport71 } from "ag-charts-community";
var { Layers: Layers6, ActionOnSet: ActionOnSet5, Validate: Validate34, ProxyPropertyOnWrite: ProxyPropertyOnWrite2, OBJECT: OBJECT13, RATIO: RATIO8, COLOR_STRING: COLOR_STRING5 } = _ModuleSupport71;
var Foreground = class extends _ModuleSupport71.Background {
  constructor(ctx) {
    super(ctx, Layers6.FOREGROUND_ZINDEX, true);
    this.ctx = ctx;
    this.image = new Image();
    this.fill = "transparent";
    this.fillOpacity = void 0;
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    const { width, height } = event.chart;
    let placement = {
      x: 0,
      y: 0,
      width,
      height
    };
    if (this.image) {
      placement = this.image.performLayout(width, height);
    }
    if (this.text) {
      this.updateTextNode(placement);
    }
  }
  onImageLoad() {
    this.ctx.updateService.update(_ModuleSupport71.ChartUpdateType.SCENE_RENDER);
  }
  updateTextNode(placement) {
    const { textNode } = this;
    textNode.fontWeight = "bold";
    textNode.fontFamily = "Impact, sans-serif";
    textNode.fontSize = 19;
    textNode.opacity = 0.7;
    textNode.fill = "#9b9b9b";
    textNode.textBaseline = "top";
    const textBBox = this.textNode.getBBox();
    const textPadding = 10;
    textNode.x = placement.x + placement.width / 2 - textBBox.width / 2;
    textNode.y = placement.y + placement.height + textPadding;
  }
};
__decorateClass([
  Validate34(OBJECT13, { optional: true }),
  ActionOnSet5({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Foreground.prototype, "image", 2);
__decorateClass([
  Validate34(COLOR_STRING5, { optional: true }),
  ProxyPropertyOnWrite2("rectNode", "fill")
], Foreground.prototype, "fill", 2);
__decorateClass([
  Validate34(RATIO8, { optional: true }),
  ProxyPropertyOnWrite2("rectNode", "fillOpacity")
], Foreground.prototype, "fillOpacity", 2);

// packages/ag-charts-enterprise/src/features/foreground/foregroundModule.ts
var ForegroundModule = {
  type: "root",
  optionsKey: "foreground",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "gauge"],
  moduleFactory: (ctx) => new Foreground(ctx)
};

// packages/ag-charts-enterprise/src/features/navigator/navigatorModule.ts
import { _ModuleSupport as _ModuleSupport74, _Theme as _Theme6 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/navigator/navigator.ts
import { _ModuleSupport as _ModuleSupport73 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/navigator/miniChart.ts
import { _ModuleSupport as _ModuleSupport72, _Scene as _Scene32, _Util as _Util52 } from "ag-charts-community";
var { Validate: Validate35, BOOLEAN: BOOLEAN13, POSITIVE_NUMBER: POSITIVE_NUMBER8, Layers: Layers7, ActionOnSet: ActionOnSet6, CategoryAxis, GroupedCategoryAxis, TextUtils: TextUtils2 } = _ModuleSupport72;
var { Padding, Logger: Logger3 } = _Util52;
var { Group: Group4, BBox: BBox4, TranslatableGroup: TranslatableGroup2 } = _Scene32;
var MiniChartPadding = class {
  constructor() {
    this.top = 0;
    this.bottom = 0;
  }
};
__decorateClass([
  Validate35(POSITIVE_NUMBER8)
], MiniChartPadding.prototype, "top", 2);
__decorateClass([
  Validate35(POSITIVE_NUMBER8)
], MiniChartPadding.prototype, "bottom", 2);
var MiniChart = class extends _ModuleSupport72.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.padding = new MiniChartPadding();
    this.root = new Group4({ name: "root" });
    this.seriesRoot = this.root.appendChild(
      new TranslatableGroup2({ name: "Series-root", layer: true, zIndex: Layers7.SERIES_LAYER_ZINDEX })
    );
    this.axisGridGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers7.AXIS_GRID_ZINDEX })
    );
    this.axisGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers7.AXIS_GRID_ZINDEX })
    );
    this.data = [];
    this._destroyed = false;
    this.miniChartAnimationPhase = "initial";
    this.axes = [];
    this.series = [];
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this.destroySeries(this.series);
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this._destroyed = true;
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      if (series.rootGroup.parent == null) {
        this.seriesRoot.appendChild(series.rootGroup);
      }
      const chart = this;
      series.chart = {
        get mode() {
          return "standalone";
        },
        get isMiniChart() {
          return true;
        },
        get seriesRect() {
          return chart.seriesRect;
        },
        placeLabels() {
          return /* @__PURE__ */ new Map();
        }
      };
      series.resetAnimation(this.miniChartAnimationPhase === "initial" ? "initial" : "disabled");
    }
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.destroy();
      if (series.rootGroup != null) {
        this.seriesRoot.removeChild(series.rootGroup);
      }
      series.chart = void 0;
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach((axis) => {
      axis.boundSeries = this.series.filter((s) => {
        const seriesAxis = s.axes[axis.direction];
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries() {
    const directionToAxesMap = {};
    this.axes.forEach((axis) => {
      const direction = axis.direction;
      const directionAxes = directionToAxesMap[direction] ?? (directionToAxesMap[direction] = []);
      directionAxes.push(axis);
    });
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger3.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);
        if (!newAxis) {
          Logger3.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      if (!axis.keys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axis.keys.includes(directionKey)) {
          return axis;
        }
      }
    }
  }
  updateData(data) {
    this.series.forEach((s) => s.setChartData(data));
    if (this.miniChartAnimationPhase === "initial") {
      this.ctx.animationManager.onBatchStop(() => {
        this.miniChartAnimationPhase = "ready";
        this.series.forEach((s) => s.resetAnimation("disabled"));
      });
    }
  }
  async processData(dataController) {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    await Promise.all(this.series.map((s) => s.processData(dataController)));
  }
  computeAxisPadding() {
    const padding = new Padding();
    if (!this.enabled) {
      return padding;
    }
    this.axes.forEach(({ position, thickness = 0, line, label }) => {
      if (position == null)
        return;
      let size;
      if (thickness > 0) {
        size = thickness;
      } else {
        const rotationPaddingFix = 5;
        size = (line.enabled ? line.width : 0) + (label.enabled ? TextUtils2.getLineHeight(label.fontSize ?? 0) + label.padding + rotationPaddingFix : 0);
      }
      padding[position] = Math.ceil(size);
    });
    return padding;
  }
  async layout(width, height) {
    const { padding } = this;
    const animated = this.seriesRect != null;
    const seriesRect = new BBox4(0, 0, width, height - (padding.top + padding.bottom));
    this.seriesRect = seriesRect;
    this.seriesRoot.translationY = padding.top;
    this.seriesRoot.setClipRect(new BBox4(0, -padding.top, width, height));
    this.axes.forEach((axis) => {
      const { position = "left" } = axis;
      switch (position) {
        case "top":
        case "bottom":
          axis.range = [0, seriesRect.width];
          axis.gridLength = seriesRect.height;
          break;
        case "right":
        case "left":
          const isCategoryAxis = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;
          axis.range = isCategoryAxis ? [0, seriesRect.height] : [seriesRect.height, 0];
          axis.gridLength = seriesRect.width;
          break;
      }
      axis.gridPadding = 0;
      axis.translation.x = 0;
      axis.translation.y = 0;
      if (position === "right") {
        axis.translation.x = width;
      } else if (position === "bottom") {
        axis.translation.y = height;
      }
      axis.calculateLayout();
      axis.updatePosition();
      axis.update(animated);
    });
    await Promise.all(this.series.map((series) => series.update({ seriesRect })));
  }
};
__decorateClass([
  Validate35(BOOLEAN13)
], MiniChart.prototype, "enabled", 2);
__decorateClass([
  ActionOnSet6({
    changeValue(newValue, oldValue = []) {
      for (const axis of oldValue) {
        if (newValue.includes(axis))
          continue;
        axis.detachAxis(this.axisGroup, this.axisGridGroup);
        axis.destroy();
      }
      for (const axis of newValue) {
        if (oldValue?.includes(axis))
          continue;
        axis.attachAxis(this.axisGroup, this.axisGridGroup);
      }
    }
  })
], MiniChart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet6({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], MiniChart.prototype, "series", 2);

// packages/ag-charts-enterprise/src/features/navigator/navigator.ts
var { ObserveChanges: ObserveChanges4 } = _ModuleSupport73;
var Navigator = class extends _ModuleSupport73.Navigator {
  constructor(ctx) {
    super(ctx);
    this.miniChart = new MiniChart(ctx);
  }
  updateData(data) {
    return this.miniChart.updateData(data);
  }
  processData(dataController) {
    return this.miniChart.processData(dataController);
  }
  onLayoutStart(opts) {
    super.onLayoutStart(opts);
    if (this.enabled) {
      const { top, bottom } = this.miniChart.computeAxisPadding();
      opts.layoutBox.shrink(top + bottom, "bottom");
      this.y -= bottom;
    }
  }
  async onLayoutComplete(opts) {
    super.onLayoutComplete(opts);
    await this.miniChart.layout(this.width, this.height);
  }
};
__decorateClass([
  ObserveChanges4((target, value, oldValue) => {
    target.updateBackground(oldValue?.root, value?.root);
  })
], Navigator.prototype, "miniChart", 2);

// packages/ag-charts-enterprise/src/features/navigator/navigatorModule.ts
var NavigatorModule = {
  type: "root",
  optionsKey: "navigator",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Navigator(ctx),
  themeTemplate: {
    ..._ModuleSupport74.NavigatorModule.themeTemplate,
    navigator: {
      ..._ModuleSupport74.NavigatorModule.themeTemplate?.navigator,
      miniChart: {
        enabled: false,
        label: {
          color: _Theme6.DEFAULT_LABEL_COLOUR,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 10,
          fontFamily: _Theme6.DEFAULT_FONT_FAMILY,
          formatter: void 0,
          padding: 0
        },
        padding: {
          top: 0,
          bottom: 0
        }
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/status-bar/statusBarModule.ts
import { _Theme as _Theme7 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/status-bar/statusBar.ts
import { _ModuleSupport as _ModuleSupport75, _Scene as _Scene34 } from "ag-charts-community";
var {
  CachedTextMeasurerPool: CachedTextMeasurerPool2,
  Layers: Layers8,
  LayoutElement,
  Validate: Validate36,
  BaseProperties: BaseProperties14,
  OBJECT: OBJECT14,
  BOOLEAN: BOOLEAN14,
  STRING: STRING17,
  COLOR_STRING: COLOR_STRING6,
  RATIO: RATIO9,
  valueProperty: valueProperty2
} = _ModuleSupport75;
var { Label: Label2, Rect, Text } = _Scene34;
var chartConfigurations = {
  ohlc: 2 /* Open */ | 4 /* Close */ | 8 /* Low */ | 16 /* High */ | 32 /* Volume */,
  candlestick: 2 /* Open */ | 4 /* Close */ | 8 /* Low */ | 16 /* High */ | 32 /* Volume */,
  "hollow-candlestick": 2 /* Open */ | 4 /* Close */ | 8 /* Low */ | 16 /* High */ | 32 /* Volume */,
  line: 64 /* UnlabelledClose */ | 32 /* Volume */,
  "step-line": 64 /* UnlabelledClose */ | 32 /* Volume */,
  "range-area": 2 /* Open */ | 4 /* Close */ | 8 /* Low */ | 16 /* High */,
  hlc: 128 /* NeutralClose */ | 8 /* Low */ | 16 /* High */ | 32 /* Volume */,
  "high-low": 512 /* NeutralLow */ | 256 /* NeutralHigh */ | 32 /* Volume */
};
var itemIdMap = {
  up: "positive",
  down: "negative"
};
var neutralColorMap = {
  hlc: "altNeutral"
};
var StatusBarBackground = class extends BaseProperties14 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Validate36(COLOR_STRING6)
], StatusBarBackground.prototype, "fill", 2);
__decorateClass([
  Validate36(RATIO9)
], StatusBarBackground.prototype, "fillOpacity", 2);
var StatusBar = class extends _ModuleSupport75.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.openKey = void 0;
    this.highKey = void 0;
    this.lowKey = void 0;
    this.closeKey = void 0;
    this.volumeKey = void 0;
    this.title = new Label2();
    this.positive = new Label2();
    this.negative = new Label2();
    this.neutral = new Label2();
    this.altNeutral = new Label2();
    this.background = new StatusBarBackground();
    this.layoutStyle = "block";
    this.id = "status-bar";
    this.data = void 0;
    this.labelGroup = new _Scene34.TranslatableGroup({
      name: "StatusBar",
      zIndex: Layers8.CHART_OVERLAY_ZINDEX,
      layer: true
    });
    this.backgroundNode = this.labelGroup.appendChild(new Rect());
    this.labels = [
      {
        label: "O",
        configuration: 2 /* Open */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "openValue",
        key: "openKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "H",
        configuration: 16 /* High */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "highValue",
        key: "highKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "H",
        configuration: 256 /* NeutralHigh */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        style: "neutral",
        id: "highValue",
        key: "highKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "L",
        configuration: 8 /* Low */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "lowValue",
        key: "lowKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "L",
        configuration: 512 /* NeutralLow */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        style: "neutral",
        id: "lowValue",
        key: "lowKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "C",
        configuration: 4 /* Close */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "closeValue",
        key: "closeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "C",
        configuration: 128 /* NeutralClose */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "closeValue",
        key: "closeKey",
        style: "neutral",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "",
        configuration: 64 /* UnlabelledClose */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        style: "neutral",
        id: "closeValue",
        key: "closeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          notation: "compact",
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "Vol",
        configuration: 32 /* Volume */,
        title: this.labelGroup.appendChild(new Text()),
        value: this.labelGroup.appendChild(new Text()),
        id: "volumeValue",
        key: "volumeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          notation: "compact",
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      }
    ];
    this.highlightManager = ctx.highlightManager;
    this.labelGroup.visible = false;
    this.destroyFns.push(
      ctx.scene.attachNode(this.labelGroup),
      ctx.layoutManager.registerElement(LayoutElement.Overlay, (e) => this.startPerformLayout(e)),
      ctx.layoutManager.addListener("layout:complete", (e) => this.onLayoutComplete(e)),
      ctx.highlightManager.addListener("highlight-change", () => this.updateHighlight())
    );
  }
  async processData(dataController) {
    if (!this.enabled || this.data == null)
      return;
    const props = [];
    for (const label of this.labels) {
      const { id, key } = label;
      const datumKey = this[key];
      if (datumKey == null) {
        label.domain = void 0;
      } else {
        props.push(valueProperty2(datumKey, "number", { id }));
      }
    }
    if (props.length === 0)
      return;
    const { processedData, dataModel } = await dataController.request(this.id, this.data, { props });
    for (const label of this.labels) {
      const { id, key } = label;
      const datumKey = this[key];
      if (datumKey != null) {
        label.domain = dataModel.getDomain(this, id, "value", processedData);
      }
    }
  }
  startPerformLayout(opts) {
    this.labelGroup.translationX = 0;
    this.labelGroup.translationY = 0;
    if (!this.enabled)
      return;
    const { layoutBox } = opts;
    const innerSpacing = 4;
    const outerSpacing = 12;
    const spacingAbove = 0;
    const spacingBelow = 8;
    this.labelGroup.translationY = layoutBox.y + spacingAbove;
    const maxFontSize = Math.max(this.title.fontSize, this.positive.fontSize, this.negative.fontSize);
    const lineHeight = maxFontSize * Text.defaultLineHeightRatio;
    const labelConfigurations = chartConfigurations[this.getChartType()] ?? 0;
    let left = 0;
    let offsetTop;
    let textVAlign = "alphabetic";
    if (this.layoutStyle === "block") {
      layoutBox.shrink(spacingAbove + lineHeight + spacingBelow, "top");
      offsetTop = maxFontSize + (lineHeight - maxFontSize) / 2;
    } else {
      const { title } = this.ctx.chartService;
      textVAlign = "top";
      offsetTop = spacingAbove + title.padding;
      if (title.enabled) {
        const titleBox = title.node.getBBox();
        left = titleBox.x + titleBox.width + outerSpacing;
      } else {
        left = title.padding;
      }
    }
    for (const { label, configuration, title, value, domain, formatter } of this.labels) {
      if (domain == null || (labelConfigurations & configuration) === 0) {
        title.visible = false;
        value.visible = false;
        continue;
      }
      const maxValueWidth = Math.max(
        CachedTextMeasurerPool2.measureText(formatter.format(domain[0]), {
          font: this.positive.getFont(),
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool2.measureText(formatter.format(domain[1]), {
          font: this.positive.getFont(),
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool2.measureText(formatter.format(domain[0]), {
          font: this.negative.getFont(),
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool2.measureText(formatter.format(domain[1]), {
          font: this.negative.getFont(),
          textBaseline: textVAlign,
          textAlign: "left"
        }).width
      );
      title.visible = true;
      value.visible = true;
      const titleMetrics = CachedTextMeasurerPool2.measureText(label, {
        font: this.title.getFont(),
        textBaseline: textVAlign,
        textAlign: "left"
      });
      title.setFont(this.title);
      title.fill = this.title.color;
      title.text = label;
      title.textBaseline = textVAlign;
      title.y = offsetTop;
      title.x = left;
      left += titleMetrics.width + innerSpacing;
      value.textBaseline = textVAlign;
      value.y = offsetTop;
      value.x = left;
      left += maxValueWidth + outerSpacing;
    }
    this.backgroundNode.x = 0;
    this.backgroundNode.y = 0;
    this.backgroundNode.width = left - outerSpacing;
    this.backgroundNode.height = lineHeight + spacingAbove + spacingBelow;
    this.backgroundNode.fill = this.background.fill;
    this.backgroundNode.fillOpacity = this.background.fillOpacity;
  }
  onLayoutComplete(opts) {
    this.labelGroup.translationX = opts.series.rect.x;
    this.updateHighlight();
  }
  updateHighlight() {
    if (!this.enabled)
      return;
    const activeHighlight = this.highlightManager.getActiveHighlight();
    const datum = activeHighlight?.datum ?? this.data?.at(-1);
    if (datum == null) {
      this.labelGroup.visible = false;
      return;
    }
    this.labelGroup.visible = true;
    const itemId = activeHighlight?.itemId;
    let baseStyle = itemId != null ? itemIdMap[itemId] : void 0;
    if (baseStyle == null && this.openKey != null && this.closeKey != null) {
      if (datum[this.openKey] < datum[this.closeKey]) {
        baseStyle = "positive";
      } else {
        baseStyle = "negative";
      }
    }
    for (const { domain, value, key, formatter, style } of this.labels) {
      if (domain == null)
        continue;
      let labelStyle = style ?? baseStyle ?? "neutral";
      if (labelStyle === "neutral") {
        labelStyle = neutralColorMap[this.getChartType()] ?? labelStyle;
      }
      const datumKey = this[key];
      const datumValue = datumKey != null ? datum?.[datumKey] : void 0;
      value.setFont(this[labelStyle]);
      value.fill = this[labelStyle].color;
      value.text = typeof datumValue === "number" ? formatter.format(datumValue) : "";
    }
  }
  getChartType() {
    let chartType = this.ctx.chartService.publicApi?.getOptions()?.chartType;
    if (chartType == null || chartConfigurations[chartType] == null) {
      chartType = "candlestick";
    }
    return chartType;
  }
};
__decorateClass([
  Validate36(BOOLEAN14)
], StatusBar.prototype, "enabled", 2);
__decorateClass([
  Validate36(STRING17, { optional: true })
], StatusBar.prototype, "openKey", 2);
__decorateClass([
  Validate36(STRING17, { optional: true })
], StatusBar.prototype, "highKey", 2);
__decorateClass([
  Validate36(STRING17, { optional: true })
], StatusBar.prototype, "lowKey", 2);
__decorateClass([
  Validate36(STRING17, { optional: true })
], StatusBar.prototype, "closeKey", 2);
__decorateClass([
  Validate36(STRING17, { optional: true })
], StatusBar.prototype, "volumeKey", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "title", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "positive", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "negative", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "neutral", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "altNeutral", 2);
__decorateClass([
  Validate36(OBJECT14)
], StatusBar.prototype, "background", 2);
__decorateClass([
  Validate36(STRING17)
], StatusBar.prototype, "layoutStyle", 2);

// packages/ag-charts-enterprise/src/features/status-bar/statusBarModule.ts
var StatusBarModule = {
  type: "root",
  identifier: "status-bar",
  optionsKey: "statusBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new StatusBar(ctx),
  themeTemplate: {
    statusBar: {
      enabled: false,
      layoutStyle: _Theme7.DEFAULT_CAPTION_LAYOUT_STYLE,
      title: {
        color: _Theme7.DEFAULT_LABEL_COLOUR
      },
      positive: {
        color: _Theme7.PALETTE_UP_STROKE
      },
      negative: {
        color: _Theme7.PALETTE_DOWN_STROKE
      },
      neutral: {
        color: _Theme7.PALETTE_NEUTRAL_STROKE
      },
      background: {
        fill: _Theme7.DEFAULT_BACKGROUND_COLOUR,
        fillOpacity: 0.5
      },
      altNeutral: {
        color: "gray"
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/sync/chartSync.ts
import { _ModuleSupport as _ModuleSupport77, _Util as _Util53 } from "ag-charts-community";
var {
  BOOLEAN: BOOLEAN15,
  STRING: STRING18,
  UNION: UNION5,
  BaseProperties: BaseProperties15,
  CartesianAxis,
  ChartUpdateType: ChartUpdateType2,
  arraysEqual,
  isDate,
  isDefined: isDefined2,
  isFiniteNumber,
  ObserveChanges: ObserveChanges5,
  TooltipManager,
  Validate: Validate37
} = _ModuleSupport77;
var { Logger: Logger4 } = _Util53;
var ChartSync = class extends BaseProperties15 {
  constructor(moduleContext) {
    super();
    this.moduleContext = moduleContext;
    this.enabled = false;
    this.axes = "x";
    this.nodeInteraction = true;
    this.zoom = true;
  }
  updateChart(chart, updateType = ChartUpdateType2.UPDATE_DATA) {
    chart.ctx.updateService.update(updateType, { skipSync: true });
  }
  updateSiblings(groupId) {
    const { syncManager } = this.moduleContext;
    const updateFn = async () => {
      for (const chart of syncManager.getGroupSiblings(groupId)) {
        await chart.waitForDataProcess(120);
        this.updateChart(chart);
      }
    };
    updateFn().catch((e) => {
      Logger4.warnOnce("Error updating sibling chart", e);
    });
  }
  enabledZoomSync() {
    const { syncManager, zoomManager } = this.moduleContext;
    this.disableZoomSync = zoomManager.addListener("zoom-change", () => {
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if (chart.modulesManager.getModule("sync")?.zoom) {
          chart.ctx.zoomManager.updateZoom("sync", this.mergeZoom(chart));
        }
      }
    });
  }
  enabledNodeInteractionSync() {
    const { highlightManager, syncManager } = this.moduleContext;
    this.disableNodeInteractionSync = highlightManager.addListener("highlight-change", (event) => {
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if (!chart.modulesManager.getModule("sync")?.nodeInteraction)
          continue;
        if (!event.currentHighlight?.datum) {
          chart.ctx.highlightManager.updateHighlight(chart.id);
          chart.ctx.tooltipManager.removeTooltip(chart.id);
          continue;
        }
        for (const axis of chart.axes) {
          const validDirection = this.axes === "xy" ? "x" : this.axes;
          if (!CartesianAxis.is(axis) || axis.direction !== validDirection)
            continue;
          const matchingNodes = chart.series.map((series) => {
            const seriesKeys = series.getKeys(axis.direction);
            if (axis.keys.length && !axis.keys.some((key) => seriesKeys.includes(key)))
              return;
            const { nodeData } = series.contextNodeData;
            if (!nodeData?.length)
              return;
            const valueKey = nodeData[0][`${axis.direction}Key`];
            let eventValue = event.currentHighlight.datum[valueKey];
            const valueIsDate = isDate(eventValue);
            if (valueIsDate) {
              eventValue = eventValue.getTime();
            }
            const nodeDatum = nodeData.find((datum) => {
              const nodeValue = datum.datum[valueKey];
              return valueIsDate ? nodeValue.getTime() === eventValue : nodeValue === eventValue;
            });
            return nodeDatum ? { series, nodeDatum } : null;
          }).filter(isDefined2);
          if (matchingNodes.length < 2 && matchingNodes[0]?.nodeDatum !== chart.ctx.highlightManager.getActiveHighlight()) {
            const { series, nodeDatum } = matchingNodes[0] ?? {};
            chart.ctx.highlightManager.updateHighlight(chart.id, nodeDatum);
            if (nodeDatum) {
              const offsetX = nodeDatum.midPoint?.x ?? nodeDatum.point?.x ?? 0;
              const offsetY = nodeDatum.midPoint?.y ?? nodeDatum.point?.y ?? 0;
              const tooltipMeta = TooltipManager.makeTooltipMeta(
                { type: "hover", offsetX, offsetY },
                nodeDatum
              );
              delete tooltipMeta.lastPointerEvent;
              chart.ctx.tooltipManager.updateTooltip(
                chart.id,
                tooltipMeta,
                series.getTooltipHtml(nodeDatum)
              );
            } else {
              chart.ctx.tooltipManager.removeTooltip(chart.id);
            }
            this.updateChart(chart, ChartUpdateType2.SERIES_UPDATE);
          }
        }
      }
    });
  }
  syncAxes(stopPropagation = false) {
    const { syncManager } = this.moduleContext;
    const chart = syncManager.getChart();
    const syncGroup = syncManager.getGroup(this.groupId);
    const syncSeries = syncGroup.flatMap((c) => c.series);
    const syncAxes = syncGroup[0].axes;
    let hasUpdated = false;
    chart.axes.forEach((axis) => {
      if (!CartesianAxis.is(axis) || this.axes !== "xy" && this.axes !== axis.direction) {
        axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);
        return;
      }
      const { direction, min, max, nice, reverse } = axis;
      for (const mainAxis of syncAxes) {
        if (direction !== mainAxis.direction)
          continue;
        if (nice !== mainAxis.nice || reverse !== mainAxis.reverse || min !== mainAxis.min && (isFiniteNumber(min) || isFiniteNumber(mainAxis.min)) || max !== mainAxis.max && (isFiniteNumber(max) || isFiniteNumber(mainAxis.max))) {
          Logger4.warnOnce(
            "To allow synchronization, ensure that all charts have matching min, max, nice, and reverse properties on the synchronized axes."
          );
          axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);
          this.enabled = false;
          return;
        }
      }
      const boundSeries = syncSeries.filter((series) => {
        if (series.visible) {
          const seriesKeys = series.getKeys(axis.direction);
          return axis.keys.length ? axis.keys.some((key) => seriesKeys.includes(key)) : true;
        }
      });
      if (!arraysEqual(axis.boundSeries, boundSeries)) {
        axis.boundSeries = boundSeries;
        hasUpdated = true;
      }
    });
    if (hasUpdated && !stopPropagation) {
      this.updateSiblings(this.groupId);
    }
  }
  mergeZoom(chart) {
    const { zoomManager } = this.moduleContext;
    if (this.axes === "xy") {
      return zoomManager.getZoom();
    }
    const combinedZoom = chart.ctx.zoomManager.getZoom() ?? {};
    combinedZoom[this.axes] = zoomManager.getZoom()?.[this.axes];
    return combinedZoom;
  }
  onEnabledChange() {
    const { syncManager } = this.moduleContext;
    if (this.enabled) {
      syncManager.subscribe(this.groupId);
    } else {
      syncManager.unsubscribe(this.groupId);
    }
    this.updateSiblings(this.groupId);
    this.onNodeInteractionChange();
    this.onZoomChange();
  }
  onGroupIdChange(newValue, oldValue) {
    if (!this.enabled || newValue === oldValue)
      return;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(oldValue);
    syncManager.subscribe(newValue);
    this.updateSiblings(oldValue);
    this.updateSiblings(newValue);
  }
  onAxesChange() {
    if (!this.enabled)
      return;
    const { syncManager } = this.moduleContext;
    this.updateChart(syncManager.getChart());
  }
  onNodeInteractionChange() {
    if (this.enabled && this.nodeInteraction) {
      this.enabledNodeInteractionSync();
    } else {
      this.disableNodeInteractionSync?.();
    }
  }
  onZoomChange() {
    if (this.enabled && this.zoom) {
      this.enabledZoomSync();
    } else {
      this.disableZoomSync?.();
    }
  }
  destroy() {
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(this.groupId);
    this.updateSiblings(this.groupId);
    this.disableZoomSync?.();
  }
};
ChartSync.className = "Sync";
__decorateClass([
  Validate37(BOOLEAN15),
  ObserveChanges5((target) => target.onEnabledChange())
], ChartSync.prototype, "enabled", 2);
__decorateClass([
  Validate37(STRING18, { optional: true }),
  ObserveChanges5((target, newValue, oldValue) => target.onGroupIdChange(newValue, oldValue))
], ChartSync.prototype, "groupId", 2);
__decorateClass([
  Validate37(UNION5(["x", "y", "xy"], "an axis")),
  ObserveChanges5((target) => target.onAxesChange())
], ChartSync.prototype, "axes", 2);
__decorateClass([
  Validate37(BOOLEAN15),
  ObserveChanges5((target) => target.onNodeInteractionChange())
], ChartSync.prototype, "nodeInteraction", 2);
__decorateClass([
  Validate37(BOOLEAN15),
  ObserveChanges5((target) => target.onZoomChange())
], ChartSync.prototype, "zoom", 2);

// packages/ag-charts-enterprise/src/features/sync/syncModule.ts
var SyncModule = {
  type: "root",
  optionsKey: "sync",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new ChartSync(ctx),
  themeTemplate: {
    sync: { enabled: false }
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoom.ts
import { _ModuleSupport as _ModuleSupport87 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/zoom/scenes/zoomRect.ts
import { _ModuleSupport as _ModuleSupport78, _Scene as _Scene35 } from "ag-charts-community";
var { COLOR_STRING: COLOR_STRING7, RATIO: RATIO10, Validate: Validate38 } = _ModuleSupport78;
var ZoomRect = class extends _Scene35.Rect {
  constructor() {
    super(...arguments);
    this.fill = "rgb(33, 150, 243)";
    this.fillOpacity = 0.2;
  }
};
ZoomRect.className = "ZoomRect";
__decorateClass([
  Validate38(COLOR_STRING7)
], ZoomRect.prototype, "fill", 2);
__decorateClass([
  Validate38(RATIO10)
], ZoomRect.prototype, "fillOpacity", 2);

// packages/ag-charts-enterprise/src/features/zoom/zoomAxisDragger.ts
import { _ModuleSupport as _ModuleSupport80 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/features/zoom/zoomUtils.ts
import { _ModuleSupport as _ModuleSupport79 } from "ag-charts-community";
var { clamp: clamp5, isEqual, round } = _ModuleSupport79;
var UNIT = { min: 0, max: 1 };
var DEFAULT_ANCHOR_POINT_X = "end";
var DEFAULT_ANCHOR_POINT_Y = "middle";
var constrain = (value, min = UNIT.min, max = UNIT.max) => clamp5(min, value, max);
function unitZoomState() {
  return { x: { ...UNIT }, y: { ...UNIT } };
}
function dx(zoom) {
  return zoom.x.max - zoom.x.min;
}
function dy(zoom) {
  return zoom.y.max - zoom.y.min;
}
function isZoomRangeEqual(left, right, epsilon = 1e-10) {
  return isEqual(left.min, right.min, epsilon) && isEqual(left.max, right.max, epsilon);
}
function isZoomEqual(left, right, epsilon) {
  return isZoomRangeEqual(left.x, right.x, epsilon) && isZoomRangeEqual(left.y, right.y, epsilon);
}
function isZoomLess(zoom, minRatioX, minRatioY) {
  const isMinXZoom = round(dx(zoom), 10) <= minRatioX;
  const isMinYZoom = round(dy(zoom), 10) <= minRatioY;
  return isMinXZoom || isMinYZoom;
}
function definedZoomState(zoom) {
  return {
    x: { min: zoom?.x?.min ?? UNIT.min, max: zoom?.x?.max ?? UNIT.max },
    y: { min: zoom?.y?.min ?? UNIT.min, max: zoom?.y?.max ?? UNIT.max }
  };
}
function pointToRatio(bbox, x, y) {
  if (!bbox)
    return { x: 0, y: 0 };
  const constrainedX = constrain(x - bbox.x, 0, bbox.x + bbox.width);
  const constrainedY = constrain(y - bbox.y, 0, bbox.y + bbox.height);
  const rx = 1 / bbox.width * constrainedX;
  const ry = 1 - 1 / bbox.height * constrainedY;
  return { x: constrain(rx), y: constrain(ry) };
}
function translateZoom(zoom, x, y) {
  return {
    x: { min: zoom.x.min + x, max: zoom.x.max + x },
    y: { min: zoom.y.min + y, max: zoom.y.max + y }
  };
}
function scaleZoom(zoom, sx, sy) {
  return {
    x: { min: zoom.x.min, max: zoom.x.min + dx(zoom) * sx },
    y: { min: zoom.y.min, max: zoom.y.min + dy(zoom) * sy }
  };
}
function scaleZoomCenter(zoom, sx, sy) {
  const dx_ = dx(zoom);
  const dy_ = dy(zoom);
  const cx = zoom.x.min + dx_ / 2;
  const cy = zoom.y.min + dy_ / 2;
  return {
    x: { min: cx - dx_ * sx / 2, max: cx + dx_ * sx / 2 },
    y: { min: cy - dy_ * sy / 2, max: cy + dy_ * sy / 2 }
  };
}
function scaleZoomAxisWithAnchor(newState, oldState, anchor, origin) {
  const { min, max } = oldState;
  const center = min + (max - min) / 2;
  const diff8 = newState.max - newState.min;
  switch (anchor) {
    case "start":
      return { min, max: oldState.min + diff8 };
    case "end":
      return { min: oldState.max - diff8, max };
    case "middle":
      return { min: center - diff8 / 2, max: center + diff8 / 2 };
    case "pointer":
      return scaleZoomAxisWithPoint(newState, oldState, origin ?? center);
    default:
      return { min, max };
  }
}
function scaleZoomAxisWithPoint(newState, oldState, origin) {
  const newDelta = newState.max - newState.min;
  const oldDelta = oldState.max - oldState.min;
  const scaledOrigin = origin * (1 - (oldDelta - newDelta));
  const translation = origin - scaledOrigin;
  const min = newState.min + translation;
  const max = newState.max + translation;
  return { min, max };
}
function multiplyZoom(zoom, nx, ny) {
  return {
    x: { min: zoom.x.min * nx, max: zoom.x.max * nx },
    y: { min: zoom.y.min * ny, max: zoom.y.max * ny }
  };
}
function constrainZoom(zoom) {
  const after = unitZoomState();
  after.x = constrainAxis(zoom.x);
  after.y = constrainAxis(zoom.y);
  return after;
}
function constrainAxis(axis) {
  const size = axis.max - axis.min;
  let min = axis.max > UNIT.max ? UNIT.max - size : axis.min;
  let max = axis.min < UNIT.min ? size : axis.max;
  min = Math.max(UNIT.min, min);
  max = Math.min(UNIT.max, max);
  return { min, max };
}
function constrainAxisWithOld({ min, max }, old, minRatio) {
  if (max === old.max) {
    min = max - minRatio;
  } else if (min === old.min) {
    max = min + minRatio;
  } else {
    const cx = old.min + (old.max - old.min) / 2;
    min = cx - minRatio / 2;
    max = cx + minRatio / 2;
  }
  return { min, max };
}

// packages/ag-charts-enterprise/src/features/zoom/zoomAxisDragger.ts
var ZoomAxisDragger = class {
  update(event, direction, anchor, bbox, zoom, axisZoom) {
    this.oldZoom ?? (this.oldZoom = definedZoomState(
      direction === _ModuleSupport80.ChartAxisDirection.X ? { ...zoom, x: axisZoom } : { ...zoom, y: axisZoom }
    ));
    this.updateCoords(event.offsetX, event.offsetY);
    return this.updateZoom(direction, anchor, bbox);
  }
  stop() {
    this.coords = void 0;
    this.oldZoom = void 0;
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords.x2 = x;
      this.coords.y2 = y;
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  updateZoom(direction, anchor, bbox) {
    const { coords, oldZoom } = this;
    let newZoom = definedZoomState(oldZoom);
    if (!coords || !oldZoom) {
      if (direction === _ModuleSupport80.ChartAxisDirection.X)
        return newZoom.x;
      return newZoom.y;
    }
    const origin = pointToRatio(bbox, coords.x1, coords.y1);
    const target = pointToRatio(bbox, coords.x2, coords.y2);
    if (direction === _ModuleSupport80.ChartAxisDirection.X) {
      const scaleX = (target.x - origin.x) * dx(oldZoom);
      newZoom.x.max += scaleX;
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchor, origin.x);
      newZoom = constrainZoom(newZoom);
      return newZoom.x;
    }
    const scaleY = (target.y - origin.y) * dy(oldZoom);
    newZoom.y.max -= scaleY;
    newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchor, origin.y);
    newZoom = constrainZoom(newZoom);
    return newZoom.y;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomContextMenu.ts
var CONTEXT_ZOOM_ACTION_ID = "zoom-action";
var CONTEXT_PAN_ACTION_ID = "pan-action";
var ZoomContextMenu = class {
  constructor(contextMenuRegistry, zoomManager, getModuleProperties, getRect, updateZoom) {
    this.contextMenuRegistry = contextMenuRegistry;
    this.zoomManager = zoomManager;
    this.getModuleProperties = getModuleProperties;
    this.getRect = getRect;
    this.updateZoom = updateZoom;
  }
  registerActions(enabled, zoom) {
    if (!enabled)
      return;
    const { contextMenuRegistry } = this;
    const destroyZoomToCursor = contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_ZOOM_ACTION_ID,
      type: "series",
      label: "contextMenuZoomToCursor",
      action: this.onZoomToHere.bind(this)
    });
    const destroyPanToCursor = contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_PAN_ACTION_ID,
      type: "series",
      label: "contextMenuPanToCursor",
      action: this.onPanToHere.bind(this)
    });
    this.toggleActions(zoom);
    return () => {
      destroyZoomToCursor();
      destroyPanToCursor();
    };
  }
  toggleActions(zoom) {
    const { contextMenuRegistry } = this;
    const { minRatioX, minRatioY } = this.getModuleProperties();
    if (isZoomLess(zoom, minRatioX, minRatioY)) {
      contextMenuRegistry.disableAction(CONTEXT_ZOOM_ACTION_ID);
    } else {
      contextMenuRegistry.enableAction(CONTEXT_ZOOM_ACTION_ID);
    }
    if (isZoomEqual(zoom, unitZoomState())) {
      contextMenuRegistry.disableAction(CONTEXT_PAN_ACTION_ID);
    } else {
      contextMenuRegistry.enableAction(CONTEXT_PAN_ACTION_ID);
    }
  }
  onZoomToHere({ event }) {
    const rect = this.getRect();
    const { enabled, isScalingX, isScalingY, minRatioX, minRatioY } = this.getModuleProperties();
    if (!enabled || !rect || !event || !event.target || !(event instanceof MouseEvent))
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(rect, event.offsetX, event.offsetX);
    const scaledOriginX = origin.x * dx(zoom);
    const scaledOriginY = origin.y * dy(zoom);
    const size = UNIT.max - UNIT.min;
    const halfSize = size / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, isScalingX ? minRatioX : size, isScalingY ? minRatioY : size);
    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
  onPanToHere({ event }) {
    const rect = this.getRect();
    const { enabled } = this.getModuleProperties();
    if (!enabled || !rect || !event || !event.target || !(event instanceof MouseEvent))
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(rect, event.offsetX, event.offsetY);
    const scaleX = dx(zoom);
    const scaleY = dy(zoom);
    const scaledOriginX = origin.x * scaleX;
    const scaledOriginY = origin.y * scaleY;
    const halfSize = (UNIT.max - UNIT.min) / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, scaleX, scaleY);
    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomPanner.ts
import { _ModuleSupport as _ModuleSupport81 } from "ag-charts-community";
var maxZoomCoords = 16;
var decelerationValues = {
  off: 1,
  short: 0.01,
  long: 2e-3
};
var ZoomPanner = class {
  constructor() {
    this.deceleration = 1;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory = [];
  }
  get decelerationValue() {
    const { deceleration } = this;
    return Math.max(
      typeof deceleration === "number" ? deceleration : decelerationValues[deceleration] ?? 1,
      1e-4
    );
  }
  addListener(_type, fn) {
    this.onUpdate = fn;
    return () => {
      this.onUpdate = void 0;
    };
  }
  stopInteractions() {
    if (this.inertiaHandle != null) {
      cancelAnimationFrame(this.inertiaHandle);
      this.inertiaHandle = void 0;
    }
  }
  update(event) {
    this.updateCoords(event.offsetX, event.offsetY);
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};
    this.onUpdate?.({
      type: "update",
      deltaX: x1 - x2,
      deltaY: y1 - y2
    });
  }
  start() {
    this.coordsMonitorTimeout = setInterval(this.recordCurrentZoomCoords.bind(this), 16);
  }
  stop() {
    const { coordsHistory } = this;
    let deltaX = 0;
    let deltaY = 0;
    let deltaT = 0;
    if (coordsHistory.length > 0) {
      const arrayIndex = this.zoomCoordsHistoryIndex % maxZoomCoords;
      let index1 = arrayIndex - 1;
      if (index1 < 0)
        index1 = coordsHistory.length - 1;
      let index0 = arrayIndex;
      if (index0 >= coordsHistory.length)
        index0 = 0;
      const coords1 = coordsHistory[index1];
      const coords0 = coordsHistory[index0];
      deltaX = coords1.x - coords0.x;
      deltaY = coords1.y - coords0.y;
      deltaT = coords1.t - coords0.t;
    }
    this.coords = void 0;
    clearInterval(this.coordsMonitorTimeout);
    this.coordsMonitorTimeout = void 0;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory.length = 0;
    if (deltaT > 0 && this.decelerationValue < 1) {
      const xVelocity = deltaX / deltaT;
      const yVelocity = deltaY / deltaT;
      const velocity = Math.hypot(xVelocity, yVelocity);
      const angle = Math.atan2(yVelocity, xVelocity);
      const t0 = performance.now();
      this.inertiaHandle = _ModuleSupport81.getWindow().requestAnimationFrame((t) => {
        this.animateInertia(t, t, t0, velocity, angle);
      });
    }
  }
  recordCurrentZoomCoords() {
    const { coords, coordsHistory, zoomCoordsHistoryIndex } = this;
    if (!coords)
      return;
    const { x2: x, y2: y } = coords;
    const t = Date.now();
    coordsHistory[zoomCoordsHistoryIndex % maxZoomCoords] = { x, y, t };
    this.zoomCoordsHistoryIndex += 1;
  }
  animateInertia(t, prevT, t0, velocity, angle) {
    const friction = 1 - this.decelerationValue;
    const maxS = -velocity / Math.log(friction);
    const s0 = velocity * (friction ** (prevT - t0) - 1) / Math.log(friction);
    const s1 = velocity * (friction ** (t - t0) - 1) / Math.log(friction);
    this.onUpdate?.({
      type: "update",
      deltaX: -Math.cos(angle) * (s1 - s0),
      deltaY: -Math.sin(angle) * (s1 - s0)
    });
    if (s1 >= maxS - 1)
      return;
    this.inertiaHandle = requestAnimationFrame((nextT) => {
      this.animateInertia(nextT, t, t0, velocity, angle);
    });
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords = { x1: this.coords.x2, y1: this.coords.y2, x2: x, y2: y };
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  translateZooms(bbox, currentZooms, deltaX, deltaY) {
    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), bbox.y + bbox.height - Math.abs(deltaY));
    const offsetX = Math.sign(deltaX) * offset.x;
    const offsetY = -Math.sign(deltaY) * offset.y;
    const newZooms = {};
    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {
      if (currentZoom && currentZoom.min === UNIT.min && currentZoom.max === UNIT.max) {
        continue;
      }
      let zoom = definedZoomState({ [direction]: currentZoom });
      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), offsetY * dy(zoom)));
      newZooms[axisId] = { direction, zoom: zoom[direction] };
    }
    return newZooms;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomRange.ts
import { _ModuleSupport as _ModuleSupport82 } from "ag-charts-community";
var { AND: AND5, DATE: DATE2, NUMBER: NUMBER9, OR: OR3, ObserveChanges: ObserveChanges6, Validate: Validate39 } = _ModuleSupport82;
var ZoomRange = class {
  // private hasRestored = false;
  constructor(onChange) {
    this.onChange = onChange;
  }
  getRange() {
    return this.getRangeWithValues(this.start, this.end);
  }
  getInitialRange() {
    return this.getRangeWithValues(this.initialStart, this.initialEnd);
  }
  updateDomain(domain) {
    this.domain = domain;
  }
  restore(start, end) {
    this.initialStart = start;
    this.initialEnd = end;
    this.start = start;
    this.end = end;
    this.onChange(this.getRange());
  }
  extendToEnd(extent3) {
    return this.extendWith((end) => Number(end) - extent3);
  }
  extendWith(fn) {
    if (!this.domain)
      return;
    const [, end] = this.domain;
    if (end == null)
      return;
    const start = fn(end);
    const changed = this.start !== start || this.end !== end;
    this.end = end;
    this.start = start;
    if (!changed)
      this.onChange?.(this.getRange());
    return { start, end };
  }
  updateWith(fn) {
    if (!this.domain)
      return;
    let [start, end] = this.domain;
    [start, end] = fn(start, end);
    const changed = this.start !== start || this.end !== end;
    this.end = end;
    this.start = start;
    if (!changed)
      this.onChange?.(this.getRange());
    return { start, end };
  }
  extendAll() {
    if (!this.domain)
      return;
    const [start, end] = this.domain;
    const changed = this.start !== start || this.end !== end;
    this.start = start;
    this.end = end;
    if (!changed)
      this.onChange?.(this.getRange());
  }
  getRangeWithValues(start, end) {
    let [d0, d1] = this.domain ?? [];
    if (start == null && end == null || d0 == null || d1 == null)
      return;
    d0 = Number(d0);
    d1 = Number(d1);
    let min = 0;
    let max = 1;
    if (start != null)
      min = (Number(start) - d0) / (d1 - d0);
    if (end != null)
      max = (Number(end) - d0) / (d1 - d0);
    return { min, max };
  }
};
__decorateClass([
  ObserveChanges6((target, start) => {
    target.initialStart ?? (target.initialStart = start);
    const range2 = target.getRangeWithValues(start, target.end);
    if (range2)
      target.onChange?.(range2);
  }),
  Validate39(AND5(
    OR3(DATE2, NUMBER9)
    /* LESS_THAN('end') */
  ), { optional: true })
], ZoomRange.prototype, "start", 2);
__decorateClass([
  ObserveChanges6((target, end) => {
    target.initialEnd ?? (target.initialEnd = end);
    const range2 = target.getRangeWithValues(target.start, end);
    if (range2)
      target.onChange?.(range2);
  }),
  Validate39(AND5(
    OR3(DATE2, NUMBER9)
    /* GREATER_THAN('start') */
  ), { optional: true })
], ZoomRange.prototype, "end", 2);

// packages/ag-charts-enterprise/src/features/zoom/zoomRatio.ts
import { _ModuleSupport as _ModuleSupport83, _Util as _Util56 } from "ag-charts-community";
var { AND: AND6, GREATER_THAN: GREATER_THAN4, LESS_THAN: LESS_THAN3, RATIO: RATIO11, ObserveChanges: ObserveChanges7, Validate: Validate40 } = _ModuleSupport83;
var { Logger: Logger5 } = _Util56;
var ZoomRatio = class {
  constructor(onChange) {
    this.onChange = onChange;
    this.hasRestored = false;
  }
  getRatio() {
    return this.getRatioWithValues(this.start, this.end);
  }
  getInitialRatio() {
    return this.getRatioWithValues(this.initialStart, this.initialEnd);
  }
  restore(start, end) {
    this.hasRestored = true;
    this.initialStart = start;
    this.initialEnd = end;
    this.start = start;
    this.end = end;
    this.onChange(this.getRatio());
  }
  getRatioWithValues(start, end) {
    if (start == null && end == null)
      return;
    return {
      min: start ?? UNIT.min,
      max: end ?? UNIT.max
    };
  }
};
__decorateClass([
  ObserveChanges7((target, start) => {
    if (target.initialStart == null && !target.hasRestored) {
      Logger5.warnOnce("Property [zoom.ratioX] is deprecated. Use [initialState.zoom.ratioX] instead.");
    }
    target.initialStart ?? (target.initialStart = start);
    const ratio = target.getRatioWithValues(start, target.end);
    if (ratio)
      target.onChange?.(ratio);
  }),
  Validate40(AND6(RATIO11, LESS_THAN3("end")), { optional: true })
], ZoomRatio.prototype, "start", 2);
__decorateClass([
  ObserveChanges7((target, end) => {
    if (target.initialEnd == null && !target.hasRestored) {
      Logger5.warnOnce("Property [zoom.ratioY] is deprecated. Use [initialState.zoom.ratioY] instead.");
    }
    target.initialEnd ?? (target.initialEnd = end);
    const ratio = target.getRatioWithValues(target.start, end);
    if (ratio)
      target.onChange?.(ratio);
  }),
  Validate40(AND6(RATIO11, GREATER_THAN4("start")), { optional: true })
], ZoomRatio.prototype, "end", 2);

// packages/ag-charts-enterprise/src/features/zoom/zoomScrollPanner.ts
import { _ModuleSupport as _ModuleSupport84 } from "ag-charts-community";
var DELTA_SCALE = 200;
var ZoomScrollPanner = class {
  update(event, step, bbox, zooms) {
    const deltaX = event.deltaX * step * DELTA_SCALE;
    return this.translateZooms(bbox, zooms, deltaX);
  }
  translateZooms(bbox, currentZooms, deltaX) {
    const newZooms = {};
    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), 0);
    const offsetX = deltaX < 0 ? -offset.x : offset.x;
    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {
      if (direction !== _ModuleSupport84.ChartAxisDirection.X)
        continue;
      let zoom = definedZoomState({ x: currentZoom });
      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), 0));
      newZooms[axisId] = { direction, zoom: zoom.x };
    }
    return newZooms;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomScroller.ts
import { _ModuleSupport as _ModuleSupport85 } from "ag-charts-community";
var ZoomScroller = class {
  updateAxes(event, props, bbox, zooms) {
    const sourceEvent = event.sourceEvent;
    const newZooms = {};
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const origin = pointToRatio(
      bbox,
      sourceEvent.offsetX ?? sourceEvent.clientX,
      sourceEvent.offsetY ?? sourceEvent.clientY
    );
    for (const [axisId, { direction, zoom }] of Object.entries(zooms)) {
      if (zoom == null)
        continue;
      let newZoom = { ...zoom };
      const delta3 = scrollingStep * event.deltaY * (zoom.max - zoom.min);
      if (direction === _ModuleSupport85.ChartAxisDirection.X && isScalingX) {
        newZoom.max += delta3;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointX, origin.x);
      } else if (direction === _ModuleSupport85.ChartAxisDirection.Y && isScalingY) {
        newZoom.max += delta3;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointY, origin.y);
      } else {
        continue;
      }
      newZooms[axisId] = { direction, zoom: constrainAxis(newZoom) };
    }
    return newZooms;
  }
  update(event, props, bbox, oldZoom) {
    const sourceEvent = event.sourceEvent;
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const origin = pointToRatio(
      bbox,
      sourceEvent.offsetX ?? sourceEvent.clientX,
      sourceEvent.offsetY ?? sourceEvent.clientY
    );
    const dir = event.deltaY;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? scrollingStep * dir * dx(oldZoom) : 0;
    newZoom.y.max += isScalingY ? scrollingStep * dir * dy(oldZoom) : 0;
    if (isScalingX) {
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX, origin.x);
    }
    if (isScalingY) {
      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY, origin.y);
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  updateDelta(delta3, props, oldZoom) {
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? scrollingStep * -delta3 * dx(oldZoom) : 0;
    newZoom.y.max += isScalingY ? scrollingStep * -delta3 * dy(oldZoom) : 0;
    if (isScalingX) {
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX);
    }
    if (isScalingY) {
      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY);
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomSelector.ts
var ZoomSelector = class {
  constructor(rect) {
    this.rect = rect;
    this.rect.visible = false;
  }
  update(event, props, bbox, currentZoom) {
    this.rect.visible = true;
    this.updateCoords(event.offsetX, event.offsetY, props, bbox, currentZoom);
    this.updateRect(bbox);
  }
  stop(innerBBox, bbox, currentZoom) {
    let zoom = definedZoomState();
    if (!innerBBox || !bbox)
      return zoom;
    if (this.coords) {
      zoom = this.createZoomFromCoords(bbox, currentZoom);
    }
    const multiplyX = bbox.width / innerBBox.width;
    const multiplyY = bbox.height / innerBBox.height;
    zoom = constrainZoom(multiplyZoom(zoom, multiplyX, multiplyY));
    this.reset();
    return zoom;
  }
  reset() {
    this.coords = void 0;
    this.rect.visible = false;
  }
  didUpdate() {
    return this.rect.visible;
  }
  updateCoords(x, y, props, bbox, currentZoom) {
    if (!this.coords) {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
      return;
    }
    this.coords.x2 = x;
    this.coords.y2 = y;
    if (!bbox)
      return;
    const { isScalingX, isScalingY, minRatioX, minRatioY } = props;
    const zoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const aspectRatio = bbox.width / bbox.height;
    const scaleX = zoom.x.max - zoom.x.min;
    const scaleY = zoom.y.max - zoom.y.min;
    const xRatio = minRatioX / scaleX;
    const yRatio = minRatioY / scaleY;
    if (normal.width / bbox.width < xRatio) {
      if (this.coords.x2 < this.coords.x1) {
        this.coords.x2 = this.coords.x1 - bbox.width * xRatio;
      } else {
        this.coords.x2 = this.coords.x1 + bbox.width * xRatio;
      }
    }
    if (isScalingY && !isScalingX) {
      if (normal.height / bbox.height < yRatio) {
        if (this.coords.y2 < this.coords.y1) {
          this.coords.y2 = this.coords.y1 - bbox.width * xRatio;
        } else {
          this.coords.y2 = this.coords.y1 + bbox.height * yRatio;
        }
      }
    } else if (this.coords.y2 < this.coords.y1) {
      this.coords.y2 = Math.min(
        this.coords.y1 - normal.width / aspectRatio,
        this.coords.y1 - bbox.height * yRatio
      );
    } else {
      this.coords.y2 = Math.max(
        this.coords.y1 + normal.width / aspectRatio,
        this.coords.y1 + bbox.height * yRatio
      );
    }
    if (!isScalingX) {
      this.coords.x1 = bbox.x;
      this.coords.x2 = bbox.x + bbox.width;
    }
    if (!isScalingY) {
      this.coords.y1 = bbox.y;
      this.coords.y2 = bbox.y + bbox.height;
    }
  }
  updateRect(bbox) {
    if (!bbox)
      return;
    const { rect } = this;
    const normal = this.getNormalisedDimensions();
    const { width, height } = normal;
    let { x, y } = normal;
    x = Math.max(x, bbox.x);
    x -= Math.max(0, x + width - (bbox.x + bbox.width));
    y = Math.max(y, bbox.y);
    y -= Math.max(0, y + height - (bbox.y + bbox.height));
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
  }
  createZoomFromCoords(bbox, currentZoom) {
    const oldZoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const origin = pointToRatio(bbox, normal.x, normal.y + normal.height);
    const xFactor = normal.width / bbox.width;
    const yFactor = normal.height / bbox.height;
    let newZoom = scaleZoom(oldZoom, xFactor, yFactor);
    const translateX = origin.x * (oldZoom.x.max - oldZoom.x.min);
    const translateY = origin.y * (oldZoom.y.max - oldZoom.y.min);
    newZoom = translateZoom(newZoom, translateX, translateY);
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  getNormalisedDimensions() {
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};
    const x = x1 <= x2 ? x1 : x2;
    const y = y1 <= y2 ? y1 : y2;
    const width = x1 <= x2 ? x2 - x1 : x1 - x2;
    const height = y1 <= y2 ? y2 - y1 : y1 - y2;
    return { x, y, width, height };
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomToolbar.ts
import { _ModuleSupport as _ModuleSupport86 } from "ag-charts-community";
var { ChartAxisDirection: ChartAxisDirection12, ToolbarManager: ToolbarManager2 } = _ModuleSupport86;
var ZoomToolbar = class {
  constructor(toolbarManager, zoomManager, getResetZoom, updateZoom, updateAxisZoom) {
    this.toolbarManager = toolbarManager;
    this.zoomManager = zoomManager;
    this.getResetZoom = getResetZoom;
    this.updateZoom = updateZoom;
    this.updateAxisZoom = updateAxisZoom;
    this.selectedZoom = void 0;
    this.destroyFns = [];
    this.destroyFns.push(zoomManager.addListener("zoom-change", this.onZoomChanged.bind(this)));
  }
  destroy() {
    for (const fn of this.destroyFns) {
      fn();
    }
  }
  toggle(enabled, zoom, props) {
    this.toggleGroups(enabled);
    if (enabled) {
      this.toggleButtons(zoom, props);
    }
  }
  toggleButtons(zoom, props) {
    const { toolbarManager } = this;
    const isMaxZoom = isZoomEqual(zoom, unitZoomState());
    const isMinZoom = isZoomLess(zoom, props.minRatioX, props.minRatioY);
    const isResetZoom = isZoomEqual(zoom, this.getResetZoom());
    toolbarManager.toggleButton("zoom", "pan-start", { enabled: zoom.x.min > UNIT.min });
    toolbarManager.toggleButton("zoom", "pan-end", { enabled: zoom.x.max < UNIT.max });
    toolbarManager.toggleButton("zoom", "pan-left", { enabled: zoom.x.min > UNIT.min });
    toolbarManager.toggleButton("zoom", "pan-right", { enabled: zoom.x.max < UNIT.max });
    toolbarManager.toggleButton("zoom", "zoom-out", { enabled: !isMaxZoom });
    toolbarManager.toggleButton("zoom", "zoom-in", { enabled: !isMinZoom });
    toolbarManager.toggleButton("zoom", "reset", { enabled: !isResetZoom });
  }
  onButtonPress(event, props) {
    this.onButtonPressRanges(event, props);
    this.onButtonPressZoom(event, props);
  }
  toggleGroups(enabled) {
    this.toolbarManager?.toggleGroup("zoom", "ranges", { visible: Boolean(enabled) });
    this.toolbarManager?.toggleGroup("zoom", "zoom", { visible: Boolean(enabled) });
  }
  onButtonPressRanges(event, props) {
    if (!ToolbarManager2.isGroup("ranges", event))
      return;
    const { id } = event;
    const { rangeX } = props;
    const time2 = event.value;
    if (typeof time2 === "number") {
      rangeX.extendToEnd(time2);
    } else if (Array.isArray(time2)) {
      rangeX.updateWith(() => time2);
    } else if (typeof time2 === "function") {
      rangeX.updateWith(time2);
    }
    const range2 = rangeX.getRange();
    this.selectedZoom = range2 != null ? { id, range: range2 } : void 0;
    this.toolbarManager.toggleGroup("zoom-toolbar", "ranges", { active: false });
    this.toolbarManager.toggleButton("ranges", id, { active: true });
  }
  onZoomChanged(e) {
    const { selectedZoom } = this;
    const { x } = e;
    this.toolbarManager.toggleGroup("zoom-toolbar", "ranges", { active: false });
    if (selectedZoom != null && x != null && isZoomRangeEqual(selectedZoom.range, x)) {
      this.toolbarManager.toggleButton("ranges", selectedZoom.id, { active: true });
    } else {
      this.selectedZoom = void 0;
    }
  }
  onButtonPressZoom(event, props) {
    if (!ToolbarManager2.isGroup("zoom", event))
      return;
    if (props.independentAxes && event.value !== "reset") {
      const axisZooms = this.zoomManager.getAxisZooms();
      for (const [axisId, { direction, zoom }] of Object.entries(axisZooms)) {
        if (zoom == null)
          continue;
        this.onButtonPressZoomAxis(event, props, axisId, direction, zoom);
      }
    } else {
      this.onButtonPressZoomUnified(event, props);
    }
  }
  onButtonPressZoomAxis(event, props, axisId, direction, zoom) {
    if (!ToolbarManager2.isGroup("zoom", event))
      return;
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    let newZoom = { ...zoom };
    const delta3 = zoom.max - zoom.min;
    switch (event.value) {
      case "pan-start":
        newZoom.max = delta3;
        newZoom.min = 0;
        break;
      case "pan-end":
        newZoom.min = newZoom.max - delta3;
        newZoom.max = UNIT.max;
        break;
      case "pan-left":
        newZoom.min -= delta3 * scrollingStep;
        newZoom.max -= delta3 * scrollingStep;
        break;
      case "pan-right":
        newZoom.min += delta3 * scrollingStep;
        newZoom.max += delta3 * scrollingStep;
        break;
      case "zoom-in":
      case "zoom-out": {
        const isDirectionX = direction === ChartAxisDirection12.X;
        const isScalingDirection = isDirectionX && isScalingX || !isDirectionX && isScalingY;
        let scale = event.value === "zoom-in" ? 1 - scrollingStep : 1 + scrollingStep;
        if (!isScalingDirection)
          scale = 1;
        const useAnchorPointX = anchorPointX === "pointer" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;
        const useAnchorPointY = anchorPointY === "pointer" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;
        const useAnchorPoint = isDirectionX ? useAnchorPointX : useAnchorPointY;
        newZoom.max = newZoom.min + (newZoom.max - newZoom.min) * scale;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, useAnchorPoint);
        break;
      }
    }
    this.updateAxisZoom(axisId, direction, constrainAxis(newZoom));
  }
  onButtonPressZoomUnified(event, props) {
    if (!ToolbarManager2.isGroup("zoom", event))
      return;
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const oldZoom = definedZoomState(this.zoomManager.getZoom());
    let zoom = definedZoomState(oldZoom);
    switch (event.value) {
      case "reset":
        zoom = this.getResetZoom();
        break;
      case "pan-start":
        zoom.x.max = dx(zoom);
        zoom.x.min = 0;
        break;
      case "pan-end":
        zoom.x.min = UNIT.max - dx(zoom);
        zoom.x.max = UNIT.max;
        break;
      case "pan-left":
        zoom = translateZoom(zoom, -dx(zoom) * scrollingStep, 0);
        break;
      case "pan-right":
        zoom = translateZoom(zoom, dx(zoom) * scrollingStep, 0);
        break;
      case "zoom-in":
      case "zoom-out": {
        const scale = event.value === "zoom-in" ? 1 - scrollingStep : 1 + scrollingStep;
        const useAnchorPointX = anchorPointX === "pointer" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;
        const useAnchorPointY = anchorPointY === "pointer" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;
        zoom = scaleZoom(zoom, isScalingX ? scale : 1, isScalingY ? scale : 1);
        zoom.x = scaleZoomAxisWithAnchor(zoom.x, oldZoom.x, useAnchorPointX);
        zoom.y = scaleZoomAxisWithAnchor(zoom.y, oldZoom.y, useAnchorPointY);
        break;
      }
    }
    this.updateZoom(constrainZoom(zoom));
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoom.ts
var {
  ARRAY: ARRAY2,
  BOOLEAN: BOOLEAN16,
  NUMBER: NUMBER10,
  RATIO: RATIO12,
  REGIONS: REGIONS3,
  STRING: STRING19,
  UNION: UNION6,
  OR: OR4,
  ActionOnSet: ActionOnSet7,
  ChartAxisDirection: ChartAxisDirection13,
  ChartUpdateType: ChartUpdateType3,
  Validate: Validate41,
  ProxyProperty: ProxyProperty2,
  arraysEqual: arraysEqual2,
  round: sharedRound
} = _ModuleSupport87;
var round2 = (value) => sharedRound(value, 10);
var ANCHOR_POINT = UNION6(["pointer", "start", "middle", "end"], "an anchor cord");
var CURSOR_ID = "zoom-cursor";
var TOOLTIP_ID = "zoom-tooltip";
var ZoomButtonsProperties = class extends _ModuleSupport87.BaseProperties {
  constructor(onChange) {
    super();
    this.onChange = onChange;
    this.enabled = false;
    this.position = "floating-bottom";
    this.size = "small";
    this.align = "center";
  }
};
__decorateClass([
  _ModuleSupport87.ObserveChanges((target) => {
    target.onChange();
  }),
  Validate41(BOOLEAN16)
], ZoomButtonsProperties.prototype, "enabled", 2);
__decorateClass([
  _ModuleSupport87.ObserveChanges((target) => {
    target.onChange();
  }),
  Validate41(ARRAY2, { optional: true })
], ZoomButtonsProperties.prototype, "buttons", 2);
__decorateClass([
  Validate41(STRING19)
], ZoomButtonsProperties.prototype, "position", 2);
__decorateClass([
  Validate41(STRING19)
], ZoomButtonsProperties.prototype, "size", 2);
__decorateClass([
  Validate41(STRING19)
], ZoomButtonsProperties.prototype, "align", 2);
var Zoom = class extends _ModuleSupport87.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.enableAxisDragging = true;
    this.buttons = new ZoomButtonsProperties(() => this.onZoomButtonsChange(this.enabled));
    this.enableDoubleClickToReset = true;
    this.enablePanning = true;
    this.enableScrolling = true;
    this.enableSelecting = false;
    this.panKey = "alt";
    this.axes = "x";
    this.scrollingStep = (UNIT.max - UNIT.min) / 10;
    this.minVisibleItemsX = 2;
    this.minVisibleItemsY = 2;
    this.anchorPointX = DEFAULT_ANCHOR_POINT_X;
    this.anchorPointY = DEFAULT_ANCHOR_POINT_Y;
    this.rangeX = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection13.X));
    this.rangeY = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection13.Y));
    this.ratioX = new ZoomRatio(this.onRangeChange.bind(this, ChartAxisDirection13.X));
    this.ratioY = new ZoomRatio(this.onRangeChange.bind(this, ChartAxisDirection13.Y));
    // Zoom methods
    this.axisDragger = new ZoomAxisDragger();
    this.panner = new ZoomPanner();
    this.scroller = new ZoomScroller();
    this.scrollPanner = new ZoomScrollPanner();
    this.deceleration = "short";
    // State
    this.dragState = 0 /* None */;
    this.axisIds = {};
    this.axisDomains = {};
    this.minRatioX = 0;
    this.minRatioY = 0;
    this.hasPerformedLayout = false;
    this._destroyContextMenuActions = void 0;
    const selectionRect = new ZoomRect();
    this.selector = new ZoomSelector(selectionRect);
    this.contextMenu = new ZoomContextMenu(
      ctx.contextMenuRegistry,
      ctx.zoomManager,
      this.getModuleProperties.bind(this),
      () => this.paddedRect,
      this.updateZoom.bind(this)
    );
    this.toolbar = new ZoomToolbar(
      ctx.toolbarManager,
      ctx.zoomManager,
      this.getResetZoom.bind(this),
      this.updateUnifiedZoom.bind(this),
      this.updateAxisZoom.bind(this)
    );
    const { Default: Default4, ZoomDrag, Animation: Animation2, Annotations: Annotations2 } = _ModuleSupport87.InteractionState;
    const draggableState = Default4 | Animation2 | ZoomDrag;
    const clickableState = Default4 | Animation2;
    const wheelableState = draggableState | Annotations2;
    const region = ctx.regionManager.getRegion(REGIONS3.SERIES);
    const horizontalAxesRegion = ctx.regionManager.getRegion(REGIONS3.HORIZONTAL_AXES);
    const verticalAxesRegion = ctx.regionManager.getRegion(REGIONS3.VERTICAL_AXES);
    const dragStartEventType = "drag-start";
    this.destroyFns.push(
      ctx.scene.attachNode(selectionRect),
      ctx.regionManager.listenAll("dblclick", (event) => this.onDoubleClick(event), clickableState),
      ctx.keyNavManager.addListener("nav-zoom", (event) => this.onNavZoom(event)),
      region.addListener("drag", (event) => this.onDrag(event), draggableState),
      region.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),
      region.addListener("drag-end", (event) => this.onDragEnd(event), draggableState),
      verticalAxesRegion.addListener("drag", (event) => this.onDrag(event), draggableState),
      verticalAxesRegion.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),
      verticalAxesRegion.addListener("drag-end", (event) => this.onDragEnd(event), draggableState),
      verticalAxesRegion.addListener("leave", () => this.onAxisLeave(), clickableState),
      verticalAxesRegion.addListener("hover", (event) => this.onAxisHover(event, ChartAxisDirection13.Y)),
      horizontalAxesRegion.addListener("drag", (event) => this.onDrag(event), draggableState),
      horizontalAxesRegion.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),
      horizontalAxesRegion.addListener("drag-end", (event) => this.onDragEnd(event), draggableState),
      horizontalAxesRegion.addListener("leave", () => this.onAxisLeave(), clickableState),
      horizontalAxesRegion.addListener("hover", (event) => this.onAxisHover(event, ChartAxisDirection13.X)),
      region.addListener("wheel", (event) => this.onWheel(event), wheelableState),
      ctx.gestureDetector.addListener("pinch-move", (event) => this.onPinchMove(event)),
      ctx.toolbarManager.addListener(
        "button-pressed",
        (event) => this.toolbar.onButtonPress(event, this.getModuleProperties())
      ),
      ctx.layoutManager.addListener("layout:complete", (event) => this.onLayoutComplete(event)),
      ctx.updateService.addListener("update-complete", (event) => this.onUpdateComplete(event)),
      ctx.zoomManager.addListener("zoom-change", (event) => this.onZoomChange(event)),
      ctx.zoomManager.addListener("zoom-pan-start", (event) => this.onZoomPanStart(event)),
      ctx.zoomManager.addListener("restore-zoom", (event) => this.onRestoreZoom(event)),
      this.panner.addListener("update", (event) => this.onPanUpdate(event)),
      () => this.toolbar.destroy()
    );
  }
  destroy() {
    super.destroy();
    this._destroyContextMenuActions?.();
  }
  onEnabledChange(enabled) {
    if (!this.contextMenu || !this.toolbar)
      return;
    const zoom = this.getZoom();
    const props = this.getModuleProperties({ enabled });
    this._destroyContextMenuActions?.();
    this._destroyContextMenuActions = this.contextMenu.registerActions(enabled, zoom);
    this.onZoomButtonsChange(enabled);
    this.toolbar.toggle(enabled, zoom, props);
  }
  onZoomButtonsChange(zoomEnabled) {
    if (!this.buttons)
      return;
    const buttonsJson = this.buttons.toJson();
    buttonsJson.enabled && (buttonsJson.enabled = zoomEnabled);
    this.ctx.toolbarManager.proxyGroupOptions("zoom", "zoom", buttonsJson);
  }
  onRangeChange(direction, rangeZoom) {
    const axisId = this.axisIds[direction];
    if (!axisId || !rangeZoom)
      return;
    this.updateAxisZoom(axisId, direction, rangeZoom);
  }
  onDoubleClick(event) {
    const { enabled, enableDoubleClickToReset, hoveredAxis } = this;
    if (!enabled || !enableDoubleClickToReset)
      return;
    const zoom = this.getResetZoom();
    if (hoveredAxis) {
      const { id, direction } = hoveredAxis;
      this.updateAxisZoom(id, direction, zoom[direction]);
    } else if (!event.preventZoomDblClick) {
      this.updateZoom(zoom);
    }
  }
  onDragStart(event) {
    const {
      enabled,
      enableAxisDragging,
      enablePanning,
      enableSelecting,
      hoveredAxis,
      ctx: { cursorManager, zoomManager }
    } = this;
    if (!enabled || event.button !== 0)
      return;
    this.panner.stopInteractions();
    let newDragState = 0 /* None */;
    if (enableAxisDragging && hoveredAxis) {
      newDragState = 1 /* Axis */;
    } else {
      const panKeyPressed = this.isPanningKeyPressed(event.sourceEvent);
      if (enablePanning && (!enableSelecting || panKeyPressed)) {
        cursorManager.updateCursor(CURSOR_ID, "grabbing");
        newDragState = 2 /* Pan */;
        this.panner.start();
      } else if (enableSelecting) {
        const fullyZoomedIn = this.isMinZoom(this.getZoom());
        if (!fullyZoomedIn && !panKeyPressed) {
          newDragState = 3 /* Select */;
        }
      }
    }
    if ((this.dragState = newDragState) !== 0 /* None */) {
      zoomManager.fireZoomPanStartEvent("zoom");
    }
  }
  onDrag(event) {
    const {
      anchorPointX,
      anchorPointY,
      axisDragger,
      dragState,
      enabled,
      paddedRect,
      panner,
      selector,
      seriesRect,
      hoveredAxis,
      ctx: { interactionManager, tooltipManager, updateService, zoomManager }
    } = this;
    if (!enabled || !paddedRect || !seriesRect)
      return;
    interactionManager.pushState(_ModuleSupport87.InteractionState.ZoomDrag);
    const zoom = this.getZoom();
    switch (dragState) {
      case 1 /* Axis */:
        if (!hoveredAxis)
          break;
        const { id: axisId, direction } = hoveredAxis;
        const anchor = direction === _ModuleSupport87.ChartAxisDirection.X ? anchorPointX : anchorPointY;
        const axisZoom = zoomManager.getAxisZoom(axisId);
        const newZoom = axisDragger.update(event, direction, anchor, seriesRect, zoom, axisZoom);
        this.updateAxisZoom(axisId, direction, newZoom);
        break;
      case 2 /* Pan */:
        panner.update(event);
        break;
      case 3 /* Select */:
        selector.update(event, this.getModuleProperties(), paddedRect, zoom);
        break;
      case 0 /* None */:
        return;
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
    updateService.update(ChartUpdateType3.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onDragEnd(_event) {
    const {
      axisDragger,
      dragState,
      enabled,
      panner,
      selector,
      ctx: { cursorManager, interactionManager, tooltipManager }
    } = this;
    interactionManager.popState(_ModuleSupport87.InteractionState.ZoomDrag);
    if (!enabled || dragState === 0 /* None */)
      return;
    switch (dragState) {
      case 1 /* Axis */:
        axisDragger.stop();
        break;
      case 2 /* Pan */:
        panner.stop();
        break;
      case 3 /* Select */:
        if (!selector.didUpdate())
          break;
        const zoom = this.getZoom();
        if (this.isMinZoom(zoom))
          break;
        const newZoom = selector.stop(this.seriesRect, this.paddedRect, zoom);
        this.updateZoom(newZoom);
        break;
    }
    this.dragState = 0 /* None */;
    cursorManager.updateCursor(CURSOR_ID);
    tooltipManager.removeTooltip(TOOLTIP_ID);
  }
  onNavZoom(event) {
    const { enabled, enableScrolling, scroller } = this;
    if (!enabled || !enableScrolling)
      return;
    event.preventDefault();
    this.updateZoom(scroller.updateDelta(event.delta, this.getModuleProperties(), this.getZoom()));
  }
  onWheel(event) {
    const { enabled, enablePanning, enableScrolling, paddedRect } = this;
    if (!enabled || !enableScrolling || !paddedRect)
      return;
    const sourceEvent = event.sourceEvent;
    const { deltaX, deltaY } = sourceEvent;
    const isHorizontalScrolling = deltaX != null && deltaY != null && Math.abs(deltaX) > Math.abs(deltaY);
    if (enablePanning && isHorizontalScrolling) {
      this.onWheelPanning(event);
    } else {
      this.onWheelScrolling(event);
    }
  }
  onWheelPanning(event) {
    const {
      scrollingStep,
      scrollPanner,
      seriesRect,
      ctx: { zoomManager }
    } = this;
    if (!seriesRect)
      return;
    event.preventDefault();
    const newZooms = scrollPanner.update(event, scrollingStep, seriesRect, zoomManager.getAxisZooms());
    for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {
      this.updateAxisZoom(axisId, direction, zoom);
    }
  }
  onWheelScrolling(event) {
    const {
      enableAxisDragging,
      enableIndependentAxes,
      hoveredAxis,
      scroller,
      seriesRect,
      ctx: { zoomManager }
    } = this;
    if (!seriesRect)
      return;
    event.preventDefault();
    const isAxisScrolling = enableAxisDragging && hoveredAxis != null;
    let isScalingX = this.isScalingX();
    let isScalingY = this.isScalingY();
    if (isAxisScrolling) {
      isScalingX = hoveredAxis.direction === _ModuleSupport87.ChartAxisDirection.X;
      isScalingY = !isScalingX;
    }
    const props = this.getModuleProperties({ isScalingX, isScalingY });
    if (enableIndependentAxes === true) {
      const newZooms = scroller.updateAxes(event, props, seriesRect, zoomManager.getAxisZooms());
      for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {
        if (isAxisScrolling && hoveredAxis.id !== axisId)
          continue;
        this.updateAxisZoom(axisId, direction, zoom);
      }
    } else {
      const newZoom = scroller.update(event, props, seriesRect, this.getZoom());
      this.updateUnifiedZoom(newZoom);
    }
  }
  onAxisLeave() {
    const {
      enabled,
      ctx: { cursorManager }
    } = this;
    if (!enabled)
      return;
    this.hoveredAxis = void 0;
    cursorManager.updateCursor(CURSOR_ID);
  }
  onAxisHover(event, direction) {
    const {
      enabled,
      enableAxisDragging,
      ctx: { cursorManager }
    } = this;
    if (!enabled)
      return;
    this.hoveredAxis = {
      id: event.bboxProviderId ?? "unknown",
      direction
    };
    if (enableAxisDragging) {
      cursorManager.updateCursor(CURSOR_ID, direction === ChartAxisDirection13.X ? "ew-resize" : "ns-resize");
    }
  }
  onPinchMove(event) {
    const { enabled, enableScrolling, paddedRect, seriesRect } = this;
    if (!enabled || !enableScrolling || !paddedRect || !seriesRect)
      return;
    const oldZoom = this.getZoom();
    const newZoom = definedZoomState(oldZoom);
    const delta3 = event.deltaDistance * -0.01;
    const origin = pointToRatio(seriesRect, event.origin.x, event.origin.y);
    if (this.isScalingX()) {
      newZoom.x.max += delta3 * dx(oldZoom);
      newZoom.x = scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x);
    }
    if (this.isScalingY()) {
      newZoom.y.max += delta3 * (oldZoom.y.max - oldZoom.y.min);
      newZoom.y = scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y);
    }
    this.updateZoom(constrainZoom(newZoom));
    event.preventDefault();
  }
  onLayoutComplete(event) {
    const { enabled, rangeX, rangeY, ratioX, ratioY } = this;
    if (!enabled)
      return;
    const {
      series: { rect, paddedRect, shouldFlipXY },
      axes
    } = event;
    this.seriesRect = rect;
    this.paddedRect = paddedRect;
    this.shouldFlipXY = shouldFlipXY;
    if (this.restoreEvent) {
      this.restoreZoom(this.restoreEvent);
      this.restoreEvent = void 0;
    }
    this.hasPerformedLayout = true;
    const axesChanged = this.updateAxes(axes);
    if (!axesChanged)
      return;
    rangeX.updateDomain(this.axisDomains[ChartAxisDirection13.X]);
    rangeY.updateDomain(this.axisDomains[ChartAxisDirection13.Y]);
    const newZoom = {
      x: rangeX.getRange() ?? ratioX.getRatio(),
      y: rangeY.getRange() ?? ratioY.getRatio()
    };
    if (newZoom.x != null || newZoom.y != null) {
      this.updateZoom(constrainZoom(definedZoomState(newZoom)));
    }
  }
  onUpdateComplete(event) {
    const { minRect, minVisibleRect } = event;
    const { enabled, minVisibleItemsX, minVisibleItemsY, paddedRect, shouldFlipXY } = this;
    if (!enabled || !paddedRect || !minRect || !minVisibleRect)
      return;
    const zoom = this.getZoom();
    const minVisibleItemsWidth = shouldFlipXY ? minVisibleItemsY : minVisibleItemsX;
    const minVisibleItemsHeight = shouldFlipXY ? minVisibleItemsX : minVisibleItemsY;
    const widthRatio = minVisibleRect.width * minVisibleItemsWidth / paddedRect.width;
    const heightRatio = minVisibleRect.height * minVisibleItemsHeight / paddedRect.height;
    const ratioX = round2(widthRatio * dx(zoom));
    const ratioY = round2(heightRatio * dy(zoom));
    if (this.isScalingX()) {
      this.minRatioX = Math.min(1, ratioX);
    }
    if (this.isScalingY()) {
      this.minRatioY = Math.min(1, ratioY);
    }
    this.minRatioX || (this.minRatioX = this.minRatioY || 0);
    this.minRatioY || (this.minRatioY = this.minRatioX || 0);
  }
  onZoomChange(event) {
    if (event.callerId !== "zoom") {
      this.panner.stopInteractions();
    }
    const zoom = this.getZoom();
    const props = this.getModuleProperties();
    this.contextMenu.toggleActions(zoom);
    this.toolbar.toggleButtons(zoom, props);
  }
  onRestoreZoom(event) {
    if (this.hasPerformedLayout) {
      this.restoreZoom(event);
    } else {
      this.restoreEvent = event;
    }
  }
  onZoomPanStart(event) {
    if (event.callerId === "zoom") {
      this.panner.stopInteractions();
    }
  }
  onPanUpdate(event) {
    const {
      panner,
      seriesRect,
      ctx: { tooltipManager, zoomManager }
    } = this;
    if (!seriesRect)
      return;
    const newZooms = panner.translateZooms(seriesRect, zoomManager.getAxisZooms(), event.deltaX, event.deltaY);
    for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {
      this.updateAxisZoom(axisId, direction, zoom);
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
  }
  updateAxes(axes) {
    if (!axes)
      return;
    const xAxis = this.getPrimaryAxis(axes, ChartAxisDirection13.X);
    const yAxis = this.getPrimaryAxis(axes, ChartAxisDirection13.Y);
    if (!xAxis || !yAxis)
      return;
    this.axisIds = {
      [ChartAxisDirection13.X]: xAxis.axisId,
      [ChartAxisDirection13.Y]: yAxis.axisId
    };
    this.axisDomains = {
      [ChartAxisDirection13.X]: xAxis.domain,
      [ChartAxisDirection13.Y]: yAxis.domain
    };
    return xAxis.changed || yAxis.changed;
  }
  getPrimaryAxis(axes, direction) {
    const axis = axes.find((a) => a.direction === direction);
    if (!axis)
      return;
    let domain = [axis.domain[0], axis.domain.at(-1)];
    if (domain[0] instanceof Date && domain[1] instanceof Date) {
      domain = [domain[0].getTime(), domain[1].getTime()];
    }
    const oldDomain = this.axisDomains[direction];
    const changed = oldDomain == null || !arraysEqual2(oldDomain, domain);
    return { axisId: axis.id, changed, domain };
  }
  isPanningKeyPressed(event) {
    switch (this.panKey) {
      case "alt":
        return event.altKey;
      case "ctrl":
        return event.ctrlKey;
      case "shift":
        return event.shiftKey;
      case "meta":
        return event.metaKey;
    }
  }
  isScalingX() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "y" : this.axes === "x";
  }
  isScalingY() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "x" : this.axes === "y";
  }
  getAnchorPointX() {
    return this.shouldFlipXY ? this.anchorPointY : this.anchorPointX;
  }
  getAnchorPointY() {
    return this.shouldFlipXY ? this.anchorPointX : this.anchorPointY;
  }
  isMinZoom(zoom) {
    return isZoomLess(zoom, this.minRatioX, this.minRatioY);
  }
  updateZoom(zoom) {
    if (this.enableIndependentAxes) {
      this.updatePrimaryAxisZooms(zoom);
    } else {
      this.updateUnifiedZoom(zoom);
    }
  }
  updatePrimaryAxisZooms(zoom) {
    const xAxisId = this.axisIds[ChartAxisDirection13.X];
    const yAxisId = this.axisIds[ChartAxisDirection13.Y];
    if (xAxisId)
      this.updateAxisZoom(xAxisId, ChartAxisDirection13.X, zoom.x);
    if (yAxisId)
      this.updateAxisZoom(yAxisId, ChartAxisDirection13.Y, zoom.y);
  }
  updateUnifiedZoom(zoom) {
    const {
      minRatioX,
      minRatioY,
      ctx: { zoomManager }
    } = this;
    const dx_ = dx(zoom);
    const dy_ = dy(zoom);
    const oldZoom = this.getZoom();
    const zoomedInTooFarX = dx_ <= dx(oldZoom) && dx_ < minRatioX;
    const zoomedInTooFarY = dy_ <= dy(oldZoom) && dy_ < minRatioY;
    if (zoomedInTooFarX) {
      zoom.x = constrainAxisWithOld(zoom.x, oldZoom.x, minRatioX);
    }
    if (zoomedInTooFarY) {
      zoom.y = constrainAxisWithOld(zoom.y, oldZoom.y, minRatioY);
    }
    zoomManager.updateZoom("zoom", zoom);
  }
  updateAxisZoom(axisId, direction, axisZoom) {
    const {
      enableIndependentAxes,
      minRatioX,
      minRatioY,
      ctx: { zoomManager }
    } = this;
    if (!axisZoom)
      return;
    const zoom = this.getZoom();
    if (enableIndependentAxes !== true) {
      zoom[direction] = axisZoom;
      this.updateUnifiedZoom(zoom);
      return;
    }
    const deltaAxis = axisZoom.max - axisZoom.min;
    const deltaOld = zoom[direction].max - zoom[direction].min;
    const minRatio = direction === ChartAxisDirection13.X ? minRatioX : minRatioY;
    if (deltaAxis <= deltaOld && deltaAxis < minRatio) {
      return;
    }
    zoomManager.updateAxisZoom("zoom", axisId, axisZoom);
  }
  restoreZoom(event) {
    const { rangeX, rangeY, ratioX, ratioY } = event;
    if (rangeX) {
      this.rangeX.restore(rangeX.start, rangeX.end);
    }
    if (rangeY) {
      this.rangeY.restore(rangeY.start, rangeY.end);
    }
    if (ratioX && !rangeX) {
      this.ratioX.restore(ratioX.start, ratioX.end);
    }
    if (ratioY && !rangeY) {
      this.ratioY.restore(ratioY.start, ratioY.end);
    }
  }
  getZoom() {
    return definedZoomState(this.ctx.zoomManager.getZoom());
  }
  getResetZoom() {
    const x = this.rangeX.getInitialRange() ?? this.ratioX.getInitialRatio() ?? UNIT;
    const y = this.rangeY.getInitialRange() ?? this.ratioY.getInitialRatio() ?? UNIT;
    return { x, y };
  }
  getModuleProperties(overrides) {
    return {
      anchorPointX: overrides?.anchorPointX ?? this.getAnchorPointX(),
      anchorPointY: overrides?.anchorPointY ?? this.getAnchorPointY(),
      enabled: overrides?.enabled ?? this.enabled,
      independentAxes: overrides?.independentAxes ?? this.enableIndependentAxes === true,
      isScalingX: overrides?.isScalingX ?? this.isScalingX(),
      isScalingY: overrides?.isScalingY ?? this.isScalingY(),
      minRatioX: overrides?.minRatioX ?? this.minRatioX,
      minRatioY: overrides?.minRatioY ?? this.minRatioY,
      rangeX: overrides?.rangeX ?? this.rangeX,
      scrollingStep: overrides?.scrollingStep ?? this.scrollingStep
    };
  }
};
__decorateClass([
  ActionOnSet7({
    newValue(enabled) {
      this.onEnabledChange(enabled);
    }
  }),
  Validate41(BOOLEAN16)
], Zoom.prototype, "enabled", 2);
__decorateClass([
  Validate41(BOOLEAN16)
], Zoom.prototype, "enableAxisDragging", 2);
__decorateClass([
  Validate41(BOOLEAN16)
], Zoom.prototype, "enableDoubleClickToReset", 2);
__decorateClass([
  Validate41(BOOLEAN16, { optional: true })
], Zoom.prototype, "enableIndependentAxes", 2);
__decorateClass([
  Validate41(BOOLEAN16)
], Zoom.prototype, "enablePanning", 2);
__decorateClass([
  Validate41(BOOLEAN16)
], Zoom.prototype, "enableScrolling", 2);
__decorateClass([
  Validate41(BOOLEAN16)
], Zoom.prototype, "enableSelecting", 2);
__decorateClass([
  Validate41(UNION6(["alt", "ctrl", "meta", "shift"], "a pan key"))
], Zoom.prototype, "panKey", 2);
__decorateClass([
  Validate41(UNION6(["x", "y", "xy"], "an axis"))
], Zoom.prototype, "axes", 2);
__decorateClass([
  Validate41(RATIO12)
], Zoom.prototype, "scrollingStep", 2);
__decorateClass([
  Validate41(NUMBER10.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsX", 2);
__decorateClass([
  Validate41(NUMBER10.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsY", 2);
__decorateClass([
  Validate41(ANCHOR_POINT)
], Zoom.prototype, "anchorPointX", 2);
__decorateClass([
  Validate41(ANCHOR_POINT)
], Zoom.prototype, "anchorPointY", 2);
__decorateClass([
  ProxyProperty2("panner.deceleration"),
  Validate41(OR4(RATIO12, UNION6(["off", "short", "long"], "a deceleration")))
], Zoom.prototype, "deceleration", 2);

// packages/ag-charts-enterprise/src/features/zoom/zoomModule.ts
var buttons = {
  enabled: true,
  buttons: [
    {
      icon: "zoom-out",
      tooltip: "toolbarZoomZoomOut",
      value: "zoom-out",
      section: "scale"
    },
    {
      icon: "zoom-in",
      tooltip: "toolbarZoomZoomIn",
      value: "zoom-in",
      section: "scale"
    },
    {
      icon: "pan-left",
      tooltip: "toolbarZoomPanLeft",
      value: "pan-left",
      section: "pan"
    },
    {
      icon: "pan-right",
      tooltip: "toolbarZoomPanRight",
      value: "pan-right",
      section: "pan"
    },
    {
      icon: "reset",
      tooltip: "toolbarZoomReset",
      value: "reset",
      section: "reset"
    }
  ]
};
var ZoomModule = {
  type: "root",
  optionsKey: "zoom",
  packageType: "enterprise",
  chartTypes: ["cartesian", "topology"],
  dependencies: ["toolbar"],
  moduleFactory: (ctx) => new Zoom(ctx),
  themeTemplate: {
    zoom: {
      anchorPointX: "end",
      anchorPointY: "middle",
      axes: "x",
      buttons,
      enabled: false,
      enableAxisDragging: true,
      enableDoubleClickToReset: true,
      enablePanning: true,
      enableScrolling: true,
      enableSelecting: false,
      deceleration: "short",
      minVisibleItemsX: 2,
      minVisibleItemsY: 2,
      panKey: "alt",
      scrollingStep: 0.1
    }
  }
};

// packages/ag-charts-enterprise/src/gradient-legend/gradientLegendModule.ts
import { _Theme as _Theme8 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/gradient-legend/gradientLegend.ts
import {
  _ModuleSupport as _ModuleSupport88,
  _Scene as _Scene38,
  _Util as _Util58
} from "ag-charts-community";
var {
  BOOLEAN: BOOLEAN17,
  OBJECT: OBJECT15,
  POSITION,
  POSITIVE_NUMBER: POSITIVE_NUMBER9,
  BaseProperties: BaseProperties16,
  AxisTicks,
  Layers: Layers9,
  ProxyProperty: ProxyProperty3,
  Validate: Validate42,
  LayoutElement: LayoutElement2
} = _ModuleSupport88;
var { Group: Group5, Rect: Rect2, Triangle, TranslatableGroup: TranslatableGroup3, LinearGradient } = _Scene38;
var { createId: createId3 } = _Util58;
var GradientBar = class extends BaseProperties16 {
  constructor() {
    super(...arguments);
    this.thickness = 16;
    this.preferredLength = 100;
  }
};
__decorateClass([
  Validate42(POSITIVE_NUMBER9)
], GradientBar.prototype, "thickness", 2);
__decorateClass([
  Validate42(POSITIVE_NUMBER9)
], GradientBar.prototype, "preferredLength", 2);
var GradientLegendScale = class {
  constructor(axisTicks) {
    this.axisTicks = axisTicks;
  }
};
__decorateClass([
  ProxyProperty3("axisTicks.label")
], GradientLegendScale.prototype, "label", 2);
__decorateClass([
  ProxyProperty3("axisTicks.interval")
], GradientLegendScale.prototype, "interval", 2);
__decorateClass([
  ProxyProperty3("axisTicks.padding")
], GradientLegendScale.prototype, "padding", 2);
var GradientLegend = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.id = createId3(this);
    this.legendGroup = new TranslatableGroup3({
      name: "legend",
      layer: true,
      zIndex: Layers9.LEGEND_ZINDEX
    });
    this.gradientRect = new Rect2();
    this.arrow = new Triangle();
    this.ticksGroup = new Group5({ name: "legend-axis-group" });
    this.destroyFns = [];
    this.enabled = false;
    this.position = "bottom";
    this.reverseOrder = false;
    this.gradient = new GradientBar();
    this.spacing = 20;
    this.data = [];
    this.highlightManager = ctx.highlightManager;
    this.axisTicks = new AxisTicks();
    this.axisTicks.attachAxis(this.ticksGroup);
    this.scale = new GradientLegendScale(this.axisTicks);
    this.legendGroup.append([this.gradientRect, this.arrow, this.ticksGroup]);
    this.destroyFns.push(
      ctx.highlightManager.addListener("highlight-change", () => this.onChartHoverChange()),
      ctx.layoutManager.registerElement(LayoutElement2.Legend, (e) => this.onStartLayout(e)),
      () => this.legendGroup.parent?.removeChild(this.legendGroup)
    );
  }
  isVertical() {
    return this.position === "right" || this.position === "left";
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
  }
  attachLegend(scene) {
    scene.appendChild(this.legendGroup);
  }
  onStartLayout(ctx) {
    const [data] = this.data;
    if (!this.enabled || !data?.enabled) {
      this.legendGroup.visible = false;
      return;
    }
    const { colorRange } = this.normalizeColorArrays(data);
    this.updateGradientRect(ctx.layoutBox, colorRange);
    const axisBBox = this.updateAxis(data);
    const { left, top } = this.getMeasurements(ctx.layoutBox, axisBBox);
    this.updateArrow();
    this.legendGroup.visible = true;
    this.legendGroup.translationX = left;
    this.legendGroup.translationY = top;
  }
  normalizeColorArrays(data) {
    let colorDomain = data.colorDomain.slice();
    const colorRange = data.colorRange.slice();
    if (colorDomain.length === colorRange.length) {
      return { colorDomain, colorRange };
    }
    if (colorDomain.length > colorRange.length) {
      colorRange.splice(colorDomain.length);
    }
    const [d0, d1] = colorDomain;
    const count = colorRange.length;
    colorDomain = colorRange.map((_, i) => {
      if (i === 0) {
        return d0;
      } else if (i === count - 1) {
        return d1;
      }
      return d0 + (d1 - d0) * i / (count - 1);
    });
    return { colorDomain, colorRange };
  }
  updateGradientRect(shrinkRect, colorRange) {
    const { gradientRect } = this;
    const { preferredLength, thickness } = this.gradient;
    let angle;
    if (this.isVertical()) {
      angle = 0;
      gradientRect.width = thickness;
      gradientRect.height = Math.min(shrinkRect.height, preferredLength);
    } else {
      angle = 90;
      gradientRect.width = Math.min(shrinkRect.width, preferredLength);
      gradientRect.height = thickness;
    }
    const linearGradient = new LinearGradient(
      "oklch",
      colorRange.map((color, i) => ({
        offset: i / (colorRange.length - 1),
        color
      })),
      angle
    );
    gradientRect.fill = linearGradient;
  }
  updateAxis(data) {
    const { axisTicks } = this;
    const vertical = this.isVertical();
    const positiveAxis = this.reverseOrder !== vertical;
    axisTicks.position = this.position;
    axisTicks.translationX = vertical ? this.gradient.thickness : 0;
    axisTicks.translationY = vertical ? 0 : this.gradient.thickness;
    axisTicks.scale.domain = positiveAxis ? data.colorDomain.slice().reverse() : data.colorDomain;
    axisTicks.scale.range = vertical ? [0, this.gradientRect.height] : [0, this.gradientRect.width];
    return axisTicks.calculateLayout();
  }
  updateArrow() {
    const highlighted = this.highlightManager.getActiveHighlight();
    const { arrow } = this;
    if (highlighted?.colorValue == null) {
      arrow.visible = false;
      return;
    }
    const { scale, label } = this.axisTicks;
    const size = label.fontSize ?? 0;
    const t = scale.convert(highlighted.colorValue);
    let { x, y } = this.gradientRect;
    let rotation = Math.PI;
    if (this.isVertical()) {
      x -= size / 2;
      y += t;
      rotation /= 2;
    } else {
      x += t;
      y -= size / 2;
    }
    arrow.visible = true;
    arrow.fill = label.color;
    arrow.rotation = rotation;
    arrow.size = size;
    arrow.translationX = x;
    arrow.translationY = y;
  }
  getMeasurements(shrinkRect, axisBox) {
    let { x: left, y: top } = shrinkRect;
    let { width, height } = this.gradientRect;
    if (this.isVertical()) {
      width += axisBox.width + 5;
    } else {
      height += axisBox.height + 5;
    }
    switch (this.position) {
      case "left":
        top += shrinkRect.height / 2 - height / 2;
        shrinkRect.shrink(width + this.spacing, "left");
        break;
      case "right":
        left += shrinkRect.width - width;
        top += shrinkRect.height / 2 - height / 2;
        shrinkRect.shrink(width + this.spacing, "right");
        break;
      case "top":
        left += shrinkRect.width / 2 - width / 2;
        shrinkRect.shrink(height + this.spacing, "top");
        break;
      case "bottom":
        left += shrinkRect.width / 2 - width / 2;
        top += shrinkRect.height - height;
        shrinkRect.shrink(height + this.spacing, "bottom");
    }
    return { top, left };
  }
  onChartHoverChange() {
    if (!this.enabled)
      return;
    this.updateArrow();
  }
};
GradientLegend.className = "GradientLegend";
__decorateClass([
  Validate42(BOOLEAN17)
], GradientLegend.prototype, "enabled", 2);
__decorateClass([
  Validate42(POSITION)
], GradientLegend.prototype, "position", 2);
__decorateClass([
  Validate42(BOOLEAN17)
], GradientLegend.prototype, "reverseOrder", 2);
__decorateClass([
  Validate42(OBJECT15)
], GradientLegend.prototype, "gradient", 2);
__decorateClass([
  Validate42(POSITIVE_NUMBER9)
], GradientLegend.prototype, "spacing", 2);

// packages/ag-charts-enterprise/src/gradient-legend/gradientLegendModule.ts
var GradientLegendModule = {
  type: "legend",
  optionsKey: "gradientLegend",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "gauge"],
  identifier: "gradient",
  moduleFactory: (ctx) => new GradientLegend(ctx),
  themeTemplate: {
    enabled: false,
    position: "bottom",
    spacing: 20,
    scale: {
      padding: 13,
      label: {
        color: _Theme8.DEFAULT_LABEL_COLOUR,
        fontSize: _Theme8.FONT_SIZE.SMALL,
        fontFamily: _Theme8.DEFAULT_FONT_FAMILY
      },
      interval: {
        minSpacing: 1
      }
    },
    gradient: {
      preferredLength: 100,
      thickness: 16
    },
    reverseOrder: false
  }
};

// packages/ag-charts-enterprise/src/license/md5.ts
var MD5 = class {
  constructor() {
    this.ieCompatibility = false;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = this.ff(a, b, c, d, k[0], 7, -680876936);
    d = this.ff(d, a, b, c, k[1], 12, -389564586);
    c = this.ff(c, d, a, b, k[2], 17, 606105819);
    b = this.ff(b, c, d, a, k[3], 22, -1044525330);
    a = this.ff(a, b, c, d, k[4], 7, -176418897);
    d = this.ff(d, a, b, c, k[5], 12, 1200080426);
    c = this.ff(c, d, a, b, k[6], 17, -1473231341);
    b = this.ff(b, c, d, a, k[7], 22, -45705983);
    a = this.ff(a, b, c, d, k[8], 7, 1770035416);
    d = this.ff(d, a, b, c, k[9], 12, -1958414417);
    c = this.ff(c, d, a, b, k[10], 17, -42063);
    b = this.ff(b, c, d, a, k[11], 22, -1990404162);
    a = this.ff(a, b, c, d, k[12], 7, 1804603682);
    d = this.ff(d, a, b, c, k[13], 12, -40341101);
    c = this.ff(c, d, a, b, k[14], 17, -1502002290);
    b = this.ff(b, c, d, a, k[15], 22, 1236535329);
    a = this.gg(a, b, c, d, k[1], 5, -165796510);
    d = this.gg(d, a, b, c, k[6], 9, -1069501632);
    c = this.gg(c, d, a, b, k[11], 14, 643717713);
    b = this.gg(b, c, d, a, k[0], 20, -373897302);
    a = this.gg(a, b, c, d, k[5], 5, -701558691);
    d = this.gg(d, a, b, c, k[10], 9, 38016083);
    c = this.gg(c, d, a, b, k[15], 14, -660478335);
    b = this.gg(b, c, d, a, k[4], 20, -405537848);
    a = this.gg(a, b, c, d, k[9], 5, 568446438);
    d = this.gg(d, a, b, c, k[14], 9, -1019803690);
    c = this.gg(c, d, a, b, k[3], 14, -187363961);
    b = this.gg(b, c, d, a, k[8], 20, 1163531501);
    a = this.gg(a, b, c, d, k[13], 5, -1444681467);
    d = this.gg(d, a, b, c, k[2], 9, -51403784);
    c = this.gg(c, d, a, b, k[7], 14, 1735328473);
    b = this.gg(b, c, d, a, k[12], 20, -1926607734);
    a = this.hh(a, b, c, d, k[5], 4, -378558);
    d = this.hh(d, a, b, c, k[8], 11, -2022574463);
    c = this.hh(c, d, a, b, k[11], 16, 1839030562);
    b = this.hh(b, c, d, a, k[14], 23, -35309556);
    a = this.hh(a, b, c, d, k[1], 4, -1530992060);
    d = this.hh(d, a, b, c, k[4], 11, 1272893353);
    c = this.hh(c, d, a, b, k[7], 16, -155497632);
    b = this.hh(b, c, d, a, k[10], 23, -1094730640);
    a = this.hh(a, b, c, d, k[13], 4, 681279174);
    d = this.hh(d, a, b, c, k[0], 11, -358537222);
    c = this.hh(c, d, a, b, k[3], 16, -722521979);
    b = this.hh(b, c, d, a, k[6], 23, 76029189);
    a = this.hh(a, b, c, d, k[9], 4, -640364487);
    d = this.hh(d, a, b, c, k[12], 11, -421815835);
    c = this.hh(c, d, a, b, k[15], 16, 530742520);
    b = this.hh(b, c, d, a, k[2], 23, -995338651);
    a = this.ii(a, b, c, d, k[0], 6, -198630844);
    d = this.ii(d, a, b, c, k[7], 10, 1126891415);
    c = this.ii(c, d, a, b, k[14], 15, -1416354905);
    b = this.ii(b, c, d, a, k[5], 21, -57434055);
    a = this.ii(a, b, c, d, k[12], 6, 1700485571);
    d = this.ii(d, a, b, c, k[3], 10, -1894986606);
    c = this.ii(c, d, a, b, k[10], 15, -1051523);
    b = this.ii(b, c, d, a, k[1], 21, -2054922799);
    a = this.ii(a, b, c, d, k[8], 6, 1873313359);
    d = this.ii(d, a, b, c, k[15], 10, -30611744);
    c = this.ii(c, d, a, b, k[6], 15, -1560198380);
    b = this.ii(b, c, d, a, k[13], 21, 1309151649);
    a = this.ii(a, b, c, d, k[4], 6, -145523070);
    d = this.ii(d, a, b, c, k[11], 10, -1120210379);
    c = this.ii(c, d, a, b, k[2], 15, 718787259);
    b = this.ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = this.add32(a, x[0]);
    x[1] = this.add32(b, x[1]);
    x[2] = this.add32(c, x[2]);
    x[3] = this.add32(d, x[3]);
  }
  cmn(q, a, b, x, s, t) {
    a = this.add32(this.add32(a, q), this.add32(x, t));
    return this.add32(a << s | a >>> 32 - s, b);
  }
  ff(a, b, c, d, x, s, t) {
    return this.cmn(b & c | ~b & d, a, b, x, s, t);
  }
  gg(a, b, c, d, x, s, t) {
    return this.cmn(b & d | c & ~d, a, b, x, s, t);
  }
  hh(a, b, c, d, x, s, t) {
    return this.cmn(b ^ c ^ d, a, b, x, s, t);
  }
  ii(a, b, c, d, x, s, t) {
    return this.cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md51(s) {
    const n = s.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= s.length; i += 64) {
      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      this.md5cycle(state, tail);
      for (i = 0; i < 16; i++) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    this.md5cycle(state, tail);
    return state;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  rhex(n) {
    const hex_chr = "0123456789abcdef".split("");
    let s = "", j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    }
    return s;
  }
  hex(x) {
    for (let i = 0; i < x.length; i++) {
      x[i] = this.rhex(x[i]);
    }
    return x.join("");
  }
  md5(s) {
    return this.hex(this.md51(s));
  }
  add32(a, b) {
    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(a, b) {
    return a + b & 4294967295;
  }
  add32Compat(x, y) {
    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
};

// packages/ag-charts-enterprise/src/license/licenseManager.ts
function missingOrEmpty(value) {
  return value == null || value.length === 0;
}
var LICENSE_TYPES = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
};
var LICENSING_HELP_URL = "https://ag-grid.com/charts/licensing/";
var _LicenseManager = class _LicenseManager {
  constructor(document2) {
    this.gridContext = false;
    this.watermarkMessage = void 0;
    this.totalMessageLength = 124;
    this.document = document2;
    this.md5 = new MD5();
    this.md5.init();
  }
  validateLicense() {
    const licenseDetails = this.getLicenseDetails(this.licenseKey, this.gridContext);
    const currentLicenseName = `AG ${licenseDetails.currentLicenseType === "BOTH" ? "Grid and " : ""}Charts Enterprise`;
    const suppliedLicenseName = licenseDetails.suppliedLicenseType === void 0 ? "" : `AG ${licenseDetails.suppliedLicenseType === "BOTH" ? "Grid and AG Charts" : licenseDetails.suppliedLicenseType === "GRID" ? "Grid" : "Charts"} Enterprise`;
    if (licenseDetails.missing) {
      if (!this.isWebsiteUrl() || this.isForceWatermark()) {
        this.outputMissingLicenseKey(currentLicenseName);
      }
    } else if (licenseDetails.expired) {
      const gridReleaseDate = _LicenseManager.getChartsReleaseDate();
      const formattedReleaseDate = _LicenseManager.formatDate(gridReleaseDate);
      this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, suppliedLicenseName);
    } else if (!licenseDetails.valid) {
      this.outputInvalidLicenseKey(
        !!licenseDetails.incorrectLicenseType,
        currentLicenseName,
        suppliedLicenseName
      );
    } else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
      this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
    }
  }
  static extractExpiry(license) {
    const restrictionHashed = license.substring(license.lastIndexOf("_") + 1, license.length);
    return new Date(parseInt(_LicenseManager.decode(restrictionHashed), 10));
  }
  static extractLicenseComponents(licenseKey) {
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    if (licenseKey.length <= 32) {
      return { md5: null, license: licenseKey, version: null, isTrial: null };
    }
    const hashStart = cleanedLicenseKey.length - 32;
    const md5 = cleanedLicenseKey.substring(hashStart);
    const license = cleanedLicenseKey.substring(0, hashStart);
    const [version, isTrial, type] = _LicenseManager.extractBracketedInformation(cleanedLicenseKey);
    return { md5, license, version, isTrial, type };
  }
  getLicenseDetails(licenseKey, gridContext = false) {
    const currentLicenseType = "CHARTS";
    if (missingOrEmpty(licenseKey)) {
      return {
        licenseKey,
        valid: false,
        missing: true,
        currentLicenseType
      };
    }
    const chartsReleaseDate = _LicenseManager.getChartsReleaseDate();
    const { md5, license, version, isTrial, type } = _LicenseManager.extractLicenseComponents(licenseKey);
    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
    let trialExpired = void 0;
    let expired = void 0;
    let expiry = null;
    let incorrectLicenseType = false;
    let suppliedLicenseType = void 0;
    function handleTrial() {
      const now = /* @__PURE__ */ new Date();
      trialExpired = expiry < now;
      expired = void 0;
    }
    if (valid) {
      expiry = _LicenseManager.extractExpiry(license);
      valid = !isNaN(expiry.getTime());
      if (valid) {
        expired = chartsReleaseDate > expiry;
        switch (version) {
          case "legacy":
          case "2": {
            valid = false;
            break;
          }
          case "3": {
            if (missingOrEmpty(type)) {
              valid = false;
            } else {
              suppliedLicenseType = type;
              if (type !== LICENSE_TYPES["02"] && type !== LICENSE_TYPES["0102"]) {
                valid = false;
                incorrectLicenseType = true;
              } else if (isTrial) {
                handleTrial();
              }
            }
          }
        }
      }
    }
    if (!valid) {
      return {
        licenseKey,
        valid,
        incorrectLicenseType,
        currentLicenseType,
        suppliedLicenseType
      };
    }
    return {
      licenseKey,
      valid,
      expiry: _LicenseManager.formatDate(expiry),
      expired,
      version,
      isTrial,
      trialExpired,
      invalidLicenseTypeForCombo: gridContext ? suppliedLicenseType !== "BOTH" : void 0,
      incorrectLicenseType,
      currentLicenseType,
      suppliedLicenseType
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    if (!this.document) {
      return "localhost";
    }
    const win = this.document.defaultView || window;
    if (!win) {
      return "localhost";
    }
    const loc = win.location;
    const { hostname = "" } = loc;
    return hostname;
  }
  isForceWatermark() {
    if (!this.document) {
      return false;
    }
    const win = this.document?.defaultView ?? typeof window != "undefined" ? window : void 0;
    if (!win) {
      return false;
    }
    const { pathname } = win.location;
    return pathname ? pathname.indexOf("forceWatermark") !== -1 : false;
  }
  isWebsiteUrl() {
    const hostname = this.getHostname();
    return hostname.match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    const hostname = this.getHostname();
    return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(date) {
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const day = date.getDate();
    const monthIndex = date.getMonth();
    const year = date.getFullYear();
    return day + " " + monthNames[monthIndex] + " " + year;
  }
  static getChartsReleaseDate() {
    return new Date(parseInt(_LicenseManager.decode(_LicenseManager.RELEASE_INFORMATION), 10));
  }
  static decode(input) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let t = "";
    let n, r, i;
    let s, o, u, a;
    let f = 0;
    const e = input.replace(/[^A-Za-z0-9+/=]/g, "");
    while (f < e.length) {
      s = keystr.indexOf(e.charAt(f++));
      o = keystr.indexOf(e.charAt(f++));
      u = keystr.indexOf(e.charAt(f++));
      a = keystr.indexOf(e.charAt(f++));
      n = s << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = _LicenseManager.utf8_decode(t);
    return t;
  }
  static utf8_decode(input) {
    input = input.replace(/rn/g, "n");
    let t = "";
    for (let n = 0; n < input.length; n++) {
      const r = input.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }
  setLicenseKey(licenseKey, gridContext = false) {
    this.gridContext = gridContext;
    this.licenseKey = licenseKey;
  }
  static extractBracketedInformation(licenseKey) {
    if (!licenseKey.includes("[")) {
      return ["legacy", false, void 0];
    }
    const matches = licenseKey.match(/\[(.*?)\]/g).map((match) => match.replace("[", "").replace("]", ""));
    if (!matches || matches.length === 0) {
      return ["legacy", false, void 0];
    }
    const isTrial = matches.filter((match) => match === "TRIAL").length === 1;
    const rawVersion = matches.filter((match) => match.indexOf("v") === 0)[0];
    const version = rawVersion ? rawVersion.replace("v", "") : "legacy";
    const type = LICENSE_TYPES[matches.filter((match) => LICENSE_TYPES[match])[0]];
    return [version, isTrial, type];
  }
  centerPadAndOutput(input) {
    const paddingRequired = this.totalMessageLength - input.length;
    console.error(input.padStart(paddingRequired / 2 + input.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(input, padding = "*", terminateWithPadding = "") {
    console.error(
      input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding
    );
  }
  outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      if (incorrectLicenseType) {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Incompatible License Key ");
        this.padAndOutput(
          `* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`,
          " ",
          "*"
        );
        this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      } else {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Invalid License Key ");
        this.padAndOutput(`* Your license key is not valid.`, " ", "*");
        this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      }
    }
    this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Trial Period Expired. ");
      this.padAndOutput(
        `* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" License Key Not Found ");
      this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, " ", "*");
      this.padAndOutput(
        "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
        " ",
        "*"
      );
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Incompatible Software Version ");
      this.padAndOutput(
        `* Your license key works with versions of ${currentLicenseName} released before ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, " ", "*");
      this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "License Expired";
  }
};
_LicenseManager.RELEASE_INFORMATION = "MTcyNjU1NzQ0MzEwNw==";
var LicenseManager = _LicenseManager;

// packages/ag-charts-enterprise/src/license/watermark.ts
import { _ModuleSupport as _ModuleSupport89 } from "ag-charts-community";
var { createElement: createElement8 } = _ModuleSupport89;
function injectWatermark(domManager, text2) {
  const element = domManager.addChild("canvas-overlay", "watermark");
  const textElement = createElement8("span");
  textElement.innerText = text2;
  element.addEventListener("animationend", () => {
    domManager.removeChild("canvas-overlay", "watermark");
    domManager.removeStyles("watermark");
  });
  element.classList.add("ag-watermark");
  element.appendChild(textElement);
}

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotModule.ts
import { _Theme as _Theme10, _Util as _Util61 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeries.ts
import { _ModuleSupport as _ModuleSupport92, _Scale as _Scale8, _Scene as _Scene40, _Util as _Util60 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/box-plot/blotPlotUtil.ts
function prepareBoxPlotFromTo(isVertical) {
  const from = isVertical ? { scalingX: 1, scalingY: 0 } : { scalingX: 0, scalingY: 1 };
  const to = { scalingX: 1, scalingY: 1 };
  return { from, to };
}
function resetBoxPlotSelectionsScalingCenterFn(isVertical) {
  return (_node, datum) => {
    if (isVertical) {
      return { scalingCenterY: datum.scaledValues.medianValue };
    }
    return { scalingCenterX: datum.scaledValues.medianValue };
  };
}

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotGroup.ts
import { _ModuleSupport as _ModuleSupport90, _Scene as _Scene39, _Util as _Util59 } from "ag-charts-community";
var { ScalableGroup, Rect: Rect3, Line: Line3, BBox: BBox5, Selection: Selection2 } = _Scene39;
var { Logger: Logger6 } = _Util59;
var BoxPlotGroup = class extends ScalableGroup {
  constructor() {
    super();
    this.append([
      new Rect3({ tag: 0 /* Box */ }),
      new Rect3({ tag: 0 /* Box */ }),
      new Rect3({ tag: 2 /* Outline */ }),
      new Rect3({ tag: 1 /* Median */ }),
      new Line3({ tag: 3 /* Whisker */ }),
      new Line3({ tag: 3 /* Whisker */ }),
      new Line3({ tag: 4 /* Cap */ }),
      new Line3({ tag: 4 /* Cap */ })
    ]);
  }
  updateDatumStyles(datum, activeStyles, isVertical, isReversedValueAxis) {
    const {
      bandwidth,
      scaledValues: { xValue: axisValue, medianValue }
    } = datum;
    let { minValue, q1Value, q3Value, maxValue } = datum.scaledValues;
    if (isVertical && !isReversedValueAxis || !isVertical && isReversedValueAxis) {
      [maxValue, q3Value, q1Value, minValue] = [minValue, q1Value, q3Value, maxValue];
    }
    const position = (x, y, width, height) => isVertical ? { y: x, x: y, width: height, height: width } : { x, y, width, height };
    const hPosition = (x1, x2, y) => isVertical ? { y1: x1, y2: x2, x: y } : { x1, x2, y };
    const vPosition = (x, y1, y2) => isVertical ? { x1: y1, x2: y2, y: x } : { x, y1, y2 };
    const bbox = (x, y, width, height) => {
      ({ x, y, width, height } = position(x, y, width, height));
      return new BBox5(x, y, width, height);
    };
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      cap,
      whisker: whiskerStyles
    } = activeStyles;
    const selection = Selection2.select(this, Rect3);
    const boxes = selection.selectByTag(0 /* Box */);
    const [outline] = selection.selectByTag(2 /* Outline */);
    const [median] = selection.selectByTag(1 /* Median */);
    const whiskers = selection.selectByTag(3 /* Whisker */);
    const caps = selection.selectByTag(4 /* Cap */);
    if (whiskerStyles.strokeWidth > bandwidth) {
      whiskerStyles.strokeWidth = bandwidth;
    }
    const boxesPosition = position(q1Value, axisValue, q3Value - q1Value, bandwidth);
    outline.setProperties(boxesPosition);
    boxes[0].setProperties(boxesPosition);
    boxes[0].setProperties({
      cornerRadius,
      clipBBox: bbox(q1Value, axisValue, Math.round(medianValue - q1Value + strokeWidth / 2), bandwidth)
    });
    boxes[1].setProperties(boxesPosition);
    boxes[1].setProperties({
      cornerRadius,
      clipBBox: bbox(
        Math.round(medianValue - strokeWidth / 2),
        axisValue,
        Math.floor(q3Value - medianValue + strokeWidth / 2),
        bandwidth
      )
    });
    const medianStart = Math.max(Math.round(medianValue - strokeWidth / 2), q1Value + strokeWidth);
    const medianEnd = Math.min(Math.round(medianValue + strokeWidth / 2), q3Value - strokeWidth);
    median.setProperties(boxesPosition);
    median.setProperties({
      visible: medianStart < medianEnd,
      cornerRadius,
      clipBBox: bbox(
        medianStart,
        axisValue + strokeWidth,
        medianEnd - medianStart,
        Math.max(0, bandwidth - strokeWidth * 2)
      )
    });
    const capStart = Math.floor(axisValue + bandwidth * (1 - cap.lengthRatio) / 2);
    const capEnd = Math.ceil(axisValue + bandwidth * (1 + cap.lengthRatio) / 2);
    caps[0].setProperties(vPosition(minValue, capStart, capEnd));
    caps[1].setProperties(vPosition(maxValue, capStart, capEnd));
    whiskers[0].setProperties(
      hPosition(
        Math.round(minValue + whiskerStyles.strokeWidth / 2),
        q1Value,
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    whiskers[1].setProperties(
      hPosition(
        q3Value,
        Math.round(maxValue - whiskerStyles.strokeWidth / 2),
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    for (const element of boxes) {
      element.setProperties({ fill, fillOpacity, strokeWidth: strokeWidth * 2, strokeOpacity: 0 });
    }
    median.setProperties({ fill: stroke2, fillOpacity: strokeOpacity, strokeWidth: 0 });
    for (const element of [...whiskers, ...caps]) {
      element.setProperties(whiskerStyles);
    }
    outline.setProperties({
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      fillOpacity: 0
    });
  }
  distanceSquared(x, y) {
    const nodes = Selection2.selectByClass(this, Rect3, Line3);
    return _ModuleSupport90.nearestSquared(x, y, nodes).distanceSquared;
  }
  get midPoint() {
    const datum = this.datum;
    if (datum.midPoint === void 0) {
      Logger6.error("BoxPlotGroup.datum.midPoint is undefined");
      return { x: NaN, y: NaN };
    }
    return datum.midPoint;
  }
};

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport91 } from "ag-charts-community";
var {
  BaseProperties: BaseProperties17,
  AbstractBarSeriesProperties,
  SeriesTooltip,
  Validate: Validate43,
  COLOR_STRING: COLOR_STRING8,
  FUNCTION: FUNCTION5,
  LINE_DASH: LINE_DASH5,
  OBJECT: OBJECT16,
  POSITIVE_NUMBER: POSITIVE_NUMBER10,
  RATIO: RATIO13,
  STRING: STRING20,
  mergeDefaults: mergeDefaults3
} = _ModuleSupport91;
var BoxPlotSeriesCap = class extends BaseProperties17 {
  constructor() {
    super(...arguments);
    this.lengthRatio = 0.5;
  }
};
__decorateClass([
  Validate43(RATIO13)
], BoxPlotSeriesCap.prototype, "lengthRatio", 2);
var BoxPlotSeriesWhisker = class extends BaseProperties17 {
};
__decorateClass([
  Validate43(COLOR_STRING8, { optional: true })
], BoxPlotSeriesWhisker.prototype, "stroke", 2);
__decorateClass([
  Validate43(POSITIVE_NUMBER10)
], BoxPlotSeriesWhisker.prototype, "strokeWidth", 2);
__decorateClass([
  Validate43(RATIO13)
], BoxPlotSeriesWhisker.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate43(LINE_DASH5, { optional: true })
], BoxPlotSeriesWhisker.prototype, "lineDash", 2);
__decorateClass([
  Validate43(POSITIVE_NUMBER10)
], BoxPlotSeriesWhisker.prototype, "lineDashOffset", 2);
var BoxPlotSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.cap = new BoxPlotSeriesCap();
    this.whisker = new BoxPlotSeriesWhisker();
    this.tooltip = new SeriesTooltip();
    // Internal: Set by paletteFactory.
    this.backgroundFill = "white";
  }
  toJson() {
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    const properties = super.toJson();
    properties.whisker = mergeDefaults3(properties.whisker, {
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return properties;
  }
};
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "minKey", 2);
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "q1Key", 2);
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "medianKey", 2);
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "q3Key", 2);
__decorateClass([
  Validate43(STRING20)
], BoxPlotSeriesProperties.prototype, "maxKey", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "minName", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "q1Name", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "medianName", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "q3Name", 2);
__decorateClass([
  Validate43(STRING20, { optional: true })
], BoxPlotSeriesProperties.prototype, "maxName", 2);
__decorateClass([
  Validate43(COLOR_STRING8, { optional: true })
], BoxPlotSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate43(RATIO13)
], BoxPlotSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate43(COLOR_STRING8)
], BoxPlotSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate43(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate43(RATIO13)
], BoxPlotSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate43(LINE_DASH5)
], BoxPlotSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate43(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate43(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate43(FUNCTION5, { optional: true })
], BoxPlotSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate43(OBJECT16)
], BoxPlotSeriesProperties.prototype, "cap", 2);
__decorateClass([
  Validate43(OBJECT16)
], BoxPlotSeriesProperties.prototype, "whisker", 2);
__decorateClass([
  Validate43(OBJECT16)
], BoxPlotSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate43(COLOR_STRING8)
], BoxPlotSeriesProperties.prototype, "backgroundFill", 2);

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeries.ts
var {
  extractDecoratedProperties,
  fixNumericExtent: fixNumericExtent2,
  keyProperty,
  mergeDefaults: mergeDefaults4,
  SeriesNodePickMode,
  SMALLEST_KEY_INTERVAL,
  valueProperty: valueProperty3,
  diff,
  animationValidation,
  convertValuesToScaleByDefs,
  computeBarFocusBounds
} = _ModuleSupport92;
var { motion } = _Scene40;
var { ContinuousScale: ContinuousScale2 } = _Scale8;
var { Color: Color4 } = _Util60;
var BoxPlotSeriesNodeEvent = class extends _ModuleSupport92.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.minKey = series.properties.minKey;
    this.q1Key = series.properties.q1Key;
    this.medianKey = series.properties.medianKey;
    this.q3Key = series.properties.q3Key;
    this.maxKey = series.properties.maxKey;
  }
};
var BoxPlotSeries = class extends _ModuleSupport92.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],
      directionKeys: {
        x: ["xKey"],
        y: ["medianKey", "q1Key", "q3Key", "minKey", "maxKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["medianName", "q1Name", "q3Name", "minName", "maxName"]
      },
      pathsPerSeries: [],
      hasHighlightedLabels: true
    });
    this.properties = new BoxPlotSeriesProperties();
    this.NodeEvent = BoxPlotSeriesNodeEvent;
  }
  async processData(dataController) {
    if (!this.properties.isValid() || !this.visible)
      return;
    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (animationEnabled && this.processedData) {
      extraProps.push(diff(this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation());
    }
    const { processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty3(minKey, yScaleType, { id: `minValue` }),
        valueProperty3(q1Key, yScaleType, { id: `q1Value` }),
        valueProperty3(medianKey, yScaleType, { id: `medianValue` }),
        valueProperty3(q3Key, yScaleType, { id: `q3Value` }),
        valueProperty3(maxKey, yScaleType, { id: `maxValue` }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    if (direction === this.getBarDirection()) {
      const minValues = dataModel.getDomain(this, `minValue`, "value", processedData);
      const maxValues = dataModel.getDomain(this, `maxValue`, "value", processedData);
      return fixNumericExtent2([Math.min(...minValues), Math.max(...maxValues)]);
    }
    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = processedData.domain.keys[index];
    if (def.type === "key" && def.valueType === "category") {
      return keys;
    }
    return this.padBandExtent(keys);
  }
  async createNodeData() {
    const { visible, dataModel } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(dataModel && xAxis && yAxis)) {
      return;
    }
    const { xKey, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = this.properties;
    const nodeData = [];
    const defs = dataModel.resolveProcessedDataDefsByIds(this, [
      "xValue",
      "minValue",
      "q1Value",
      `medianValue`,
      `q3Value`,
      `maxValue`
    ]);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale2.is(xAxis.scale) ? barWidth * -0.5 : 0;
    const { groupScale, processedData } = this;
    const isVertical = this.isVertical();
    const context = {
      itemId: xKey,
      nodeData,
      labelData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!visible)
      return context;
    processedData?.data.forEach(({ datum, keys, values }) => {
      const { xValue, minValue, q1Value, medianValue, q3Value, maxValue } = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
      if ([minValue, q1Value, medianValue, q3Value, maxValue].some((value) => typeof value !== "number") || minValue > q1Value || q1Value > medianValue || medianValue > q3Value || q3Value > maxValue) {
        return;
      }
      const scaledValues = convertValuesToScaleByDefs({
        defs,
        values: {
          xValue,
          minValue,
          q1Value,
          medianValue,
          q3Value,
          maxValue
        },
        xAxis,
        yAxis
      });
      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;
      const bandwidth = Math.round(barWidth);
      const height = Math.abs(scaledValues.q3Value - scaledValues.q1Value);
      const midX = scaledValues.xValue + bandwidth / 2;
      const midY = Math.min(scaledValues.q3Value, scaledValues.q1Value) + height / 2;
      const midPoint = {
        x: isVertical ? midX : midY,
        y: isVertical ? midY : midX
      };
      let focusRect;
      if (isVertical) {
        focusRect = {
          x: midPoint.x - bandwidth / 2,
          y: scaledValues.minValue,
          width: bandwidth,
          height: scaledValues.maxValue - scaledValues.minValue
        };
      } else {
        focusRect = {
          x: scaledValues.minValue,
          y: midPoint.y - bandwidth / 2,
          width: scaledValues.maxValue - scaledValues.minValue,
          height: bandwidth
        };
      }
      nodeData.push({
        series: this,
        itemId: xValue,
        datum,
        xKey,
        bandwidth,
        scaledValues,
        cap,
        whisker,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        midPoint,
        focusRect
      });
    });
    return context;
  }
  getLegendData(legendType) {
    const { id, data } = this;
    const {
      xKey,
      yName,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      showInLegend,
      legendItemName,
      visible
    } = this.properties;
    if (!showInLegend || !data?.length || !xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible,
        label: {
          text: legendItemName ?? yName ?? id
        },
        symbols: [{ marker: { fill, fillOpacity, stroke: stroke2, strokeOpacity, strokeWidth } }],
        legendItemName
      }
    ];
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      minKey,
      q1Key,
      medianKey,
      q3Key,
      maxKey,
      xName,
      yName,
      minName,
      q1Name,
      medianName,
      q3Name,
      maxName,
      tooltip,
      fill
    } = this.properties;
    const { datum, itemId } = nodeDatum;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!xAxis || !yAxis || !this.properties.isValid())
      return _ModuleSupport92.EMPTY_TOOLTIP_CONTENT;
    const title = _Util60.sanitizeHtml(yName);
    const contentData = [
      [xKey, xName, xAxis],
      [minKey, minName, yAxis],
      [q1Key, q1Name, yAxis],
      [medianKey, medianName, yAxis],
      [q3Key, q3Name, yAxis],
      [maxKey, maxName, yAxis]
    ];
    const content = contentData.map(([key, name, axis]) => _Util60.sanitizeHtml(`${name ?? key}: ${axis.formatDatum(datum[key])}`)).join(title ? "<br/>" : ", ");
    const { fill: formatFill } = this.getFormattedStyles(nodeDatum);
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: fill },
      {
        seriesId: this.id,
        itemId,
        datum,
        fill,
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey,
        xName,
        minName,
        q1Name,
        medianName,
        q3Name,
        maxName,
        yName,
        title,
        color: fill ?? formatFill
      }
    );
  }
  animateEmptyUpdateReady({
    datumSelection
  }) {
    const isVertical = this.isVertical();
    const { from, to } = prepareBoxPlotFromTo(isVertical);
    motion.resetMotion([datumSelection], resetBoxPlotSelectionsScalingCenterFn(isVertical));
    motion.staticFromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], from, to, {
      phase: "initial"
    });
  }
  isLabelEnabled() {
    return false;
  }
  async updateDatumSelection(opts) {
    const data = opts.nodeData ?? [];
    return opts.datumSelection.update(data);
  }
  async updateDatumNodes({
    datumSelection,
    isHighlight: highlighted
  }) {
    const isVertical = this.isVertical();
    const isReversedValueAxis = this.getValueAxis()?.isReversed();
    datumSelection.each((boxPlotGroup, nodeDatum) => {
      let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
      if (highlighted) {
        activeStyles = mergeDefaults4(this.properties.highlightStyle.item, activeStyles);
      }
      const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;
      activeStyles.whisker = mergeDefaults4(activeStyles.whisker, {
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      });
      boxPlotGroup.updateDatumStyles(
        nodeDatum,
        activeStyles,
        isVertical,
        isReversedValueAxis
      );
    });
  }
  async updateLabelNodes(_opts) {
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  nodeFactory() {
    return new BoxPlotGroup();
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache },
      properties
    } = this;
    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey, itemStyler, backgroundFill, cornerRadius } = properties;
    const { datum, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = nodeDatum;
    let fill;
    let fillOpacity;
    const useFakeFill = true;
    if (useFakeFill) {
      fill = nodeDatum.fill;
      fillOpacity = properties.fillOpacity;
    } else {
      try {
        fill = Color4.mix(
          Color4.fromString(backgroundFill),
          Color4.fromString(nodeDatum.fill),
          properties.fillOpacity
        ).toString();
      } catch {
        fill = nodeDatum.fill;
      }
      fillOpacity = void 0;
    }
    const activeStyles = {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      cap: extractDecoratedProperties(cap),
      whisker: extractDecoratedProperties(whisker)
    };
    if (itemStyler) {
      const formatStyles = callbackCache.call(itemStyler, {
        datum,
        seriesId,
        highlighted,
        ...activeStyles,
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey
      });
      if (formatStyles) {
        return mergeDefaults4(formatStyles, activeStyles);
      }
    }
    return activeStyles;
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    return computeBarFocusBounds(
      this.contextNodeData?.nodeData[datumIndex].focusRect,
      this.contentGroup,
      seriesRect
    );
  }
};
BoxPlotSeries.className = "BoxPlotSeries";
BoxPlotSeries.type = "box-plot";

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotThemes.ts
import { _Theme as _Theme9 } from "ag-charts-community";
var BOX_PLOT_SERIES_THEME = {
  series: {
    direction: "vertical",
    // @todo(AG-11876) Use fillOpacity to match area, range area, radar area, chord, and sankey series
    // fillOpacity: 0.3,
    strokeWidth: 2
  },
  axes: {
    [_Theme9.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [_Theme9.CARTESIAN_AXIS_TYPE.CATEGORY]: {
      groupPaddingInner: 0.2,
      crosshair: {
        enabled: false,
        snap: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotModule.ts
var { Color: Color5 } = _Util61;
var BoxPlotModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "box-plot",
  moduleFactory: (ctx) => new BoxPlotSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme10.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme10.POSITION.LEFT
    },
    {
      type: _Theme10.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme10.POSITION.BOTTOM
    }
  ],
  themeTemplate: BOX_PLOT_SERIES_THEME,
  groupable: true,
  paletteFactory: ({ takeColors, themeTemplateParameters }) => {
    const themeBackgroundColor = themeTemplateParameters.get(_Theme10.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) ?? "white";
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    let fakeFill;
    try {
      fakeFill = Color5.mix(Color5.fromString(backgroundFill), Color5.fromString(fill), 0.3).toString();
    } catch {
      fakeFill = fill;
    }
    return {
      fill: fakeFill,
      stroke: stroke2,
      backgroundFill
    };
  },
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};

// packages/ag-charts-enterprise/src/series/bullet/bulletModule.ts
import { _Theme as _Theme12 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/bullet/bulletSeries.ts
import { _ModuleSupport as _ModuleSupport94, _Scene as _Scene41, _Util as _Util62 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/bullet/bulletSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport93 } from "ag-charts-community";
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties2,
  BaseProperties: BaseProperties18,
  PropertiesArray: PropertiesArray2,
  SeriesTooltip: SeriesTooltip2,
  Validate: Validate44,
  ARRAY: ARRAY3,
  COLOR_STRING: COLOR_STRING9,
  LINE_DASH: LINE_DASH6,
  OBJECT: OBJECT17,
  POSITIVE_NUMBER: POSITIVE_NUMBER11,
  RATIO: RATIO14,
  STRING: STRING21
} = _ModuleSupport93;
var TargetStyle = class extends BaseProperties18 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.lengthRatio = 0.75;
  }
};
__decorateClass([
  Validate44(COLOR_STRING9)
], TargetStyle.prototype, "fill", 2);
__decorateClass([
  Validate44(RATIO14)
], TargetStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate44(COLOR_STRING9)
], TargetStyle.prototype, "stroke", 2);
__decorateClass([
  Validate44(POSITIVE_NUMBER11)
], TargetStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate44(RATIO14)
], TargetStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate44(LINE_DASH6)
], TargetStyle.prototype, "lineDash", 2);
__decorateClass([
  Validate44(POSITIVE_NUMBER11)
], TargetStyle.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate44(RATIO14)
], TargetStyle.prototype, "lengthRatio", 2);
var BulletScale = class extends BaseProperties18 {
};
__decorateClass([
  Validate44(POSITIVE_NUMBER11, { optional: true })
], BulletScale.prototype, "max", 2);
var BulletColorRange = class extends BaseProperties18 {
  constructor() {
    super(...arguments);
    this.color = "lightgrey";
  }
};
__decorateClass([
  Validate44(COLOR_STRING9)
], BulletColorRange.prototype, "color", 2);
__decorateClass([
  Validate44(POSITIVE_NUMBER11, { optional: true })
], BulletColorRange.prototype, "stop", 2);
var BulletSeriesProperties = class extends AbstractBarSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.widthRatio = 0.5;
    this.colorRanges = new PropertiesArray2(BulletColorRange);
    this.target = new TargetStyle();
    this.scale = new BulletScale();
    this.tooltip = new SeriesTooltip2();
    // Internal: Set by paletteFactory.
    this.backgroundFill = "white";
  }
};
__decorateClass([
  Validate44(STRING21)
], BulletSeriesProperties.prototype, "valueKey", 2);
__decorateClass([
  Validate44(STRING21, { optional: true })
], BulletSeriesProperties.prototype, "valueName", 2);
__decorateClass([
  Validate44(STRING21, { optional: true })
], BulletSeriesProperties.prototype, "targetKey", 2);
__decorateClass([
  Validate44(STRING21, { optional: true })
], BulletSeriesProperties.prototype, "targetName", 2);
__decorateClass([
  Validate44(COLOR_STRING9)
], BulletSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate44(RATIO14)
], BulletSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate44(COLOR_STRING9)
], BulletSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate44(POSITIVE_NUMBER11)
], BulletSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate44(RATIO14)
], BulletSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate44(LINE_DASH6)
], BulletSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate44(POSITIVE_NUMBER11)
], BulletSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate44(RATIO14)
], BulletSeriesProperties.prototype, "widthRatio", 2);
__decorateClass([
  Validate44(ARRAY3.restrict({ minLength: 0 }))
], BulletSeriesProperties.prototype, "colorRanges", 2);
__decorateClass([
  Validate44(OBJECT17)
], BulletSeriesProperties.prototype, "target", 2);
__decorateClass([
  Validate44(OBJECT17)
], BulletSeriesProperties.prototype, "scale", 2);
__decorateClass([
  Validate44(OBJECT17)
], BulletSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate44(COLOR_STRING9)
], BulletSeriesProperties.prototype, "backgroundFill", 2);

// packages/ag-charts-enterprise/src/series/bullet/bulletSeries.ts
var {
  animationValidation: animationValidation2,
  collapsedStartingBarPosition,
  diff: diff2,
  keyProperty: keyProperty2,
  partialAssign: partialAssign2,
  prepareBarAnimationFunctions,
  resetBarSelectionsFn,
  seriesLabelFadeInAnimation,
  valueProperty: valueProperty4,
  createDatumId,
  computeBarFocusBounds: computeBarFocusBounds2
} = _ModuleSupport94;
var { fromToMotion } = _Scene41.motion;
var { sanitizeHtml, Color: Color6 } = _Util62;
var STYLING_KEYS = [
  "fill",
  "fillOpacity",
  "stroke",
  "strokeWidth",
  "strokeOpacity",
  "lineDash",
  "lineDashOffset"
];
var BulletSeries = class extends _ModuleSupport94.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: { y: ["targetKey", "valueKey"] },
      directionNames: { y: ["targetName", "valueName"] },
      pickModes: [
        _ModuleSupport94.SeriesNodePickMode.NEAREST_NODE,
        _ModuleSupport94.SeriesNodePickMode.EXACT_SHAPE_MATCH
      ],
      hasHighlightedLabels: true,
      animationResetFns: {
        datum: resetBarSelectionsFn
      }
    });
    this.properties = new BulletSeriesProperties();
    this.normalizedColorRanges = [];
    this.colorRangesGroup = new _Scene41.Group({ name: `${this.id}-colorRanges` });
    this.colorRangesSelection = _Scene41.Selection.select(this.colorRangesGroup, _Scene41.Rect, false);
    this.rootGroup.append(this.colorRangesGroup);
    this.targetLinesSelection = _Scene41.Selection.select(this.annotationGroup, _Scene41.Line, false);
  }
  destroy() {
    this.rootGroup.removeChild(this.colorRangesGroup);
    super.destroy();
  }
  async processData(dataController) {
    if (!this.properties.isValid() || !this.data || !this.visible)
      return;
    const { valueKey, targetKey } = this.properties;
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (targetKey !== void 0) {
      extraProps.push(valueProperty4(targetKey, yScaleType, { id: "target" }));
    }
    if (!this.ctx.animationManager.isSkipped()) {
      if (this.processedData !== void 0) {
        extraProps.push(diff2(this.processedData));
      }
      extraProps.push(animationValidation2());
    }
    await this.requestDataModel(dataController, this.data.slice(0, 1), {
      props: [
        keyProperty2(valueKey, xScaleType, { id: "xValue" }),
        valueProperty4(valueKey, yScaleType, { id: "value" }),
        ...extraProps
      ],
      groupByKeys: true
    });
    this.animationState.transition("updateData");
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  getMaxValue() {
    return Math.max(...this.getValueAxis()?.dataDomain.domain ?? [0]);
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return [];
    }
    const { valueKey, targetKey, valueName, scale } = this.properties;
    if (direction === this.getCategoryDirection()) {
      return [valueName ?? valueKey];
    }
    if (direction == this.getValueAxis()?.direction) {
      const valueDomain = dataModel.getDomain(this, "value", "value", processedData);
      const targetDomain = targetKey === void 0 ? [] : dataModel.getDomain(this, "target", "value", processedData);
      return [0, scale.max ?? Math.max(...valueDomain, ...targetDomain)];
    }
    throw new Error(`unknown direction ${direction}`);
  }
  getKeys(direction) {
    if (direction === this.getBarDirection()) {
      return [this.properties.valueKey];
    }
    return super.getKeys(direction);
  }
  async createNodeData() {
    const { dataModel, processedData } = this;
    const {
      valueKey,
      targetKey,
      widthRatio,
      target: { lengthRatio }
    } = this.properties;
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    if (!valueKey || !dataModel || !processedData || !xScale || !yScale)
      return;
    if (widthRatio === void 0 || lengthRatio === void 0)
      return;
    const multiplier = xScale.bandwidth ?? NaN;
    const maxValue = this.getMaxValue();
    const valueIndex = dataModel.resolveProcessedDataIndexById(this, "value");
    const targetIndex = targetKey === void 0 ? NaN : dataModel.resolveProcessedDataIndexById(this, "target");
    const context = {
      itemId: valueKey,
      nodeData: [],
      labelData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!this.visible)
      return context;
    for (const { datum, values } of processedData.data) {
      if (!Array.isArray(datum) || datum.length < 1) {
        continue;
      }
      if (values[0][valueIndex] < 0) {
        _Util62.Logger.warnOnce("negative values are not supported, clipping to 0.");
      }
      const xValue = this.properties.valueName ?? this.properties.valueKey;
      const yValue = Math.min(maxValue, Math.max(0, values[0][valueIndex]));
      const y = yScale.convert(yValue);
      const barWidth = widthRatio * multiplier;
      const bottomY = yScale.convert(0);
      const barAlongX = this.getBarDirection() === _ModuleSupport94.ChartAxisDirection.X;
      const rect = {
        x: multiplier * (1 - widthRatio) / 2,
        y: Math.min(y, bottomY),
        width: barWidth,
        height: Math.abs(bottomY - y)
      };
      if (barAlongX) {
        [rect.x, rect.y, rect.width, rect.height] = [rect.y, rect.x, rect.height, rect.width];
      }
      let target;
      if (values[0][targetIndex] < 0) {
        _Util62.Logger.warnOnce("negative targets are not supported, ignoring.");
      }
      if (this.properties.targetKey && values[0][targetIndex] >= 0) {
        const targetLineLength = lengthRatio * multiplier;
        const targetValue = Math.min(maxValue, values[0][targetIndex]);
        if (!isNaN(targetValue) && targetValue !== void 0) {
          const convertedY = yScale.convert(targetValue);
          let x1 = multiplier * (1 - lengthRatio) / 2;
          let x2 = x1 + targetLineLength;
          let [y1, y2] = [convertedY, convertedY];
          if (barAlongX) {
            [x1, x2, y1, y2] = [y1, y2, x1, x2];
          }
          target = { value: targetValue, x1, x2, y1, y2 };
        }
      }
      const nodeData = {
        series: this,
        datum: datum[0],
        xKey: valueKey,
        xValue,
        yKey: valueKey,
        yValue,
        cumulativeValue: yValue,
        target,
        ...rect,
        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
        opacity: 1
      };
      context.nodeData.push(nodeData);
    }
    const sortedRanges = [...this.getColorRanges()].sort((a, b) => (a.stop ?? maxValue) - (b.stop ?? maxValue));
    let start = 0;
    this.normalizedColorRanges = sortedRanges.map((item) => {
      const stop = Math.min(maxValue, item.stop ?? Infinity);
      const result = { color: item.color, start, stop };
      start = stop;
      return result;
    });
    return context;
  }
  getColorRanges() {
    const { colorRanges, fill, backgroundFill } = this.properties;
    if (colorRanges !== void 0 && colorRanges.length > 0) {
      return colorRanges;
    }
    const defaultColorRange = new BulletColorRange();
    try {
      defaultColorRange.color = Color6.mix(
        Color6.fromString(fill),
        Color6.fromString(backgroundFill),
        0.7
      ).toString();
    } catch {
      defaultColorRange.color = fill;
    }
    return [defaultColorRange];
  }
  getLegendData(_legendType) {
    return [];
  }
  getTooltipHtml(nodeDatum) {
    const { valueKey, valueName, targetKey, targetName } = this.properties;
    const axis = this.getValueAxis();
    const { yValue: valueValue, target: { value: targetValue } = { value: void 0 }, datum, itemId } = nodeDatum;
    if (valueKey === void 0 || valueValue === void 0 || axis === void 0) {
      return _ModuleSupport94.EMPTY_TOOLTIP_CONTENT;
    }
    const makeLine = (key, name, value) => {
      const nameString = sanitizeHtml(name ?? key);
      const valueString = sanitizeHtml(axis.formatDatum(value));
      return `<b>${nameString}</b>: ${valueString}`;
    };
    const title = void 0;
    const content = targetKey === void 0 || targetValue === void 0 ? makeLine(valueKey, valueName, valueValue) : `${makeLine(valueKey, valueName, valueValue)}<br/>${makeLine(targetKey, targetName, targetValue)}`;
    return this.properties.tooltip.toTooltipHtml(
      { title, content, backgroundColor: this.properties.fill },
      { datum, itemId, title, seriesId: this.id, valueKey, valueName, targetKey, targetName, color: void 0 }
    );
  }
  isLabelEnabled() {
    return false;
  }
  nodeFactory() {
    return new _Scene41.Rect();
  }
  async updateDatumSelection(opts) {
    this.targetLinesSelection.update(opts.nodeData, void 0, void 0);
    return opts.datumSelection.update(opts.nodeData, void 0, void 0);
  }
  async updateDatumNodes(opts) {
    for (const { node } of opts.datumSelection) {
      const style = this.properties;
      partialAssign2(STYLING_KEYS, node, style);
    }
    for (const { node, datum } of this.targetLinesSelection) {
      if (datum.target === void 0) {
        node.visible = false;
      } else {
        const style = this.properties.target;
        partialAssign2(["x1", "x2", "y1", "y2"], node, datum.target);
        partialAssign2(STYLING_KEYS, node, style);
      }
    }
  }
  async updateColorRanges() {
    const valAxis = this.getValueAxis();
    const catAxis = this.getCategoryAxis();
    if (!valAxis || !catAxis)
      return;
    const [min, max] = [0, Math.max(...catAxis.scale.range)];
    const computeRect = this.getBarDirection() === _ModuleSupport94.ChartAxisDirection.Y ? (rect, colorRange) => {
      rect.x = min;
      rect.y = valAxis.scale.convert(colorRange.stop);
      rect.height = valAxis.scale.convert(colorRange.start) - rect.y;
      rect.width = max;
    } : (rect, colorRange) => {
      rect.x = valAxis.scale.convert(colorRange.start);
      rect.y = min;
      rect.height = max;
      rect.width = valAxis.scale.convert(colorRange.stop) - rect.x;
    };
    this.colorRangesSelection.update(this.normalizedColorRanges);
    for (const { node, datum } of this.colorRangesSelection) {
      computeRect(node, datum);
      node.fill = datum.color;
    }
  }
  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    await super.updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled);
    await this.updateColorRanges();
  }
  async updateLabelSelection(opts) {
    return opts.labelSelection;
  }
  async updateLabelNodes(_opts) {
  }
  animateEmptyUpdateReady(data) {
    const { datumSelection, annotationSelections } = data;
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection, annotationSelections } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = this.processedData?.reduced?.diff;
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => createDatumId(datum.xValue),
      dataDiff
    );
    const hasMotion = dataDiff?.changed ?? true;
    if (hasMotion) {
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    return computeBarFocusBounds2(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};

// packages/ag-charts-enterprise/src/series/bullet/bulletThemes.ts
import { _Theme as _Theme11 } from "ag-charts-community";
var BULLET_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: 0,
    strokeOpacity: 1,
    fillOpacity: 1,
    widthRatio: 0.5,
    target: {
      strokeWidth: 3,
      strokeOpacity: 1,
      lengthRatio: 0.75
    }
  },
  axes: {
    [_Theme11.CARTESIAN_AXIS_TYPE.NUMBER]: {
      nice: false,
      crosshair: {
        enabled: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/bullet/bulletModule.ts
var BulletModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "bullet",
  solo: true,
  moduleFactory: (ctx) => new BulletSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme12.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme12.POSITION.LEFT
    },
    {
      type: _Theme12.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme12.POSITION.BOTTOM
    }
  ],
  themeTemplate: BULLET_SERIES_THEME,
  swapDefaultAxesCondition: (series) => series?.direction === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(colorsCount);
    const themeBackgroundColor = themeTemplateParameters.get(_Theme12.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) ?? "white";
    const targetStroke = themeTemplateParameters.get(_Theme12.DEFAULT_CROSS_LINES_COLOUR);
    return {
      fill,
      stroke: stroke2,
      target: { stroke: targetStroke },
      backgroundFill
    };
  }
};

// packages/ag-charts-enterprise/src/series/candlestick/candlestickModule.ts
import { _Theme as _Theme14 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeries.ts
import { _ModuleSupport as _ModuleSupport100 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesBase.ts
import {
  _ModuleSupport as _ModuleSupport97,
  _Scale as _Scale10,
  _Scene as _Scene42,
  _Util as _Util63
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/candlestick/candlestickUtil.ts
import { _ModuleSupport as _ModuleSupport96 } from "ag-charts-community";
var { computeBarFocusBounds: computeBarFocusBounds3, NODE_UPDATE_STATE_TO_PHASE_MAPPING } = _ModuleSupport96;
function resetCandlestickSelectionsFn(_node, datum) {
  return getCoordinates(datum);
}
function prepareCandlestickAnimationFunctions(initial) {
  const fromFn = (candlestickGroup, datum, status) => {
    const phase = initial ? "initial" : NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    if (status === "unknown" || status === "added" && datum != null) {
      const { x, y, yLow, yHigh, width, height } = getCoordinates(datum);
      let collapsedY = datum.itemId === "up" ? yLow : yHigh;
      if (status === "unknown") {
        collapsedY = y + height / 2;
      }
      return {
        x,
        y: collapsedY,
        yBottom: collapsedY,
        yHigh: collapsedY,
        yLow: collapsedY,
        width,
        height: 0,
        phase
      };
    }
    return {
      x: candlestickGroup.x,
      y: candlestickGroup.y,
      yBottom: candlestickGroup.yBottom,
      yHigh: candlestickGroup.yHigh,
      yLow: candlestickGroup.yLow,
      width: candlestickGroup.width,
      height: candlestickGroup.height,
      phase
    };
  };
  const toFn = (_, datum, status) => {
    if (status === "removed") {
      const { x, yLow, yHigh, width } = getCoordinates(datum);
      const collapsedY = datum.itemId === "up" ? yLow : yHigh;
      return { x, y: collapsedY, yBottom: collapsedY, yHigh: collapsedY, yLow: collapsedY, width, height: 0 };
    }
    return getCoordinates(datum);
  };
  return { toFn, fromFn };
}
function getCoordinates(datum) {
  const {
    bandwidth,
    scaledValues: { xValue: x, openValue, closeValue, highValue, lowValue }
  } = datum;
  const y = Math.min(openValue, closeValue);
  const yBottom = isNaN(openValue) ? closeValue : Math.max(openValue, closeValue);
  const yHigh = Math.min(highValue, lowValue);
  const yLow = Math.max(highValue, lowValue);
  return {
    x,
    y,
    yBottom,
    yHigh,
    yLow,
    width: bandwidth,
    height: Math.max(yBottom - y, 1e-3)
    // This is to differentiate between animation setting height 0 and data values resulting in height 0
  };
}
function computeCandleFocusBounds(series, opts) {
  const candleDatum = series.getNodeData()?.at(opts.datumIndex);
  const datum = !candleDatum ? void 0 : {
    x: candleDatum.scaledValues.xValue,
    y: candleDatum.scaledValues.highValue,
    width: candleDatum.bandwidth,
    height: candleDatum.scaledValues.lowValue - candleDatum.scaledValues.highValue
  };
  return computeBarFocusBounds3(datum, series.contentGroup, opts.seriesRect);
}

// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesBase.ts
var { motion: motion2 } = _Scene42;
var {
  fixNumericExtent: fixNumericExtent3,
  keyProperty: keyProperty3,
  SeriesNodePickMode: SeriesNodePickMode2,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL2,
  valueProperty: valueProperty5,
  diff: diff3,
  animationValidation: animationValidation3,
  convertValuesToScaleByDefs: convertValuesToScaleByDefs2
} = _ModuleSupport97;
var { sanitizeHtml: sanitizeHtml2, Logger: Logger7 } = _Util63;
var { ContinuousScale: ContinuousScale3 } = _Scale10;
var CandlestickSeriesNodeEvent = class extends _ModuleSupport97.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.openKey = series.properties.openKey;
    this.closeKey = series.properties.closeKey;
    this.highKey = series.properties.highKey;
    this.lowKey = series.properties.lowKey;
  }
};
var OhlcSeriesBase = class extends _ModuleSupport97.AbstractBarSeries {
  constructor(moduleCtx, datumAnimationResetFnc) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode2.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode2.EXACT_SHAPE_MATCH],
      directionKeys: {
        x: ["xKey"],
        y: ["lowKey", "highKey", "openKey", "closeKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["lowName", "highName", "openName", "closeName"]
      },
      pathsPerSeries: [],
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: datumAnimationResetFnc
      }
    });
    this.NodeEvent = CandlestickSeriesNodeEvent;
  }
  animateEmptyUpdateReady({
    datumSelection
  }) {
    const animationFns = prepareCandlestickAnimationFunctions(true);
    motion2.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], animationFns);
  }
  animateWaitingUpdateReady({
    datumSelection
  }) {
    const { processedData } = this;
    const difference = processedData?.reduced?.diff;
    const animationFns = prepareCandlestickAnimationFunctions(false);
    motion2.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelection],
      animationFns,
      (_, datum) => String(datum.xValue),
      difference
    );
  }
  async processData(dataController) {
    if (!this.properties.isValid() || !this.visible)
      return;
    const { xKey, openKey, closeKey, highKey, lowKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (animationEnabled) {
      if (this.processedData) {
        extraProps.push(diff3(this.processedData));
      }
      extraProps.push(animationValidation3());
    }
    if (openKey) {
      extraProps.push(
        valueProperty5(openKey, yScaleType, {
          id: `openValue`,
          invalidValue: void 0,
          missingValue: void 0
        })
      );
    }
    const { processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty3(xKey, xScaleType, { id: `xValue` }),
        valueProperty5(closeKey, yScaleType, { id: `closeValue` }),
        valueProperty5(highKey, yScaleType, { id: `highValue` }),
        valueProperty5(lowKey, yScaleType, { id: `lowValue` }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL2] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    const { openKey } = this.properties;
    if (direction === this.getBarDirection()) {
      const lowValues = dataModel.getDomain(this, `lowValue`, "value", processedData);
      const highValues = dataModel.getDomain(this, `highValue`, "value", processedData);
      const openValues = openKey ? dataModel.getDomain(this, `openValue`, "value", processedData) : [];
      const closeValues = dataModel.getDomain(this, `closeValue`, "value", processedData);
      return fixNumericExtent3([
        Math.min(...lowValues, ...highValues, ...openValues, ...closeValues),
        Math.max(...highValues, ...lowValues, ...openValues, ...closeValues)
      ]);
    }
    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = processedData.domain.keys[index];
    if (def.type === "key" && def.valueType === "category") {
      return keys;
    }
    return this.padBandExtent(keys);
  }
  createBaseNodeData() {
    const { visible, dataModel } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(dataModel && xAxis && yAxis)) {
      return;
    }
    const nodeData = [];
    const { xKey, highKey, lowKey } = this.properties;
    const defs = dataModel.resolveProcessedDataDefsByIds(this, [
      "xValue",
      "openValue",
      "closeValue",
      "highValue",
      "lowValue"
    ]);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale3.is(xAxis.scale) ? barWidth * -0.5 : 0;
    const { groupScale, processedData } = this;
    const context = {
      itemId: xKey,
      nodeData,
      labelData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!visible)
      return context;
    processedData?.data.forEach(({ datum, keys, values }) => {
      const { xValue, openValue, closeValue, highValue, lowValue } = dataModel.resolveProcessedDataDefsValues(
        defs,
        { keys, values }
      );
      const validLowValue = lowValue != null && lowValue <= openValue && lowValue <= closeValue;
      const validHighValue = highValue != null && highValue >= openValue && highValue >= closeValue;
      if (!validLowValue) {
        Logger7.warnOnce(
          `invalid low value for key [${lowKey}] in data element, low value cannot be higher than datum open or close values`
        );
        return;
      }
      if (!validHighValue) {
        Logger7.warnOnce(
          `invalid high value for key [${highKey}] in data element, high value cannot be lower than datum open or close values.`
        );
        return;
      }
      const scaledValues = convertValuesToScaleByDefs2({
        defs,
        values: {
          xValue,
          openValue,
          closeValue,
          highValue,
          lowValue
        },
        xAxis,
        yAxis
      });
      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;
      const isRising = closeValue > openValue;
      const itemId = this.getSeriesItemType(isRising);
      const [y, yBottom] = isRising ? [scaledValues.openValue, scaledValues.closeValue] : [scaledValues.closeValue, scaledValues.openValue];
      const height = yBottom - y;
      const midPoint = {
        x: scaledValues.xValue + Math.round(barWidth) / 2,
        y: y + height / 2
      };
      nodeData.push({
        series: this,
        itemId,
        datum,
        xKey,
        xValue,
        openValue,
        closeValue,
        highValue,
        lowValue,
        // CRT-340 Use atleast 1px width to prevent nothing being drawn.
        bandwidth: barWidth >= 1 ? barWidth : groupScale.rawBandwidth,
        scaledValues,
        midPoint,
        aggregatedValue: closeValue
      });
    });
    return context;
  }
  getSeriesItemType(isRising) {
    return isRising ? "up" : "down";
  }
  getItemConfig(seriesItemType) {
    return this.properties.item[seriesItemType];
  }
  getLegendData(legendType) {
    const { id, data } = this;
    const {
      xKey,
      yName,
      item: { up, down },
      showInLegend,
      legendItemName,
      visible
    } = this.properties;
    if (!showInLegend || !data?.length || !xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible,
        label: {
          text: legendItemName ?? yName ?? id
        },
        symbols: [
          {
            marker: {
              fill: up.fill ?? up.stroke,
              fillOpacity: up.fillOpacity ?? 1,
              stroke: up.stroke,
              strokeWidth: up.strokeWidth ?? 1,
              strokeOpacity: up.strokeOpacity ?? 1,
              padding: 0
            }
          },
          {
            marker: {
              fill: down.fill ?? down.stroke,
              fillOpacity: down.fillOpacity ?? 1,
              stroke: down.stroke,
              strokeWidth: down.strokeWidth ?? 1,
              strokeOpacity: down.strokeOpacity ?? 1
            }
          }
        ],
        legendItemName
      }
    ];
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      openKey,
      closeKey,
      highKey,
      lowKey,
      xName,
      yName,
      openName,
      closeName,
      highName,
      lowName,
      tooltip
    } = this.properties;
    const { datum, itemId } = nodeDatum;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!xAxis || !yAxis || !this.properties.isValid())
      return _ModuleSupport97.EMPTY_TOOLTIP_CONTENT;
    const capitalise = (text2) => text2.charAt(0).toUpperCase() + text2.substring(1);
    const title = sanitizeHtml2(yName);
    const contentData = [
      [xKey, xName, xAxis],
      [openKey, openName, yAxis],
      [highKey, highName, yAxis],
      [lowKey, lowName, yAxis],
      [closeKey, closeName, yAxis]
    ];
    const content = contentData.map(([key, name, axis]) => sanitizeHtml2(`${name ?? capitalise(key)}: ${axis.formatDatum(datum[key])}`)).join("<br/>");
    const styles = this.getFormattedStyles(nodeDatum);
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: styles.stroke },
      {
        seriesId: this.id,
        highlighted: false,
        datum,
        ...styles,
        xKey,
        openKey,
        closeKey,
        highKey,
        lowKey,
        xName,
        yName,
        openName,
        closeName,
        highName,
        lowName,
        title,
        color: styles.fill,
        fill: styles.fill,
        itemId
      }
    );
  }
  isVertical() {
    return true;
  }
  isLabelEnabled() {
    return false;
  }
  async updateDatumSelection(opts) {
    const data = opts.nodeData ?? [];
    return opts.datumSelection.update(data);
  }
  async updateDatumNodes({
    datumSelection,
    isHighlight: highlighted
  }) {
    datumSelection.each((group, nodeDatum) => {
      const activeStyles = this.getActiveStyles(nodeDatum, highlighted);
      group.updateDatumStyles(nodeDatum, activeStyles);
    });
  }
  async updateLabelNodes(_opts) {
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
};

// packages/ag-charts-enterprise/src/series/candlestick/candlestickGroup.ts
import { _ModuleSupport as _ModuleSupport98, _Scene as _Scene43, _Util as _Util64 } from "ag-charts-community";
var { SceneChangeDetection, BBox: BBox6, RedrawType } = _Scene43;
var CandlestickBaseGroup = class extends _Scene43.Group {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.yBottom = 0;
    this.yHigh = 0;
    this.yLow = 0;
    this.width = 0;
    this.height = 0;
  }
  distanceSquared(x, y) {
    const nodes = _Scene43.Selection.selectByClass(this, _Scene43.Rect, _Scene43.Line);
    return _ModuleSupport98.nearestSquared(x, y, nodes).distanceSquared;
  }
  get midPoint() {
    const datum = this.datum;
    if (datum.midPoint === void 0) {
      _Util64.Logger.error("CandlestickBaseGroup.datum.midPoint is undefined");
      return { x: NaN, y: NaN };
    }
    return datum.midPoint;
  }
  render(renderCtx) {
    this.updateCoordinates();
    super.render(renderCtx);
  }
};
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "yBottom", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "yHigh", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "yLow", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection({ redraw: RedrawType.MAJOR })
], CandlestickBaseGroup.prototype, "height", 2);
var CandlestickGroup = class extends CandlestickBaseGroup {
  constructor() {
    super();
    this.append([
      new _Scene43.Rect({ tag: 0 /* Body */ }),
      new _Scene43.Line({ tag: 1 /* LowWick */ }),
      new _Scene43.Line({ tag: 2 /* HighWick */ })
    ]);
  }
  updateCoordinates() {
    const { x, y, yBottom, yHigh, yLow, width, height } = this;
    const selection = _Scene43.Selection.select(this, _Scene43.Rect);
    const [body] = selection.selectByTag(0 /* Body */);
    const [lowWick] = selection.selectByTag(1 /* LowWick */);
    const [highWick] = selection.selectByTag(2 /* HighWick */);
    if (width === 0 || height === 0) {
      body.visible = false;
      lowWick.visible = false;
      highWick.visible = false;
      return;
    }
    body.visible = true;
    lowWick.visible = true;
    highWick.visible = true;
    body.setProperties({
      x,
      y,
      width,
      height,
      crisp: true,
      clipBBox: new BBox6(x, y, width, height)
    });
    const halfWidth = width / 2;
    lowWick.setProperties({
      y1: Math.round(yLow + lowWick.strokeWidth / 2),
      y2: yBottom,
      x: x + halfWidth
    });
    highWick.setProperties({
      y1: Math.round(yHigh + highWick.strokeWidth / 2),
      y2: y,
      x: x + halfWidth
    });
  }
  updateDatumStyles(datum, activeStyles) {
    const { bandwidth } = datum;
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wick: wickStyles = {},
      cornerRadius
    } = activeStyles;
    wickStyles.strokeWidth ?? (wickStyles.strokeWidth = 1);
    const selection = _Scene43.Selection.select(this, _Scene43.Rect);
    const [body] = selection.selectByTag(0 /* Body */);
    const [lowWick] = selection.selectByTag(1 /* LowWick */);
    const [highWick] = selection.selectByTag(2 /* HighWick */);
    if (wickStyles.strokeWidth > bandwidth) {
      wickStyles.strokeWidth = bandwidth;
    }
    body.setProperties({
      fill,
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      stroke: stroke2,
      lineDash,
      lineDashOffset,
      cornerRadius
    });
    lowWick.setProperties(wickStyles);
    highWick.setProperties(wickStyles);
  }
};

// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport99 } from "ag-charts-community";
var {
  BaseProperties: BaseProperties19,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties3,
  SeriesTooltip: SeriesTooltip3,
  Validate: Validate45,
  COLOR_STRING: COLOR_STRING10,
  FUNCTION: FUNCTION6,
  LINE_DASH: LINE_DASH7,
  OBJECT: OBJECT18,
  POSITIVE_NUMBER: POSITIVE_NUMBER12,
  RATIO: RATIO15,
  STRING: STRING22
} = _ModuleSupport99;
var CandlestickSeriesWick = class extends BaseProperties19 {
};
__decorateClass([
  Validate45(COLOR_STRING10, { optional: true })
], CandlestickSeriesWick.prototype, "stroke", 2);
__decorateClass([
  Validate45(POSITIVE_NUMBER12)
], CandlestickSeriesWick.prototype, "strokeWidth", 2);
__decorateClass([
  Validate45(RATIO15)
], CandlestickSeriesWick.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate45(LINE_DASH7, { optional: true })
], CandlestickSeriesWick.prototype, "lineDash", 2);
__decorateClass([
  Validate45(POSITIVE_NUMBER12)
], CandlestickSeriesWick.prototype, "lineDashOffset", 2);
var CandlestickSeriesItem = class extends BaseProperties19 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.wick = new CandlestickSeriesWick();
  }
};
__decorateClass([
  Validate45(COLOR_STRING10, { optional: true })
], CandlestickSeriesItem.prototype, "fill", 2);
__decorateClass([
  Validate45(RATIO15)
], CandlestickSeriesItem.prototype, "fillOpacity", 2);
__decorateClass([
  Validate45(COLOR_STRING10)
], CandlestickSeriesItem.prototype, "stroke", 2);
__decorateClass([
  Validate45(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "strokeWidth", 2);
__decorateClass([
  Validate45(RATIO15)
], CandlestickSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate45(LINE_DASH7)
], CandlestickSeriesItem.prototype, "lineDash", 2);
__decorateClass([
  Validate45(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate45(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "cornerRadius", 2);
__decorateClass([
  Validate45(OBJECT18)
], CandlestickSeriesItem.prototype, "wick", 2);
var CandlestickSeriesItems = class extends BaseProperties19 {
  constructor() {
    super(...arguments);
    this.up = new CandlestickSeriesItem();
    this.down = new CandlestickSeriesItem();
  }
};
__decorateClass([
  Validate45(OBJECT18)
], CandlestickSeriesItems.prototype, "up", 2);
__decorateClass([
  Validate45(OBJECT18)
], CandlestickSeriesItems.prototype, "down", 2);
var CandlestickSeriesProperties = class extends AbstractBarSeriesProperties3 {
  constructor() {
    super(...arguments);
    this.tooltip = new SeriesTooltip3();
    this.item = new CandlestickSeriesItems();
  }
};
__decorateClass([
  Validate45(STRING22)
], CandlestickSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate45(STRING22)
], CandlestickSeriesProperties.prototype, "openKey", 2);
__decorateClass([
  Validate45(STRING22)
], CandlestickSeriesProperties.prototype, "closeKey", 2);
__decorateClass([
  Validate45(STRING22)
], CandlestickSeriesProperties.prototype, "highKey", 2);
__decorateClass([
  Validate45(STRING22)
], CandlestickSeriesProperties.prototype, "lowKey", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "openName", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "closeName", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "highName", 2);
__decorateClass([
  Validate45(STRING22, { optional: true })
], CandlestickSeriesProperties.prototype, "lowName", 2);
__decorateClass([
  Validate45(OBJECT18)
], CandlestickSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate45(OBJECT18)
], CandlestickSeriesProperties.prototype, "item", 2);
__decorateClass([
  Validate45(FUNCTION6, { optional: true })
], CandlestickSeriesProperties.prototype, "itemStyler", 2);

// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeries.ts
var { extractDecoratedProperties: extractDecoratedProperties2, mergeDefaults: mergeDefaults5 } = _ModuleSupport100;
var CandlestickSeries = class extends OhlcSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, resetCandlestickSelectionsFn);
    this.properties = new CandlestickSeriesProperties();
  }
  async createNodeData() {
    const baseNodeData = this.createBaseNodeData();
    if (!baseNodeData) {
      return;
    }
    const nodeData = baseNodeData.nodeData.map((datum) => {
      const {
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        wick,
        cornerRadius
      } = this.getItemConfig(datum.itemId);
      return {
        ...datum,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        wick,
        cornerRadius
      };
    });
    return { ...baseNodeData, nodeData };
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { xKey, openKey, closeKey, highKey, lowKey, itemStyler } = this.properties;
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(
      nodeDatum.itemId
    );
    if (itemStyler) {
      const formatStyles = callbackCache.call(itemStyler, {
        datum: nodeDatum.datum,
        itemId: nodeDatum.itemId,
        seriesId,
        highlighted,
        xKey,
        openKey,
        closeKey,
        highKey,
        lowKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      });
      if (formatStyles) {
        return mergeDefaults5(formatStyles, this.getSeriesStyles(nodeDatum));
      }
    }
    return this.getSeriesStyles(nodeDatum);
  }
  nodeFactory() {
    return new CandlestickGroup();
  }
  getSeriesStyles(nodeDatum) {
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, wick, cornerRadius } = nodeDatum;
    return {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wick: extractDecoratedProperties2(wick),
      cornerRadius
    };
  }
  getActiveStyles(nodeDatum, highlighted) {
    let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
    if (highlighted) {
      activeStyles = mergeDefaults5(this.properties.highlightStyle.item, activeStyles);
    }
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;
    activeStyles.wick = mergeDefaults5(activeStyles.wick, {
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return activeStyles;
  }
  computeFocusBounds(opts) {
    return computeCandleFocusBounds(this, opts);
  }
};
CandlestickSeries.className = "CandleStickSeries";
CandlestickSeries.type = "candlestick";

// packages/ag-charts-enterprise/src/series/candlestick/candlestickThemes.ts
import { _Theme as _Theme13 } from "ag-charts-community";
var CANDLESTICK_SERIES_THEME = {
  series: {
    highlightStyle: {
      item: { strokeWidth: 3 }
    }
  },
  animation: { enabled: false },
  axes: {
    [_Theme13.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [_Theme13.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {
      groupPaddingInner: 0,
      crosshair: {
        enabled: true
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/candlestick/candlestickModule.ts
var CandlestickModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "candlestick",
  moduleFactory: (ctx) => new CandlestickSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: _Theme14.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme14.POSITION.LEFT
    },
    {
      type: _Theme14.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,
      position: _Theme14.POSITION.BOTTOM
    }
  ],
  themeTemplate: CANDLESTICK_SERIES_THEME,
  groupable: false,
  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {
    if (userPalette === "user-indexed") {
      const { fills, strokes } = takeColors(colorsCount);
      return {
        item: {
          up: {
            fill: "transparent",
            stroke: strokes[0]
          },
          down: {
            fill: fills[0],
            stroke: strokes[0]
          }
        }
      };
    }
    return {
      item: {
        up: palette.up,
        down: palette.down
      }
    };
  }
};

// packages/ag-charts-enterprise/src/series/chord/chordModule.ts
import { _Theme as _Theme15 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/chord/chordSeries.ts
import {
  _ModuleSupport as _ModuleSupport103,
  _Scene as _Scene48,
  _Util as _Util67
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionSeries.ts
import { _ModuleSupport as _ModuleSupport101, _Scene as _Scene45 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionUtil.ts
import { _Util as _Util65 } from "ag-charts-community";
var { Logger: Logger8 } = _Util65;
function computeNodeGraph(nodes, links, includeCircularReferences) {
  if (!includeCircularReferences) {
    links = removeCircularLinks(links);
  }
  const nodeGraph = /* @__PURE__ */ new Map();
  for (const datum of nodes) {
    nodeGraph.set(datum.id, {
      datum,
      linksBefore: [],
      linksAfter: [],
      maxPathLengthBefore: -1,
      maxPathLengthAfter: -1
    });
  }
  let maxPathLength = 0;
  nodeGraph.forEach((node, id) => {
    maxPathLength = Math.max(
      maxPathLength,
      computePathLength(nodeGraph, links, node, id, -1, []) + computePathLength(nodeGraph, links, node, id, 1, []) + 1
    );
  });
  return { links, nodeGraph, maxPathLength };
}
function findCircularLinks(links, link, into, stack) {
  const stackIndex = stack.indexOf(link);
  if (stackIndex !== -1) {
    for (let i = stackIndex; i < stack.length; i += 1) {
      into.add(stack[i]);
    }
    return;
  }
  stack.push(link);
  const { toNode } = link;
  for (const next of links) {
    if (next.fromNode === toNode) {
      findCircularLinks(links, next, into, stack);
    }
  }
  stack.pop();
}
function removeCircularLinks(links) {
  const circularLinks = /* @__PURE__ */ new Set();
  for (const link of links) {
    findCircularLinks(links, link, circularLinks, []);
  }
  if (circularLinks.size !== 0) {
    Logger8.warnOnce("Some links formed circular references. These will be removed from the output.");
  }
  return circularLinks.size === 0 ? links : links.filter((link) => !circularLinks.has(link));
}
function computePathLength(nodeGraph, links, node, id, direction, stack) {
  if (stack.includes(id)) {
    return Infinity;
  }
  let maxPathLength = direction === -1 ? node.maxPathLengthBefore : node.maxPathLengthAfter;
  if (maxPathLength === -1) {
    maxPathLength = 0;
    const connectedLinks = direction === -1 ? node.linksBefore : node.linksAfter;
    for (const link of links) {
      const { fromNode, toNode } = link;
      const linkId = direction === -1 ? toNode.id : fromNode.id;
      const nextNodeId = direction === -1 ? fromNode.id : toNode.id;
      const nextNode = id === linkId ? nodeGraph.get(nextNodeId) : void 0;
      if (nextNode == null)
        continue;
      connectedLinks.push({ node: nextNode, link });
      stack?.push(id);
      maxPathLength = Math.max(
        maxPathLength,
        computePathLength(nodeGraph, links, nextNode, nextNodeId, direction, stack) + 1
      );
      stack?.pop();
    }
    if (direction === -1) {
      node.maxPathLengthBefore = maxPathLength;
    } else {
      node.maxPathLengthAfter = maxPathLength;
    }
  }
  return maxPathLength;
}

// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionSeries.ts
var { DataModelSeries, DataController, Validate: Validate46, ARRAY: ARRAY4, keyProperty: keyProperty4, valueProperty: valueProperty6 } = _ModuleSupport101;
var { Selection: Selection3, Group: Group6, TransformableText } = _Scene45;
var FlowProportionSeries = class extends DataModelSeries {
  constructor() {
    super(...arguments);
    this._chartNodes = void 0;
    this.nodeCount = 0;
    this.linkCount = 0;
    this.nodesDataController = new DataController("standalone");
    this.nodesDataModel = void 0;
    this.nodesProcessedData = void 0;
    this.processedNodes = /* @__PURE__ */ new Map();
    this.linkGroup = this.contentGroup.appendChild(new Group6({ name: "linkGroup" }));
    this.nodeGroup = this.contentGroup.appendChild(new Group6({ name: "nodeGroup" }));
    this.focusLinkGroup = this.highlightNode.appendChild(new Group6({ name: "linkGroup" }));
    this.focusNodeGroup = this.highlightNode.appendChild(new Group6({ name: "nodeGroup" }));
    this.highlightLinkGroup = this.highlightNode.appendChild(new Group6({ name: "linkGroup" }));
    this.highlightNodeGroup = this.highlightNode.appendChild(new Group6({ name: "nodeGroup" }));
    this.labelSelection = Selection3.select(
      this.labelGroup,
      TransformableText
    );
    this.linkSelection = Selection3.select(
      this.linkGroup,
      () => this.linkFactory()
    );
    this.nodeSelection = Selection3.select(
      this.nodeGroup,
      () => this.nodeFactory()
    );
    this.focusLinkSelection = Selection3.select(
      this.focusLinkGroup,
      () => this.linkFactory()
    );
    this.focusNodeSelection = Selection3.select(
      this.focusNodeGroup,
      () => this.nodeFactory()
    );
    this.highlightLinkSelection = Selection3.select(
      this.highlightLinkGroup,
      () => this.linkFactory()
    );
    this.highlightNodeSelection = Selection3.select(
      this.highlightNodeGroup,
      () => this.nodeFactory()
    );
  }
  get nodes() {
    return this.properties.nodes ?? this._chartNodes;
  }
  setChartNodes(nodes) {
    this._chartNodes = nodes;
    if (this.nodes === nodes) {
      this.nodeDataRefresh = true;
    }
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  async processData(dataController) {
    const { nodesDataController, data, nodes } = this;
    if (data == null || !this.properties.isValid()) {
      return;
    }
    const { fromKey, toKey, sizeKey, idKey, labelKey } = this.properties;
    const nodesDataModelPromise = nodes != null ? nodesDataController.request(this.id, nodes, {
      props: [
        keyProperty4(idKey, void 0, { id: "idValue", includeProperty: false }),
        ...labelKey != null ? [valueProperty6(labelKey, void 0, { id: "labelValue", includeProperty: false })] : []
      ],
      groupByKeys: true
    }) : null;
    const linksDataModelPromise = this.requestDataModel(dataController, data, {
      props: [
        valueProperty6(fromKey, void 0, { id: "fromValue", includeProperty: false }),
        valueProperty6(toKey, void 0, { id: "toValue", includeProperty: false }),
        ...sizeKey != null ? [valueProperty6(sizeKey, void 0, { id: "sizeValue", includeProperty: false, missingValue: 0 })] : []
      ],
      groupByKeys: false
    });
    if (nodes != null) {
      nodesDataController.execute();
    }
    const [nodesDataModel, linksDataModel] = await Promise.all([nodesDataModelPromise, linksDataModelPromise]);
    this.nodesDataModel = nodesDataModel?.dataModel;
    this.nodesProcessedData = nodesDataModel?.processedData;
    const { fills, strokes } = this.properties;
    const processedNodes = /* @__PURE__ */ new Map();
    if (nodesDataModel == null) {
      const fromIdIdx = linksDataModel.dataModel.resolveProcessedDataIndexById(this, "fromValue");
      const toIdIdx = linksDataModel.dataModel.resolveProcessedDataIndexById(this, "toValue");
      const createImplicitNode = (id) => {
        const index = processedNodes.size;
        const label = id;
        const fill = fills[index % fills.length];
        const stroke2 = strokes[index % strokes.length];
        return {
          series: this,
          itemId: void 0,
          datum: {},
          // Must be a referential object for tooltips
          type: 1 /* Node */,
          index,
          id,
          label,
          fill,
          stroke: stroke2
        };
      };
      linksDataModel.processedData.data.forEach(({ values }) => {
        const fromId = values[fromIdIdx];
        const toId = values[toIdIdx];
        if (fromId == null || toId == null)
          return;
        if (!processedNodes.has(fromId)) {
          processedNodes.set(fromId, createImplicitNode(fromId));
        }
        if (!processedNodes.has(toId)) {
          processedNodes.set(toId, createImplicitNode(toId));
        }
      });
    } else {
      const nodeIdIdx = nodesDataModel.dataModel.resolveProcessedDataIndexById(this, "idValue");
      const labelIdx = labelKey != null ? nodesDataModel.dataModel.resolveProcessedDataIndexById(this, "labelValue") : void 0;
      nodesDataModel.processedData.data.forEach(({ datum, keys, values }, index) => {
        const value = values[0];
        const id = keys[nodeIdIdx];
        const label = labelIdx != null ? value[labelIdx] : void 0;
        const fill = fills[index % fills.length];
        const stroke2 = strokes[index % strokes.length];
        processedNodes.set(id, {
          series: this,
          itemId: void 0,
          datum,
          type: 1 /* Node */,
          index,
          id,
          label,
          fill,
          stroke: stroke2
        });
      });
    }
    this.processedNodes = processedNodes;
  }
  getNodeGraph(createNode, createLink, { includeCircularReferences }) {
    const { dataModel: linksDataModel, processedData: linksProcessedData } = this;
    if (linksDataModel == null || linksProcessedData == null) {
      const { links: links2, nodeGraph: nodeGraph2, maxPathLength: maxPathLength2 } = computeNodeGraph(
        (/* @__PURE__ */ new Map()).values(),
        [],
        includeCircularReferences
      );
      this.nodeCount = 0;
      this.linkCount = 0;
      return { nodeGraph: nodeGraph2, links: links2, maxPathLength: maxPathLength2 };
    }
    const { sizeKey } = this.properties;
    const fromIdIdx = linksDataModel.resolveProcessedDataIndexById(this, "fromValue");
    const toIdIdx = linksDataModel.resolveProcessedDataIndexById(this, "toValue");
    const sizeIdx = sizeKey != null ? linksDataModel.resolveProcessedDataIndexById(this, "sizeValue") : void 0;
    const nodesById = /* @__PURE__ */ new Map();
    this.processedNodes.forEach((datum) => {
      const node = createNode(datum);
      nodesById.set(datum.id, node);
    });
    const baseLinks = [];
    linksProcessedData.data.forEach(({ datum, values }, index) => {
      const fromId = values[fromIdIdx];
      const toId = values[toIdIdx];
      const size = sizeIdx != null ? values[sizeIdx] : 1;
      const fromNode = nodesById.get(fromId);
      const toNode = nodesById.get(toId);
      if (size <= 0 || fromNode == null || toNode == null)
        return;
      const link = createLink({
        series: this,
        itemId: void 0,
        datum,
        type: 0 /* Link */,
        index,
        fromNode,
        toNode,
        size
      });
      baseLinks.push(link);
    });
    const { links, nodeGraph, maxPathLength } = computeNodeGraph(
      nodesById.values(),
      baseLinks,
      includeCircularReferences
    );
    this.nodeCount = nodeGraph.size;
    this.linkCount = links.length;
    return { nodeGraph, links, maxPathLength };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  async update(opts) {
    const { seriesRect } = opts;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width ?? 0,
      seriesRectHeight: seriesRect?.height ?? 0
    };
    if (this._nodeDataDependencies == null || this._nodeDataDependencies.seriesRectWidth !== newNodeDataDependencies.seriesRectWidth || this._nodeDataDependencies.seriesRectHeight !== newNodeDataDependencies.seriesRectHeight) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    await this.updateSelections();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum?.series === this && highlightedDatum.type == null) {
      const { itemId } = highlightedDatum;
      highlightedDatum = itemId != null ? nodeData.find((node) => node.type === 1 /* Node */ && node.id === itemId) : void 0;
    } else if (highlightedDatum?.series !== this) {
      highlightedDatum = void 0;
    }
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = highlightedDatum != null ? this.properties.highlightStyle.series.dimOpacity ?? 1 : 1;
    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection: this.labelSelection });
    await this.updateLabelNodes({ labelSelection: this.labelSelection });
    this.linkSelection = await this.updateLinkSelection({
      nodeData: nodeData.filter((d) => d.type === 0 /* Link */),
      datumSelection: this.linkSelection
    });
    await this.updateLinkNodes({ datumSelection: this.linkSelection, isHighlight: false });
    this.nodeSelection = await this.updateNodeSelection({
      nodeData: nodeData.filter((d) => d.type === 1 /* Node */),
      datumSelection: this.nodeSelection
    });
    await this.updateNodeNodes({ datumSelection: this.nodeSelection, isHighlight: false });
    let focusLinkSelection;
    let focusNodeSelection;
    let highlightLinkSelection;
    let highlightNodeSelection;
    if (highlightedDatum?.type === 1 /* Node */) {
      focusLinkSelection = nodeData.filter((node) => {
        return node.type === 0 /* Link */ && (node.toNode === highlightedDatum || node.fromNode === highlightedDatum);
      });
      focusNodeSelection = focusLinkSelection.map((link) => {
        return link.fromNode === highlightedDatum ? link.toNode : link.fromNode;
      });
      focusNodeSelection.push(highlightedDatum);
      highlightLinkSelection = [];
      highlightNodeSelection = [highlightedDatum];
    } else if (highlightedDatum?.type === 0 /* Link */) {
      focusLinkSelection = [highlightedDatum];
      focusNodeSelection = [highlightedDatum.fromNode, highlightedDatum.toNode];
      highlightLinkSelection = [highlightedDatum];
      highlightNodeSelection = [];
    } else {
      focusLinkSelection = [];
      focusNodeSelection = [];
      highlightLinkSelection = [];
      highlightNodeSelection = [];
    }
    this.focusLinkSelection = await this.updateLinkSelection({
      nodeData: focusLinkSelection,
      datumSelection: this.focusLinkSelection
    });
    await this.updateLinkNodes({ datumSelection: this.focusLinkSelection, isHighlight: false });
    this.focusNodeSelection = await this.updateNodeSelection({
      nodeData: focusNodeSelection,
      datumSelection: this.focusNodeSelection
    });
    await this.updateNodeNodes({ datumSelection: this.focusNodeSelection, isHighlight: false });
    this.highlightLinkSelection = await this.updateLinkSelection({
      nodeData: highlightLinkSelection,
      datumSelection: this.highlightLinkSelection
    });
    await this.updateLinkNodes({ datumSelection: this.highlightLinkSelection, isHighlight: true });
    this.highlightNodeSelection = await this.updateNodeSelection({
      nodeData: highlightNodeSelection,
      datumSelection: this.highlightNodeSelection
    });
    await this.updateNodeNodes({ datumSelection: this.highlightNodeSelection, isHighlight: true });
  }
  resetAnimation(_chartAnimationPhase) {
  }
  getSeriesDomain(_direction) {
    return [];
  }
  getLegendData(legendType) {
    if (legendType !== "category")
      return [];
    return Array.from(
      this.processedNodes.values(),
      ({ id, label, fill, stroke: stroke2 }) => ({
        legendType: "category",
        id: this.id,
        itemId: id,
        seriesId: this.id,
        enabled: true,
        label: { text: label ?? id },
        symbols: [
          {
            marker: {
              fill,
              fillOpacity: 1,
              stroke: stroke2,
              strokeWidth: 0,
              strokeOpacity: 1
            }
          }
        ]
      })
    );
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistanceSquared = Infinity;
    let minDatum;
    this.linkSelection.each((node, datum) => {
      const distanceSquared = node.containsPoint(x, y) ? 0 : Infinity;
      if (distanceSquared < minDistanceSquared) {
        minDistanceSquared = distanceSquared;
        minDatum = datum;
      }
    });
    this.nodeSelection.each((node, datum) => {
      const distanceSquared = node.distanceSquared(x, y);
      if (distanceSquared < minDistanceSquared) {
        minDistanceSquared = distanceSquared;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  getDatumAriaText(datum, description) {
    if (datum.type === 0 /* Link */) {
      return this.ctx.localeManager.t("ariaAnnounceFlowProportionLink", {
        index: datum.index + 1,
        count: this.linkCount,
        from: datum.fromNode.id,
        to: datum.toNode.id,
        size: datum.size,
        sizeName: this.properties.sizeName ?? this.properties.sizeKey
      });
    } else if (datum.type === 1 /* Node */) {
      return this.ctx.localeManager.t("ariaAnnounceFlowProportionNode", {
        index: datum.index + 1,
        count: this.nodeCount,
        description
      });
    }
  }
};
__decorateClass([
  Validate46(ARRAY4, { optional: true, property: "nodes" })
], FlowProportionSeries.prototype, "_chartNodes", 2);

// packages/ag-charts-enterprise/src/series/chord/chordLink.ts
import { _Scene as _Scene46 } from "ag-charts-community";
var { BBox: BBox7, Path: Path5, ScenePathChangeDetection } = _Scene46;
function bezierControlPoints({
  radius,
  startAngle,
  endAngle,
  tension
}) {
  const cp0x = radius * Math.cos(startAngle);
  const cp0y = radius * Math.sin(startAngle);
  const cp3x = radius * Math.cos(endAngle);
  const cp3y = radius * Math.sin(endAngle);
  const cp1x = cp0x * tension;
  const cp1y = cp0y * tension;
  const cp2x = cp3x * tension;
  const cp2y = cp3y * tension;
  return {
    x: [cp0x, cp1x, cp2x, cp3x],
    y: [cp0y, cp1y, cp2y, cp3y]
  };
}
var ChordLink = class extends Path5 {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.startAngle1 = 0;
    this.endAngle1 = 0;
    this.startAngle2 = 0;
    this.endAngle2 = 0;
    this.tension = 1;
  }
  computeBBox() {
    const { centerX, centerY, radius, startAngle1, endAngle1, startAngle2, endAngle2, tension } = this;
    const outer = bezierControlPoints({ radius, startAngle: startAngle1, endAngle: endAngle2, tension });
    const inner = bezierControlPoints({ radius, startAngle: startAngle2, endAngle: endAngle1, tension });
    const x = Math.min(...outer.x, ...inner.x);
    const width = Math.max(...outer.x, ...inner.x) - x;
    const y = Math.min(...outer.y, ...inner.y);
    const height = Math.max(...outer.y, ...inner.y) - y;
    return new BBox7(centerX + x, centerY + y, width, height);
  }
  tensionedCurveTo(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
    const { path, tension } = this;
    const scale = 1 - tension;
    path.cubicCurveTo(
      (cp1x - cp0x) * scale + cp0x,
      (cp1y - cp0y) * scale + cp0y,
      (cp2x - cp3x) * scale + cp3x,
      (cp2y - cp3y) * scale + cp3y,
      cp3x,
      cp3y
    );
  }
  updatePath() {
    const { path, centerX, centerY, radius } = this;
    let { startAngle1, endAngle1, startAngle2, endAngle2 } = this;
    if (startAngle1 > startAngle2) {
      [startAngle1, startAngle2] = [startAngle2, startAngle1];
      [endAngle1, endAngle2] = [endAngle2, endAngle1];
    }
    path.clear();
    const startX = centerX + radius * Math.cos(startAngle1);
    const startY = centerY + radius * Math.sin(startAngle1);
    path.moveTo(startX, startY);
    this.tensionedCurveTo(
      startX,
      startY,
      centerX,
      centerY,
      centerX,
      centerY,
      centerX + radius * Math.cos(endAngle2),
      centerY + radius * Math.sin(endAngle2)
    );
    path.arc(centerX, centerY, radius, endAngle2, startAngle2, true);
    this.tensionedCurveTo(
      centerX + radius * Math.cos(startAngle2),
      centerY + radius * Math.sin(startAngle2),
      centerX,
      centerY,
      centerX,
      centerY,
      centerX + radius * Math.cos(endAngle1),
      centerY + radius * Math.sin(endAngle1)
    );
    path.arc(centerX, centerY, radius, endAngle1, startAngle1, true);
    path.closePath();
  }
};
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "centerX", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "centerY", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "radius", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "startAngle1", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "endAngle1", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "startAngle2", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "endAngle2", 2);
__decorateClass([
  ScenePathChangeDetection()
], ChordLink.prototype, "tension", 2);

// packages/ag-charts-enterprise/src/series/chord/chordSeriesProperties.ts
import {
  _ModuleSupport as _ModuleSupport102,
  _Scene as _Scene47
} from "ag-charts-community";
var {
  BaseProperties: BaseProperties20,
  SeriesTooltip: SeriesTooltip4,
  SeriesProperties,
  ARRAY: ARRAY5,
  COLOR_STRING: COLOR_STRING11,
  COLOR_STRING_ARRAY,
  FUNCTION: FUNCTION7,
  LINE_DASH: LINE_DASH8,
  OBJECT: OBJECT19,
  POSITIVE_NUMBER: POSITIVE_NUMBER13,
  RATIO: RATIO16,
  STRING: STRING23,
  Validate: Validate47
} = _ModuleSupport102;
var { Label: Label3 } = _Scene47;
var ChordSeriesLabelProperties = class extends Label3 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.maxWidth = 1;
  }
};
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesLabelProperties.prototype, "spacing", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesLabelProperties.prototype, "maxWidth", 2);
var ChordSeriesLinkProperties = class extends BaseProperties20 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tension = 0;
  }
};
__decorateClass([
  Validate47(COLOR_STRING11, { optional: true })
], ChordSeriesLinkProperties.prototype, "fill", 2);
__decorateClass([
  Validate47(RATIO16)
], ChordSeriesLinkProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate47(COLOR_STRING11, { optional: true })
], ChordSeriesLinkProperties.prototype, "stroke", 2);
__decorateClass([
  Validate47(RATIO16)
], ChordSeriesLinkProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesLinkProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate47(LINE_DASH8)
], ChordSeriesLinkProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesLinkProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate47(RATIO16)
], ChordSeriesLinkProperties.prototype, "tension", 2);
__decorateClass([
  Validate47(FUNCTION7, { optional: true })
], ChordSeriesLinkProperties.prototype, "itemStyler", 2);
var ChordSeriesNodeProperties = class extends BaseProperties20 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.width = 1;
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesNodeProperties.prototype, "spacing", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesNodeProperties.prototype, "width", 2);
__decorateClass([
  Validate47(COLOR_STRING11, { optional: true })
], ChordSeriesNodeProperties.prototype, "fill", 2);
__decorateClass([
  Validate47(RATIO16)
], ChordSeriesNodeProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate47(COLOR_STRING11, { optional: true })
], ChordSeriesNodeProperties.prototype, "stroke", 2);
__decorateClass([
  Validate47(RATIO16)
], ChordSeriesNodeProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesNodeProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate47(LINE_DASH8)
], ChordSeriesNodeProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate47(POSITIVE_NUMBER13)
], ChordSeriesNodeProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate47(FUNCTION7, { optional: true })
], ChordSeriesNodeProperties.prototype, "itemStyler", 2);
var ChordSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.idKey = "";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.sizeKey = void 0;
    this.sizeName = void 0;
    this.nodes = void 0;
    this.fills = [];
    this.strokes = [];
    this.label = new ChordSeriesLabelProperties();
    this.link = new ChordSeriesLinkProperties();
    this.node = new ChordSeriesNodeProperties();
    this.tooltip = new SeriesTooltip4();
  }
};
__decorateClass([
  Validate47(STRING23)
], ChordSeriesProperties.prototype, "fromKey", 2);
__decorateClass([
  Validate47(STRING23)
], ChordSeriesProperties.prototype, "toKey", 2);
__decorateClass([
  Validate47(STRING23)
], ChordSeriesProperties.prototype, "idKey", 2);
__decorateClass([
  Validate47(STRING23, { optional: true })
], ChordSeriesProperties.prototype, "idName", 2);
__decorateClass([
  Validate47(STRING23, { optional: true })
], ChordSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate47(STRING23, { optional: true })
], ChordSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate47(STRING23, { optional: true })
], ChordSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate47(STRING23, { optional: true })
], ChordSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate47(ARRAY5, { optional: true })
], ChordSeriesProperties.prototype, "nodes", 2);
__decorateClass([
  Validate47(COLOR_STRING_ARRAY)
], ChordSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate47(COLOR_STRING_ARRAY)
], ChordSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate47(OBJECT19)
], ChordSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate47(OBJECT19)
], ChordSeriesProperties.prototype, "link", 2);
__decorateClass([
  Validate47(OBJECT19)
], ChordSeriesProperties.prototype, "node", 2);
__decorateClass([
  Validate47(OBJECT19)
], ChordSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/chord/chordSeries.ts
var { SeriesNodePickMode: SeriesNodePickMode3, CachedTextMeasurerPool: CachedTextMeasurerPool3, TextWrapper: TextWrapper4, createDatumId: createDatumId2, EMPTY_TOOLTIP_CONTENT } = _ModuleSupport103;
var { angleBetween: angleBetween3, normalizeAngle360: normalizeAngle3605, isBetweenAngles, sanitizeHtml: sanitizeHtml3, Logger: Logger9 } = _Util67;
var { Sector: Sector3, Text: Text2, evaluateBezier } = _Scene48;
var nodeMidAngle = (node) => node.startAngle + angleBetween3(node.startAngle, node.endAngle) / 2;
var ChordSeries = class extends FlowProportionSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      pickModes: [SeriesNodePickMode3.NEAREST_NODE, SeriesNodePickMode3.EXACT_SHAPE_MATCH]
    });
    this.properties = new ChordSeriesProperties();
  }
  isLabelEnabled() {
    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;
  }
  linkFactory() {
    return new ChordLink();
  }
  nodeFactory() {
    return new Sector3();
  }
  async createNodeData() {
    const {
      id: seriesId,
      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 }
    } = this;
    const {
      fromKey,
      toKey,
      sizeKey,
      label: { spacing: labelSpacing, maxWidth: labelMaxWidth, fontSize },
      node: { width: nodeWidth, spacing: nodeSpacing }
    } = this.properties;
    const centerX = seriesRectWidth / 2;
    const centerY = seriesRectHeight / 2;
    let labelData = [];
    const defaultLabelFormatter = (v) => String(v);
    const { nodeGraph, links } = this.getNodeGraph(
      (node) => {
        const label = this.getLabelText(
          this.properties.label,
          {
            datum: node.datum,
            value: node.label,
            fromKey,
            toKey,
            sizeKey
          },
          defaultLabelFormatter
        );
        return {
          ...node,
          label,
          size: 0,
          centerX,
          centerY,
          innerRadius: NaN,
          outerRadius: NaN,
          startAngle: NaN,
          endAngle: NaN
        };
      },
      (link) => ({
        ...link,
        centerX,
        centerY,
        radius: NaN,
        startAngle1: NaN,
        endAngle1: NaN,
        startAngle2: NaN,
        endAngle2: NaN
      }),
      { includeCircularReferences: true }
    );
    let totalSize = 0;
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }, id) => {
      const size = linksBefore.reduce((acc, { link }) => acc + link.size, 0) + linksAfter.reduce((acc, { link }) => acc + link.size, 0);
      if (size === 0) {
        nodeGraph.delete(id);
      } else {
        node.size = size;
        totalSize += node.size;
      }
    });
    let labelInset = 0;
    if (this.isLabelEnabled()) {
      const canvasFont = this.properties.label.getFont();
      let maxMeasuredLabelWidth = 0;
      nodeGraph.forEach(({ datum: node }) => {
        const { id, label } = node;
        if (label == null)
          return;
        const text2 = TextWrapper4.wrapText(label, {
          maxWidth: labelMaxWidth,
          font: this.properties.label,
          textWrap: "never"
        });
        const { width } = CachedTextMeasurerPool3.measureText(text2, {
          font: canvasFont,
          textAlign: "left",
          textBaseline: "middle"
        });
        maxMeasuredLabelWidth = Math.max(width, maxMeasuredLabelWidth);
        labelData.push({
          id,
          text: text2,
          centerX,
          centerY,
          angle: NaN,
          radius: NaN
        });
      });
      labelInset = maxMeasuredLabelWidth + labelSpacing;
    }
    const nodeCount = nodeGraph.size;
    let radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth - labelInset;
    let spacingSweep = nodeSpacing / radius;
    if (labelInset !== 0 && (nodeCount * spacingSweep >= 1.5 * Math.PI || radius <= 0)) {
      labelData = [];
      radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth;
      spacingSweep = nodeSpacing / radius;
    }
    if (nodeCount * spacingSweep >= 2 * Math.PI || radius <= 0) {
      Logger9.warnOnce("There was insufficient space to display the Chord Series.");
      return {
        itemId: this.id,
        nodeData: [],
        labelData: []
      };
    }
    const innerRadius = radius;
    const outerRadius = radius + nodeWidth;
    const sizeScale = Math.max((2 * Math.PI - nodeCount * spacingSweep) / totalSize, 0);
    let nodeAngle = 0;
    nodeGraph.forEach(({ datum: node }) => {
      node.innerRadius = innerRadius;
      node.outerRadius = outerRadius;
      node.startAngle = nodeAngle;
      node.endAngle = nodeAngle + node.size * sizeScale;
      nodeAngle = node.endAngle + spacingSweep;
      const midR = (node.innerRadius + node.outerRadius) / 2;
      const midAngle = nodeMidAngle(node);
      node.midPoint = {
        x: node.centerX + midR * Math.cos(midAngle),
        y: node.centerY + midR * Math.sin(midAngle)
      };
    });
    const nodeData = [];
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {
      const midAngle = nodeMidAngle(node);
      const combinedLinks = [
        ...linksBefore.map((l) => ({
          link: l.link,
          distance: angleBetween3(nodeMidAngle(l.node.datum), midAngle),
          after: false
        })),
        ...linksAfter.map((l) => ({
          link: l.link,
          distance: angleBetween3(nodeMidAngle(l.node.datum), midAngle),
          after: true
        }))
      ];
      let linkAngle = node.startAngle;
      combinedLinks.sort((a, b) => a.distance - b.distance).forEach(({ link, after }) => {
        const linkSweep = link.size * sizeScale;
        if (after) {
          link.startAngle1 = linkAngle;
          link.endAngle1 = linkAngle + linkSweep;
        } else {
          link.startAngle2 = linkAngle;
          link.endAngle2 = linkAngle + linkSweep;
        }
        linkAngle += link.size * sizeScale;
      });
      nodeData.push(node);
    });
    const { tension } = this.properties.link;
    links.forEach((link) => {
      link.radius = radius;
      const outer = bezierControlPoints({
        radius,
        startAngle: link.startAngle1,
        endAngle: link.endAngle2,
        tension
      });
      const inner = bezierControlPoints({
        radius,
        startAngle: link.startAngle2,
        endAngle: link.endAngle1,
        tension
      });
      const outerX = evaluateBezier(...outer.x, 0.5);
      const outerY = evaluateBezier(...outer.y, 0.5);
      const innerX = evaluateBezier(...inner.x, 0.5);
      const innerY = evaluateBezier(...inner.y, 0.5);
      link.midPoint = {
        x: link.centerX + (outerX + innerX) / 2,
        y: link.centerY + (outerY + innerY) / 2
      };
      nodeData.push(link);
    });
    labelData.forEach((label) => {
      const node = nodeGraph.get(label.id)?.datum;
      if (node == null)
        return;
      label.radius = outerRadius + labelSpacing;
      label.angle = normalizeAngle3605(node.startAngle + angleBetween3(node.startAngle, node.endAngle) / 2);
    });
    labelData.sort((a, b) => a.angle - b.angle);
    let minAngle = Infinity;
    let maxAngle = -Infinity;
    labelData = labelData.filter((label) => {
      const labelHeight = fontSize * Text2.defaultLineHeightRatio;
      const da = Math.atan2(labelHeight / 2, label.radius);
      const a0 = label.angle - da;
      const a1 = label.angle + da;
      if (isBetweenAngles(minAngle, a0, a1))
        return false;
      if (isBetweenAngles(maxAngle, a0, a1))
        return false;
      minAngle = Math.min(a0, minAngle);
      maxAngle = Math.max(a1, maxAngle);
      return true;
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
    labelSelection.each((label, { text: text2, centerX, centerY, radius, angle }) => {
      label.visible = true;
      label.translationX = centerX + radius * Math.cos(angle);
      label.translationY = centerY + radius * Math.sin(angle);
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textBaseline = "middle";
      if (Math.cos(angle) >= 0) {
        label.textAlign = "left";
        label.rotation = angle;
      } else {
        label.textAlign = "right";
        label.rotation = angle - Math.PI;
      }
    });
  }
  async updateNodeSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId2([datum.type, datum.id]));
  }
  async updateNodeNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { fromKey, toKey, sizeKey } = this.properties;
    const {
      fill: baseFill,
      fillOpacity,
      stroke: baseStroke,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      itemStyler
    } = properties.node;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.node.strokeWidth);
    datumSelection.each((sector, datum) => {
      const fill = baseFill ?? datum.fill;
      const stroke2 = baseStroke ?? datum.stroke;
      let format;
      if (itemStyler != null) {
        const { label, size } = datum;
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          label,
          size,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: isHighlight
        });
      }
      sector.centerX = datum.centerX;
      sector.centerY = datum.centerY;
      sector.innerRadius = datum.innerRadius;
      sector.outerRadius = datum.outerRadius;
      sector.startAngle = datum.startAngle;
      sector.endAngle = datum.endAngle;
      sector.fill = highlightStyle?.fill ?? format?.fill ?? fill;
      sector.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      sector.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      sector.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      sector.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;
      sector.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      sector.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
      sector.inset = sector.strokeWidth / 2;
    });
  }
  async updateLinkSelection(opts) {
    return opts.datumSelection.update(
      opts.nodeData,
      void 0,
      (datum) => createDatumId2([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])
    );
  }
  async updateLinkNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { fromKey, toKey, sizeKey } = properties;
    const {
      fill: baseFill,
      fillOpacity,
      stroke: baseStroke,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      tension,
      itemStyler
    } = properties.link;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.link.strokeWidth);
    datumSelection.each((link, datum) => {
      const fill = baseFill ?? datum.fromNode.fill;
      const stroke2 = baseStroke ?? datum.fromNode.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          tension,
          highlighted: isHighlight
        });
      }
      link.centerX = datum.centerX;
      link.centerY = datum.centerY;
      link.radius = datum.radius;
      link.startAngle1 = datum.startAngle1;
      link.endAngle1 = datum.endAngle1;
      link.startAngle2 = datum.startAngle2;
      link.endAngle2 = datum.endAngle2;
      link.fill = highlightStyle?.fill ?? format?.fill ?? fill;
      link.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      link.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      link.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      link.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;
      link.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      link.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
      link.tension = format?.tension ?? tension;
    });
  }
  resetAnimation(_chartAnimationPhase) {
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;
    const { datum, itemId } = nodeDatum;
    let title;
    const contentLines = [];
    let fill;
    if (nodeDatum.type === 0 /* Link */) {
      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, tension, itemStyler } = properties.link;
      const { fromNode, toNode, size } = nodeDatum;
      title = `${fromNode.label ?? fromNode.id} - ${toNode.label ?? toNode.id}`;
      if (sizeKey != null) {
        contentLines.push(sanitizeHtml3(`${sizeName ?? sizeKey}: ` + size));
      }
      fill = properties.link.fill ?? fromNode.fill;
      const stroke2 = properties.link.stroke ?? fromNode.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          tension,
          highlighted: true
        });
      }
      fill = format?.fill ?? fill;
    } else {
      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.node;
      const { id, label, size } = nodeDatum;
      title = label ?? id;
      if (sizeKey != null) {
        contentLines.push(sanitizeHtml3(`${sizeName ?? sizeKey}: ` + size));
      }
      fill = properties.link.fill ?? nodeDatum.fill;
      const stroke2 = properties.link.stroke ?? nodeDatum.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          label,
          size,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: true
        });
      }
      fill = format?.fill ?? nodeDatum.fill;
    }
    const content = contentLines.join("<br>");
    const color = fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        title,
        color,
        itemId,
        fromKey,
        toKey,
        sizeKey,
        sizeName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getLabelData() {
    return [];
  }
  computeFocusBounds({
    datumIndex
  }) {
    const datum = this.contextNodeData?.nodeData[datumIndex];
    if (datum?.type === 1 /* Node */) {
      for (const node of this.nodeSelection) {
        if (node.datum === datum) {
          return node.node;
        }
      }
      return void 0;
    } else if (datum?.type === 0 /* Link */) {
      for (const link of this.linkSelection) {
        if (link.datum === datum) {
          return link.node;
        }
      }
      return void 0;
    }
  }
};
ChordSeries.className = "ChordSeries";
ChordSeries.type = "chord";

// packages/ag-charts-enterprise/src/series/chord/chordModule.ts
var { DEFAULT_FONT_FAMILY, DEFAULT_LABEL_COLOUR } = _Theme15;
var ChordModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["flow-proportion"],
  solo: true,
  identifier: "chord",
  tooltipDefaults: { range: "exact" },
  moduleFactory: (ctx) => new ChordSeries(ctx),
  themeTemplate: {
    series: {
      highlightStyle: {
        series: {
          dimOpacity: 0.2
        }
      },
      label: {
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR,
        spacing: 5,
        maxWidth: 100
      },
      node: {
        spacing: 8,
        width: 10,
        strokeWidth: 0
      },
      link: {
        fillOpacity: 0.5,
        strokeWidth: 0,
        tension: 0.4
      }
    },
    legend: {
      enabled: false,
      toggleSeries: false
    }
  },
  paletteFactory({ takeColors, colorsCount }) {
    const { fills, strokes } = takeColors(colorsCount);
    return {
      fills,
      strokes
    };
  }
};

// packages/ag-charts-enterprise/src/series/heatmap/heatmapModule.ts
import { _Theme as _Theme17 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeries.ts
import { _ModuleSupport as _ModuleSupport108, _Scale as _Scale11, _Scene as _Scene50, _Util as _Util69 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/util/labelFormatter.ts
import { _ModuleSupport as _ModuleSupport105, _Util as _Util68 } from "ag-charts-community";
var { CachedTextMeasurerPool: CachedTextMeasurerPool4, TextUtils: TextUtils3, TextWrapper: TextWrapper5, findMaxValue } = _ModuleSupport105;
var { Logger: Logger10 } = _Util68;
function generateLabelSecondaryLabelFontSizeCandidates(label, secondaryLabel) {
  const { fontSize: labelFontSize, minimumFontSize: labelMinimumFontSize = labelFontSize } = label;
  const {
    fontSize: secondaryLabelFontSize,
    minimumFontSize: secondaryLabelMinimumFontSize = secondaryLabelFontSize
  } = secondaryLabel;
  const labelTracks = labelFontSize - labelMinimumFontSize;
  const secondaryLabelTracks = secondaryLabelFontSize - secondaryLabelMinimumFontSize;
  let currentLabelFontSize = label.fontSize;
  let currentSecondaryLabelFontSize = secondaryLabel.fontSize;
  const out = [{ labelFontSize, secondaryLabelFontSize }];
  while (currentLabelFontSize > labelMinimumFontSize || currentSecondaryLabelFontSize > secondaryLabelMinimumFontSize) {
    const labelProgress = labelTracks > 0 ? (currentLabelFontSize - labelMinimumFontSize) / labelTracks : -1;
    const secondaryLabelProgress = secondaryLabelTracks > 0 ? (currentSecondaryLabelFontSize - secondaryLabelMinimumFontSize) / secondaryLabelTracks : -1;
    if (labelProgress > secondaryLabelProgress) {
      currentLabelFontSize--;
    } else {
      currentSecondaryLabelFontSize--;
    }
    out.push({
      labelFontSize: currentLabelFontSize,
      secondaryLabelFontSize: currentSecondaryLabelFontSize
    });
  }
  out.reverse();
  return out;
}
function getLineHeight(labelProps, fontSize) {
  if (labelProps.lineHeight != null && labelProps.fontSize != null) {
    return labelProps.lineHeight * fontSize / labelProps.fontSize;
  } else {
    return TextUtils3.getLineHeight(fontSize);
  }
}
function formatStackedLabels(labelValue, labelProps, secondaryLabelValue, secondaryLabelProps, { padding }, sizeFittingHeight) {
  const { spacing = 0 } = labelProps;
  const widthAdjust = 2 * padding;
  const heightAdjust = 2 * padding + spacing;
  const minimumHeight = (labelProps.minimumFontSize ?? labelProps.fontSize) + (secondaryLabelProps.minimumFontSize ?? secondaryLabelProps.fontSize);
  if (minimumHeight > sizeFittingHeight(minimumHeight + heightAdjust, false).height - heightAdjust)
    return;
  const fontSizeCandidates = generateLabelSecondaryLabelFontSizeCandidates(labelProps, secondaryLabelProps);
  const labelTextSizeProps = {
    fontFamily: labelProps.fontFamily,
    fontSize: labelProps.fontSize,
    fontStyle: labelProps.fontStyle,
    fontWeight: labelProps.fontWeight
  };
  const secondaryLabelTextSizeProps = {
    fontFamily: secondaryLabelProps.fontFamily,
    fontSize: secondaryLabelProps.fontSize,
    fontStyle: secondaryLabelProps.fontStyle,
    fontWeight: secondaryLabelProps.fontWeight
  };
  let label;
  let secondaryLabel;
  return findMaxValue(0, fontSizeCandidates.length - 1, (index) => {
    const { labelFontSize, secondaryLabelFontSize } = fontSizeCandidates[index];
    const allowTruncation = index === 0;
    const labelLineHeight = getLineHeight(labelProps, labelFontSize);
    const secondaryLabelLineHeight = getLineHeight(secondaryLabelProps, secondaryLabelFontSize);
    const sizeFitting = sizeFittingHeight(
      labelLineHeight + secondaryLabelLineHeight + heightAdjust,
      allowTruncation
    );
    const availableWidth = sizeFitting.width - widthAdjust;
    const availableHeight = sizeFitting.height - heightAdjust;
    if (labelLineHeight + secondaryLabelLineHeight > availableHeight)
      return;
    if (label == null || label.fontSize !== labelFontSize) {
      labelTextSizeProps.fontSize = labelFontSize;
      label = wrapLabel(
        labelProps,
        labelValue,
        availableWidth,
        availableHeight,
        labelTextSizeProps,
        labelProps.wrapping,
        allowTruncation ? labelProps.overflowStrategy : "hide"
      );
    }
    if (label == null || label.width > availableWidth || label.height > availableHeight)
      return;
    if (secondaryLabel == null || secondaryLabel.fontSize !== secondaryLabelFontSize) {
      secondaryLabelTextSizeProps.fontSize = secondaryLabelFontSize;
      secondaryLabel = wrapLabel(
        secondaryLabelProps,
        secondaryLabelValue,
        availableWidth,
        availableHeight,
        secondaryLabelTextSizeProps,
        secondaryLabelProps.wrapping,
        allowTruncation ? secondaryLabelProps.overflowStrategy : "hide"
      );
    }
    if (secondaryLabel == null)
      return;
    const totalLabelHeight = label.height + secondaryLabel.height;
    if (secondaryLabel.width > availableWidth || totalLabelHeight > availableHeight)
      return;
    return {
      width: Math.max(label.width, secondaryLabel.width),
      height: totalLabelHeight + spacing,
      meta: sizeFitting.meta,
      label,
      secondaryLabel
    };
  });
}
function formatSingleLabel(value, props, { padding }, sizeFittingHeight) {
  const sizeAdjust = 2 * padding;
  const minimumFontSize = Math.min(props.minimumFontSize ?? props.fontSize, props.fontSize);
  const textSizeProps = {
    fontFamily: props.fontFamily,
    fontSize: props.fontSize,
    fontStyle: props.fontStyle,
    fontWeight: props.fontWeight
  };
  return findMaxValue(minimumFontSize, props.fontSize, (fontSize) => {
    const lineHeight = getLineHeight(props, fontSize);
    const allowTruncation = fontSize === minimumFontSize;
    const sizeFitting = sizeFittingHeight(lineHeight + sizeAdjust, allowTruncation);
    const availableWidth = sizeFitting.width - sizeAdjust;
    const availableHeight = sizeFitting.height - sizeAdjust;
    if (lineHeight > availableHeight)
      return;
    textSizeProps.fontSize = fontSize;
    const lines = TextWrapper5.wrapLines(value, {
      maxWidth: availableWidth,
      maxHeight: availableHeight,
      font: textSizeProps,
      textWrap: props.wrapping,
      overflow: allowTruncation ? props.overflowStrategy : "hide"
    });
    if (!lines.length)
      return;
    const clippedLabel = clipLines(lines, {
      lineHeight,
      font: textSizeProps,
      maxWidth: availableWidth,
      maxHeight: availableHeight
    });
    if (!clippedLabel)
      return;
    return [{ fontSize, lineHeight, ...clippedLabel }, sizeFitting.meta];
  });
}
function hasInvalidFontSize(label) {
  return label?.minimumFontSize != null && label?.fontSize && label?.minimumFontSize > label?.fontSize;
}
function formatLabels(baseLabelValue, labelProps, baseSecondaryLabelValue, secondaryLabelProps, layoutParams, sizeFittingHeight) {
  const labelValue = labelProps.enabled ? baseLabelValue : void 0;
  const secondaryLabelValue = secondaryLabelProps.enabled ? baseSecondaryLabelValue : void 0;
  if (hasInvalidFontSize(labelProps) || hasInvalidFontSize(secondaryLabelProps)) {
    Logger10.warnOnce(`minimumFontSize should be set to a value less than or equal to the font size`);
  }
  let value;
  if (labelValue != null && secondaryLabelValue != null) {
    value = formatStackedLabels(
      labelValue,
      labelProps,
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  let labelMeta;
  if (value == null && labelValue != null) {
    labelMeta = formatSingleLabel(labelValue, labelProps, layoutParams, sizeFittingHeight);
  }
  if (labelMeta != null) {
    const [label, meta] = labelMeta;
    value = {
      width: label.width,
      height: label.height,
      meta,
      label,
      secondaryLabel: void 0
    };
  }
  let secondaryLabelMeta;
  if (value == null && labelValue == null && secondaryLabelValue != null) {
    secondaryLabelMeta = formatSingleLabel(
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  if (secondaryLabelMeta != null) {
    const [secondaryLabel, meta] = secondaryLabelMeta;
    value = {
      width: secondaryLabel.width,
      height: secondaryLabel.height,
      meta,
      label: void 0,
      secondaryLabel
    };
  }
  return value;
}
function wrapLabel(props, text2, maxWidth, maxHeight, font2, textWrap, overflow) {
  const lines = TextWrapper5.wrapLines(text2, { maxWidth, maxHeight, font: font2, textWrap, overflow });
  if (!lines.length)
    return;
  const lineHeight = getLineHeight(props, font2.fontSize);
  const { width } = CachedTextMeasurerPool4.measureLines(lines, { font: font2 });
  return {
    width,
    lineHeight,
    text: lines.join("\n"),
    height: lines.length * lineHeight,
    fontSize: font2.fontSize
  };
}
function clipLines(lines, { font: font2, lineHeight = TextUtils3.defaultLineHeight, maxWidth, maxHeight = Infinity }) {
  let height = lineHeight * lines.length;
  while (height > maxHeight) {
    if (lines.length === 1)
      return;
    lines.pop();
    lines[lines.length - 1] = TextWrapper5.appendEllipsis(lines.at(-1));
    height = lineHeight * lines.length;
  }
  const metrics = CachedTextMeasurerPool4.measureLines(lines, { font: font2 });
  let text2, width;
  if (metrics.width > maxWidth) {
    const clippedLines = [];
    width = 0;
    for (const line of metrics.lineMetrics) {
      if (line.width > maxWidth) {
        if (!clippedLines.length)
          return;
        break;
      }
      clippedLines.push(line.text);
      width = Math.max(width, line.width);
    }
    text2 = TextWrapper5.appendEllipsis(clippedLines.join("\n"));
  } else {
    text2 = lines.join("\n");
    width = metrics.width;
  }
  return { text: text2, width, height };
}

// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport107 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/util/autoSizedLabel.ts
import { _ModuleSupport as _ModuleSupport106, _Scene as _Scene49 } from "ag-charts-community";
var { Validate: Validate48, NUMBER: NUMBER11, POSITIVE_NUMBER: POSITIVE_NUMBER14, TEXT_WRAP, OVERFLOW_STRATEGY } = _ModuleSupport106;
var BaseAutoSizedLabel = class extends _Scene49.Label {
  constructor() {
    super(...arguments);
    this.wrapping = "on-space";
    this.overflowStrategy = "ellipsis";
  }
};
__decorateClass([
  Validate48(TEXT_WRAP)
], BaseAutoSizedLabel.prototype, "wrapping", 2);
__decorateClass([
  Validate48(OVERFLOW_STRATEGY)
], BaseAutoSizedLabel.prototype, "overflowStrategy", 2);
__decorateClass([
  Validate48(POSITIVE_NUMBER14, { optional: true })
], BaseAutoSizedLabel.prototype, "lineHeight", 2);
__decorateClass([
  Validate48(POSITIVE_NUMBER14, { optional: true })
], BaseAutoSizedLabel.prototype, "minimumFontSize", 2);
var AutoSizedLabel = class extends BaseAutoSizedLabel {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass([
  Validate48(NUMBER11)
], AutoSizedLabel.prototype, "spacing", 2);
var AutoSizedSecondaryLabel = class extends BaseAutoSizedLabel {
};

// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeriesProperties.ts
var {
  CartesianSeriesProperties,
  SeriesTooltip: SeriesTooltip5,
  Validate: Validate49,
  AND: AND7,
  ARRAY: ARRAY6,
  COLOR_STRING: COLOR_STRING12,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY2,
  FUNCTION: FUNCTION8,
  OBJECT: OBJECT20,
  POSITIVE_NUMBER: POSITIVE_NUMBER15,
  RATIO: RATIO17,
  STRING: STRING24,
  TEXT_ALIGN: TEXT_ALIGN2,
  VERTICAL_ALIGN
} = _ModuleSupport107;
var HeatmapSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.colorRange = ["black", "black"];
    this.stroke = "black";
    this.strokeWidth = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.itemPadding = 0;
    this.label = new AutoSizedLabel();
    this.tooltip = new SeriesTooltip5();
  }
};
__decorateClass([
  Validate49(STRING24, { optional: true })
], HeatmapSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate49(STRING24)
], HeatmapSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate49(STRING24)
], HeatmapSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate49(STRING24, { optional: true })
], HeatmapSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate49(STRING24, { optional: true })
], HeatmapSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate49(STRING24, { optional: true })
], HeatmapSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate49(STRING24, { optional: true })
], HeatmapSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate49(AND7(COLOR_STRING_ARRAY2, ARRAY6.restrict({ minLength: 1 })))
], HeatmapSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate49(COLOR_STRING12, { optional: true })
], HeatmapSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate49(RATIO17, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate49(POSITIVE_NUMBER15, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate49(TEXT_ALIGN2)
], HeatmapSeriesProperties.prototype, "textAlign", 2);
__decorateClass([
  Validate49(VERTICAL_ALIGN)
], HeatmapSeriesProperties.prototype, "verticalAlign", 2);
__decorateClass([
  Validate49(POSITIVE_NUMBER15)
], HeatmapSeriesProperties.prototype, "itemPadding", 2);
__decorateClass([
  Validate49(FUNCTION8, { optional: true })
], HeatmapSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate49(OBJECT20)
], HeatmapSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate49(OBJECT20)
], HeatmapSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeries.ts
var {
  SeriesNodePickMode: SeriesNodePickMode4,
  computeBarFocusBounds: computeBarFocusBounds4,
  getMissCount,
  valueProperty: valueProperty7,
  ChartAxisDirection: ChartAxisDirection14,
  DEFAULT_CARTESIAN_DIRECTION_KEYS,
  DEFAULT_CARTESIAN_DIRECTION_NAMES
} = _ModuleSupport108;
var { Rect: Rect4, PointerEvents } = _Scene50;
var { ColorScale } = _Scale11;
var { sanitizeHtml: sanitizeHtml4, Logger: Logger11 } = _Util69;
var HeatmapSeriesNodeEvent = class extends _ModuleSupport108.CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.colorKey = series.properties.colorKey;
  }
};
var textAlignFactors = {
  left: -0.5,
  center: 0,
  right: -0.5
};
var verticalAlignFactors = {
  top: -0.5,
  middle: 0,
  bottom: -0.5
};
var HeatmapSeries = class extends _ModuleSupport108.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pickModes: [SeriesNodePickMode4.NEAREST_NODE, SeriesNodePickMode4.EXACT_SHAPE_MATCH],
      pathsPerSeries: [],
      hasMarkers: false,
      hasHighlightedLabels: true
    });
    this.properties = new HeatmapSeriesProperties();
    this.NodeEvent = HeatmapSeriesNodeEvent;
    this.colorScale = new ColorScale();
  }
  async processData(dataController) {
    const xAxis = this.axes[ChartAxisDirection14.X];
    const yAxis = this.axes[ChartAxisDirection14.Y];
    if (!xAxis || !yAxis || !this.properties.isValid() || !this.data?.length) {
      return;
    }
    const { xKey, yKey, colorRange, colorKey } = this.properties;
    const xScale = this.axes[ChartAxisDirection14.X]?.scale;
    const yScale = this.axes[ChartAxisDirection14.Y]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const colorScaleType = this.colorScale.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty7(xKey, xScaleType, { id: "xValue" }),
        valueProperty7(yKey, yScaleType, { id: "yValue" }),
        ...colorKey ? [valueProperty7(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    if (this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      this.colorScale.domain = processedData.domain.values[colorKeyIdx];
      this.colorScale.range = colorRange;
      this.colorScale.update();
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorDataIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount(this, processedData.defs.values[colorDataIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === ChartAxisDirection14.X) {
      return dataModel.getDomain(this, `xValue`, "value", processedData);
    } else {
      return dataModel.getDomain(this, `yValue`, "value", processedData);
    }
  }
  async createNodeData() {
    const { data, visible, axes, dataModel } = this;
    const xAxis = axes[ChartAxisDirection14.X];
    const yAxis = axes[ChartAxisDirection14.Y];
    if (!(data && dataModel && visible && xAxis && yAxis)) {
      return;
    }
    if (xAxis.type !== "category" || yAxis.type !== "category") {
      Logger11.warnOnce(
        `Heatmap series expected axes to have "category" type, but received "${xAxis.type}" and "${yAxis.type}" instead.`
      );
      return;
    }
    const {
      xKey,
      xName,
      yKey,
      yName,
      colorKey,
      colorName,
      textAlign,
      verticalAlign,
      itemPadding,
      colorRange,
      label
    } = this.properties;
    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const colorScaleValid = this.isColorScaleValid();
    const nodeData = [];
    const labelData = [];
    const width = xScale.bandwidth ?? 10;
    const height = yScale.bandwidth ?? 10;
    const textAlignFactor = (width - 2 * itemPadding) * textAlignFactors[textAlign];
    const verticalAlignFactor = (height - 2 * itemPadding) * verticalAlignFactors[verticalAlign];
    const sizeFittingHeight = () => ({ width, height, meta: null });
    for (const { values, datum } of this.processedData?.data ?? []) {
      const xDatum = values[xDataIdx];
      const yDatum = values[yDataIdx];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      const colorValue = values[colorDataIdx ?? -1];
      const fill = colorScaleValid && colorValue != null ? this.colorScale.convert(colorValue) : colorRange[0];
      const labelText = colorValue == null ? void 0 : this.getLabelText(label, {
        value: colorValue,
        datum,
        colorKey,
        colorName,
        xKey,
        yKey,
        xName,
        yName
      });
      const labels = formatLabels(
        labelText,
        this.properties.label,
        void 0,
        this.properties.label,
        { padding: itemPadding },
        sizeFittingHeight
      );
      const point = { x, y, size: 0 };
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        xValue: xDatum,
        yValue: yDatum,
        colorValue,
        datum,
        point,
        width,
        height,
        fill,
        midPoint: { x, y },
        missing: colorValue == null
      });
      if (labels?.label != null) {
        const { text: text2, fontSize, lineHeight, height: labelHeight } = labels.label;
        const { fontStyle, fontFamily, fontWeight, color } = this.properties.label;
        const lx = point.x + textAlignFactor * (width - 2 * itemPadding);
        const ly = point.y + verticalAlignFactor * (height - 2 * itemPadding) - (labels.height - labelHeight) * 0.5;
        labelData.push({
          series: this,
          itemId: yKey,
          datum,
          text: text2,
          fontSize,
          lineHeight,
          fontStyle,
          fontFamily,
          fontWeight,
          color,
          textAlign,
          verticalAlign,
          x: lx,
          y: ly
        });
      }
    }
    return {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  nodeFactory() {
    return new Rect4();
  }
  async updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data);
  }
  async updateDatumNodes(opts) {
    const { isHighlight: isDatumHighlighted } = opts;
    const {
      id: seriesId,
      ctx: { callbackCache },
      properties
    } = this;
    const { xKey, yKey, colorKey, itemStyler } = properties;
    const highlightStyle = isDatumHighlighted ? properties.highlightStyle.item : void 0;
    const fillOpacity = highlightStyle?.fillOpacity ?? 1;
    const stroke2 = highlightStyle?.stroke ?? properties.stroke;
    const strokeWidth = highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth);
    const strokeOpacity = highlightStyle?.strokeOpacity ?? properties.strokeOpacity ?? 1;
    const xAxis = this.axes[ChartAxisDirection14.X];
    const [visibleMin, visibleMax] = xAxis?.visibleRange ?? [];
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    const crisp = !isZoomed;
    opts.datumSelection.each((rect, nodeDatum) => {
      const { datum, point, width, height } = nodeDatum;
      const fill = highlightStyle?.fill ?? nodeDatum.fill;
      let format;
      if (itemStyler) {
        format = callbackCache.call(itemStyler, {
          datum,
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          strokeWidth,
          highlighted: isDatumHighlighted,
          xKey,
          yKey,
          colorKey,
          seriesId
        });
      }
      rect.crisp = crisp;
      rect.x = Math.floor(point.x - width / 2);
      rect.y = Math.floor(point.y - height / 2);
      rect.width = Math.ceil(width);
      rect.height = Math.ceil(height);
      rect.fill = format?.fill ?? fill;
      rect.fillOpacity = format?.fillOpacity ?? fillOpacity;
      rect.stroke = format?.stroke ?? stroke2;
      rect.strokeWidth = format?.strokeWidth ?? strokeWidth;
      rect.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;
    });
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    const { enabled } = this.properties.label;
    const data = enabled ? labelData : [];
    return labelSelection.update(data);
  }
  async updateLabelNodes(opts) {
    opts.labelSelection.each((text2, datum) => {
      text2.text = datum.text;
      text2.fontSize = datum.fontSize;
      text2.lineHeight = datum.lineHeight;
      text2.fontStyle = datum.fontStyle;
      text2.fontFamily = datum.fontFamily;
      text2.fontWeight = datum.fontWeight;
      text2.fill = datum.color;
      text2.textAlign = datum.textAlign;
      text2.textBaseline = datum.verticalAlign;
      text2.x = datum.x;
      text2.y = datum.y;
      text2.pointerEvents = PointerEvents.None;
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes[ChartAxisDirection14.X];
    const yAxis = this.axes[ChartAxisDirection14.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return _ModuleSupport108.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      xKey,
      yKey,
      colorKey,
      xName,
      yName,
      colorName,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity = 1,
      colorRange,
      itemStyler,
      tooltip
    } = this.properties;
    const {
      colorScale,
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { datum, xValue, yValue, colorValue, itemId } = nodeDatum;
    const fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange[0];
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        datum,
        xKey,
        yKey,
        colorKey,
        fill,
        fillOpacity: 1,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        highlighted: false,
        seriesId
      });
    }
    const color = format?.fill ?? fill ?? "gray";
    const title = this.properties.title ?? yName;
    const xString = sanitizeHtml4(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml4(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml4(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml4(yName ?? yKey)}</b>: ${yString}`;
    if (colorKey) {
      content = `<b>${sanitizeHtml4(colorName ?? colorKey)}</b>: ${sanitizeHtml4(colorValue)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        xKey,
        yKey,
        xName,
        yName,
        title,
        color,
        colorKey,
        colorName,
        itemId
      }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "gradient" || !this.data?.length || !this.properties.isValid() || !this.isColorScaleValid() || !this.dataModel) {
      return [];
    }
    return [
      {
        legendType: "gradient",
        enabled: this.visible,
        seriesId: this.id,
        colorName: this.properties.colorName,
        colorDomain: this.processedData.domain.values[this.dataModel.resolveProcessedDataIndexById(this, "colorValue")],
        colorRange: this.properties.colorRange
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled && Boolean(this.properties.colorKey);
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    const datum = this.contextNodeData?.nodeData[datumIndex];
    if (datum === void 0)
      return void 0;
    const { width, height, midPoint } = datum;
    const focusRect = { x: midPoint.x - width / 2, y: midPoint.y - height / 2, width, height };
    return computeBarFocusBounds4(focusRect, this.contentGroup, seriesRect);
  }
};
HeatmapSeries.className = "HeatmapSeries";
HeatmapSeries.type = "heatmap";

// packages/ag-charts-enterprise/src/series/heatmap/heatmapThemes.ts
import { _Theme as _Theme16 } from "ag-charts-community";
var HEATMAP_SERIES_THEME = {
  series: {
    label: {
      enabled: false,
      color: _Theme16.DEFAULT_LABEL_COLOUR,
      fontSize: _Theme16.FONT_SIZE.SMALL,
      fontFamily: _Theme16.DEFAULT_FONT_FAMILY,
      wrapping: "on-space",
      overflowStrategy: "ellipsis"
    },
    itemPadding: 3
  },
  gradientLegend: {
    enabled: true
  }
};

// packages/ag-charts-enterprise/src/series/heatmap/heatmapModule.ts
var HeatmapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "heatmap",
  moduleFactory: (ctx) => new HeatmapSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme17.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme17.POSITION.LEFT
    },
    {
      type: _Theme17.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme17.POSITION.BOTTOM
    }
  ],
  themeTemplate: HEATMAP_SERIES_THEME,
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    const defaultColorRange = themeTemplateParameters.get(_Theme17.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    const defaultBackgroundColor = themeTemplateParameters.get(_Theme17.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) ?? "white";
    const { fills, strokes } = takeColors(colorsCount);
    return {
      stroke: userPalette === "inbuilt" ? backgroundFill : strokes[0],
      colorRange: userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]]
    };
  }
};

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeModule.ts
import { _Theme as _Theme18 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/gauge-util/defaultColorStops.ts
import { _Scale as _Scale12 } from "ag-charts-community";
var { ColorScale: ColorScale2 } = _Scale12;
function defaultColorStops(colors) {
  if (colors == null)
    return [];
  const colorScale = new ColorScale2();
  colorScale.domain = [0, 1];
  colorScale.range = colors;
  const stopCount = 5;
  return Array.from({ length: 5 }, (_, i) => {
    return colorScale.convert(i / (stopCount - 1));
  });
}

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeSeries.ts
import {
  _ModuleSupport as _ModuleSupport114,
  _Scene as _Scene53,
  _Util as _Util73
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/gauge-util/lineMarker.ts
import { Marker } from "ag-charts-community";
var LineMarker = class extends Marker {
  updatePath() {
    const { x, y, path, size } = this;
    path.clear();
    path.moveTo(x, y - size / 2);
    path.lineTo(x, y + size / 2);
  }
};
LineMarker.className = "LineMarker";

// packages/ag-charts-enterprise/src/series/gauge-util/stops.ts
import { _ModuleSupport as _ModuleSupport110, _Scale as _Scale13, _Util as _Util71 } from "ag-charts-community";
var { BaseProperties: BaseProperties21, Validate: Validate50, COLOR_STRING: COLOR_STRING13, NUMBER: NUMBER12 } = _ModuleSupport110;
var { ColorScale: ColorScale3 } = _Scale13;
var { Logger: Logger12 } = _Util71;
var GaugeStopProperties = class extends BaseProperties21 {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Validate50(NUMBER12, { optional: true })
], GaugeStopProperties.prototype, "stop", 2);
__decorateClass([
  Validate50(COLOR_STRING13, { optional: true })
], GaugeStopProperties.prototype, "color", 2);
function stopsAreAscending(fills) {
  let currentStop;
  for (let i = 0; i < fills.length; i += 1) {
    const { stop } = fills[i];
    if (stop == null) {
      continue;
    } else if (currentStop != null && stop < currentStop) {
      return false;
    }
    currentStop = stop;
  }
  return true;
}
function discreteColorStops(colorStops) {
  return colorStops.flatMap((colorStop, i) => {
    const { offset } = colorStop;
    const nextColor = colorStops.at(i + 1)?.color;
    return nextColor != null ? [colorStop, { offset, color: nextColor }] : [colorStop];
  });
}
function getDefaultColorStops(defaultColorStops2, fillMode) {
  const stopOffset = fillMode === "discrete" ? 1 : 0;
  const colorStops = defaultColorStops2.map(
    (color, index, { length }) => ({
      offset: (index + stopOffset) / (length - 1 + stopOffset),
      color
    })
  );
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
function getColorStops(fills, defaultColorStops2, domain, fillMode) {
  if (fills.length === 0) {
    return getDefaultColorStops(defaultColorStops2, fillMode);
  } else if (!stopsAreAscending(fills)) {
    Logger12.warnOnce(`[fills] must have the stops defined in ascending order`);
    return [];
  }
  const d0 = Math.min(...domain);
  const d1 = Math.max(...domain);
  const isDiscrete = fillMode === "discrete";
  const offsets = new Float64Array(fills.length);
  let previousDefinedStopIndex = 0;
  let nextDefinedStopIndex = -1;
  for (let i = 0; i < fills.length; i += 1) {
    const colorStop = fills[i];
    if (i >= nextDefinedStopIndex) {
      nextDefinedStopIndex = fills.length - 1;
      for (let j = i + 1; j < fills.length; j += 1) {
        if (fills[j].stop != null) {
          nextDefinedStopIndex = j;
          break;
        }
      }
    }
    let { stop } = colorStop;
    if (stop == null) {
      const stop0 = fills[previousDefinedStopIndex].stop;
      const stop1 = fills[nextDefinedStopIndex].stop;
      const value0 = stop0 ?? d0;
      const value1 = stop1 ?? d1;
      const stopOffset = isDiscrete && stop0 == null ? 1 : 0;
      stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);
    } else {
      previousDefinedStopIndex = i;
    }
    const offset = (stop - d0) / (d1 - d0);
    offsets[i] = offset;
  }
  let lastDefinedColor = fills.find((c) => c.color != null)?.color;
  let colorScale;
  const colorStops = fills.map(({ color }, i) => {
    const offset = offsets[i];
    if (color != null) {
      lastDefinedColor = color;
    } else if (lastDefinedColor != null) {
      color = lastDefinedColor;
    } else {
      if (colorScale == null) {
        colorScale = new ColorScale3();
        colorScale.domain = [0, 1];
        colorScale.range = defaultColorStops2;
      }
      color = colorScale.convert(offset);
    }
    return { offset, color };
  });
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport113, _Scene as _Scene51 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/gauge-util/properties.ts
import { _ModuleSupport as _ModuleSupport111 } from "ag-charts-community";
var { MARKER_SHAPE, UNION: UNION7, OR: OR5 } = _ModuleSupport111;
var FILL_MODE = UNION7(["continuous", "discrete"], "a fill mode");
var TARGET_MARKER_SHAPE = OR5(MARKER_SHAPE, UNION7(["line"], "a marker shape"));
var CORNER_MODE = UNION7(["container", "item"], "a corner mode");

// packages/ag-charts-enterprise/src/series/gauge-util/segmentation.ts
import { _ModuleSupport as _ModuleSupport112, _Util as _Util72 } from "ag-charts-community";
var { BaseProperties: BaseProperties22, Validate: Validate51, OBJECT: OBJECT21, BOOLEAN: BOOLEAN18, NUMBER: NUMBER13, NUMBER_ARRAY } = _ModuleSupport112;
var { Logger: Logger13 } = _Util72;
var GaugeSegmentationIntervalProperties = class extends BaseProperties22 {
  getSegments(scale, maxTicks) {
    const { values, step, count } = this;
    const d0 = Math.min(...scale.domain);
    const d1 = Math.max(...scale.domain);
    let ticks;
    if (values != null) {
      const segments = values.filter((v) => v > d0 && v < d1).sort((a, b) => a - b);
      ticks = [d0, ...segments, d1];
    } else if (step != null) {
      const segments = [];
      for (let i = d0; i < d1; i += step) {
        segments.push(i);
      }
      segments.push(d1);
      ticks = segments;
    } else if (count != null) {
      const segments = count + 1;
      ticks = Array.from({ length: segments + 1 }, (_, i) => i / segments * (d1 - d0) + d0);
    } else {
      ticks = scale.ticks?.();
    }
    if (ticks != null && ticks.length > maxTicks) {
      Logger13.warnOnce(
        `the configured segmentation results in more than 1 item per pixel, ignoring. Supply a segmentation configuration that results in larger segments or omit this configuration`
      );
      ticks = void 0;
    }
    ticks ?? (ticks = [d0, d1]);
    return ticks;
  }
};
__decorateClass([
  Validate51(NUMBER_ARRAY, { optional: true })
], GaugeSegmentationIntervalProperties.prototype, "values", 2);
__decorateClass([
  Validate51(NUMBER13, { optional: true })
], GaugeSegmentationIntervalProperties.prototype, "step", 2);
__decorateClass([
  Validate51(NUMBER13, { optional: true })
], GaugeSegmentationIntervalProperties.prototype, "count", 2);
var GaugeSegmentationProperties = class extends BaseProperties22 {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.interval = new GaugeSegmentationIntervalProperties();
    this.spacing = 0;
  }
};
__decorateClass([
  Validate51(BOOLEAN18)
], GaugeSegmentationProperties.prototype, "enabled", 2);
__decorateClass([
  Validate51(OBJECT21)
], GaugeSegmentationProperties.prototype, "interval", 2);
__decorateClass([
  Validate51(NUMBER13)
], GaugeSegmentationProperties.prototype, "spacing", 2);

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeSeriesProperties.ts
var {
  BaseProperties: BaseProperties23,
  SeriesTooltip: SeriesTooltip6,
  SeriesProperties: SeriesProperties2,
  PropertiesArray: PropertiesArray3,
  Validate: Validate52,
  BOOLEAN: BOOLEAN19,
  COLOR_STRING: COLOR_STRING14,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY3,
  FUNCTION: FUNCTION9,
  LINE_DASH: LINE_DASH9,
  NUMBER: NUMBER14,
  OBJECT_ARRAY,
  OBJECT: OBJECT22,
  POSITIVE_NUMBER: POSITIVE_NUMBER16,
  RATIO: RATIO18,
  STRING: STRING25,
  UNION: UNION8
} = _ModuleSupport113;
var { Label: Label4 } = _Scene51;
var TARGET_PLACEMENT = UNION8(["before", "after", "middle"], "a placement");
var DIRECTION = UNION8(["horizontal", "vertical"], "an orientation");
var LinearGaugeDefaultTargetLabelProperties = class extends Label4 {
};
__decorateClass([
  Validate52(NUMBER14, { optional: true })
], LinearGaugeDefaultTargetLabelProperties.prototype, "spacing", 2);
var LinearGaugeTargetProperties = class extends BaseProperties23 {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.label = new LinearGaugeDefaultTargetLabelProperties();
  }
};
__decorateClass([
  Validate52(STRING25, { optional: true })
], LinearGaugeTargetProperties.prototype, "text", 2);
__decorateClass([
  Validate52(NUMBER14)
], LinearGaugeTargetProperties.prototype, "value", 2);
__decorateClass([
  Validate52(TARGET_MARKER_SHAPE, { optional: true })
], LinearGaugeTargetProperties.prototype, "shape", 2);
__decorateClass([
  Validate52(TARGET_PLACEMENT, { optional: true })
], LinearGaugeTargetProperties.prototype, "placement", 2);
__decorateClass([
  Validate52(NUMBER14, { optional: true })
], LinearGaugeTargetProperties.prototype, "spacing", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16, { optional: true })
], LinearGaugeTargetProperties.prototype, "size", 2);
__decorateClass([
  Validate52(NUMBER14, { optional: true })
], LinearGaugeTargetProperties.prototype, "rotation", 2);
__decorateClass([
  Validate52(COLOR_STRING14, { optional: true })
], LinearGaugeTargetProperties.prototype, "fill", 2);
__decorateClass([
  Validate52(RATIO18, { optional: true })
], LinearGaugeTargetProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate52(COLOR_STRING14, { optional: true })
], LinearGaugeTargetProperties.prototype, "stroke", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16, { optional: true })
], LinearGaugeTargetProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate52(RATIO18, { optional: true })
], LinearGaugeTargetProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate52(LINE_DASH9, { optional: true })
], LinearGaugeTargetProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16, { optional: true })
], LinearGaugeTargetProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeTargetProperties.prototype, "label", 2);
var LinearGaugeBarProperties = class extends BaseProperties23 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.thicknessRatio = 1;
    this.fills = new PropertiesArray3(GaugeStopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate52(BOOLEAN19)
], LinearGaugeBarProperties.prototype, "enabled", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16, { optional: true })
], LinearGaugeBarProperties.prototype, "thickness", 2);
__decorateClass([
  Validate52(RATIO18)
], LinearGaugeBarProperties.prototype, "thicknessRatio", 2);
__decorateClass([
  Validate52(OBJECT_ARRAY)
], LinearGaugeBarProperties.prototype, "fills", 2);
__decorateClass([
  Validate52(FILL_MODE)
], LinearGaugeBarProperties.prototype, "fillMode", 2);
__decorateClass([
  Validate52(COLOR_STRING14, { optional: true })
], LinearGaugeBarProperties.prototype, "fill", 2);
__decorateClass([
  Validate52(RATIO18)
], LinearGaugeBarProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate52(COLOR_STRING14)
], LinearGaugeBarProperties.prototype, "stroke", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeBarProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate52(RATIO18)
], LinearGaugeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate52(LINE_DASH9)
], LinearGaugeBarProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeBarProperties.prototype, "lineDashOffset", 2);
var LinearGaugeScaleProperties = class extends BaseProperties23 {
  constructor() {
    super(...arguments);
    this.fills = new PropertiesArray3(GaugeStopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.defaultFill = "black";
  }
};
__decorateClass([
  Validate52(OBJECT_ARRAY)
], LinearGaugeScaleProperties.prototype, "fills", 2);
__decorateClass([
  Validate52(FILL_MODE)
], LinearGaugeScaleProperties.prototype, "fillMode", 2);
__decorateClass([
  Validate52(COLOR_STRING14, { optional: true })
], LinearGaugeScaleProperties.prototype, "fill", 2);
__decorateClass([
  Validate52(RATIO18)
], LinearGaugeScaleProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate52(COLOR_STRING14)
], LinearGaugeScaleProperties.prototype, "stroke", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeScaleProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate52(RATIO18)
], LinearGaugeScaleProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate52(LINE_DASH9)
], LinearGaugeScaleProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeScaleProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate52(COLOR_STRING14)
], LinearGaugeScaleProperties.prototype, "defaultFill", 2);
var LinearGaugeLabelProperties = class extends AutoSizedLabel {
};
__decorateClass([
  Validate52(STRING25, { optional: true })
], LinearGaugeLabelProperties.prototype, "text", 2);
var LinearGaugeSecondaryLabelProperties = class extends AutoSizedSecondaryLabel {
};
__decorateClass([
  Validate52(STRING25, { optional: true })
], LinearGaugeSecondaryLabelProperties.prototype, "text", 2);
var LinearGaugeSeriesProperties = class extends SeriesProperties2 {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.segmentation = new GaugeSegmentationProperties();
    this.defaultColorRange = [];
    this.targets = new PropertiesArray3(LinearGaugeTargetProperties);
    this.defaultTarget = new LinearGaugeTargetProperties();
    this.direction = "vertical";
    this.thickness = 1;
    this.cornerRadius = 0;
    this.cornerMode = "container";
    this.margin = 0;
    this.scale = new LinearGaugeScaleProperties();
    this.bar = new LinearGaugeBarProperties();
    this.label = new LinearGaugeLabelProperties();
    this.secondaryLabel = new LinearGaugeSecondaryLabelProperties();
    this.tooltip = new SeriesTooltip6();
  }
};
__decorateClass([
  Validate52(NUMBER14)
], LinearGaugeSeriesProperties.prototype, "value", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "segmentation", 2);
__decorateClass([
  Validate52(COLOR_STRING_ARRAY3)
], LinearGaugeSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Validate52(OBJECT_ARRAY)
], LinearGaugeSeriesProperties.prototype, "targets", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "defaultTarget", 2);
__decorateClass([
  Validate52(DIRECTION)
], LinearGaugeSeriesProperties.prototype, "direction", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeSeriesProperties.prototype, "thickness", 2);
__decorateClass([
  Validate52(POSITIVE_NUMBER16)
], LinearGaugeSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate52(CORNER_MODE)
], LinearGaugeSeriesProperties.prototype, "cornerMode", 2);
__decorateClass([
  Validate52(NUMBER14)
], LinearGaugeSeriesProperties.prototype, "margin", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "scale", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "bar", 2);
__decorateClass([
  Validate52(FUNCTION9, { optional: true })
], LinearGaugeSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass([
  Validate52(OBJECT22)
], LinearGaugeSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeUtil.ts
import { _Scene as _Scene52 } from "ag-charts-community";
var { BBox: BBox8 } = _Scene52;
function datumRect(datum) {
  const { x0, y0, x1, y1, horizontalInset, verticalInset } = datum;
  const x = Math.min(x0, x1) + horizontalInset;
  const y = Math.min(y0, y1) + verticalInset;
  const width = Math.max(Math.abs(x1 - x0) - 2 * horizontalInset, 0);
  const height = Math.max(Math.abs(y1 - y0) - 2 * verticalInset, 0);
  return { x, y, width, height };
}
function clipBBoxVisibility(datum, clipBBox) {
  if (clipBBox == null)
    return true;
  const rect = datumRect(datum);
  const delta3 = 1e-6;
  const x0 = rect.x + delta3;
  const y0 = rect.y + delta3;
  const x1 = rect.x + rect.width - delta3;
  const y1 = rect.y + rect.height - delta3;
  const clipX0 = clipBBox.x;
  const clipX1 = clipBBox.x + clipBBox.width;
  const clipY0 = clipBBox.y;
  const clipY1 = clipBBox.y + clipBBox.height;
  return Math.max(x0, clipX0) <= Math.min(x1, clipX1) && Math.max(y0, clipY0) <= Math.min(y1, clipY1);
}
function hasClipBBox(datum) {
  const { clipX0, clipX1, clipY0, clipY1 } = datum;
  return clipX0 != null && clipX1 != null || clipY0 != null && clipY1 != null;
}
function computeClipBBox(datum) {
  if (!hasClipBBox(datum))
    return;
  const { x0, y0, x1, y1 } = datum;
  const { x, y, width, height } = datumRect(datum);
  let { clipX0, clipX1, clipY0, clipY1 } = datum;
  if (clipX0 == null || clipX1 == null) {
    clipX0 = x0;
    clipX1 = x1;
  }
  if (clipY0 == null || clipY1 == null) {
    clipY0 = y0;
    clipY1 = y1;
  }
  const clipX = Math.min(clipX0, clipX1);
  const clipY = Math.min(clipY0, clipY1);
  const clipWidth = Math.abs(clipX1 - clipX0);
  const clipHeight = Math.abs(clipY1 - clipY0);
  clipX0 = Math.max(x, clipX);
  clipY0 = Math.max(y, clipY);
  clipX1 = Math.min(x + width, clipX + clipWidth);
  clipY1 = Math.min(y + height, clipY + clipHeight);
  return new BBox8(
    Math.min(clipX0, clipX1),
    Math.min(clipY0, clipY1),
    Math.abs(clipX1 - clipX0),
    Math.abs(clipY1 - clipY0)
  );
}
function prepareLinearGaugeSeriesAnimationFunctions(initialLoad, horizontal) {
  const phase = initialLoad ? "initial" : "update";
  const node = {
    fromFn(sect, datum) {
      const previousDatum = sect.previousDatum;
      let { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1 } = previousDatum ?? datum;
      const { horizontalInset, verticalInset } = datum;
      const previousHadClipBBox = previousDatum != null && hasClipBBox(previousDatum);
      const nextHasClipBBox = hasClipBBox(datum);
      if (previousHadClipBBox && nextHasClipBBox) {
      } else if (!previousHadClipBBox && nextHasClipBBox) {
        ({ x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1 } = datum);
        if (initialLoad) {
          if (horizontal) {
            clipX1 = datum.clipX0;
          } else {
            clipY1 = datum.clipY0;
          }
        }
      } else if (previousHadClipBBox && !nextHasClipBBox) {
        ({ x0, y0, x1, y1 } = datum);
        clipX0 = void 0;
        clipY0 = void 0;
        clipX1 = void 0;
        clipY1 = void 0;
      } else if (initialLoad) {
        if (horizontal) {
          x1 = x0;
        } else {
          y1 = y0;
        }
      }
      return { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset, phase };
    },
    toFn(_sect, datum) {
      const { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset } = datum;
      return { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset };
    },
    applyFn(rect, params) {
      rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, params));
    }
  };
  return { node };
}
function resetLinearGaugeSeriesResetRectFunction(_node, datum) {
  const { x, y, width, height } = datumRect(datum);
  const clipBBox = computeClipBBox(datum);
  const visible = clipBBoxVisibility(datum, clipBBox);
  return { x, y, width, height, clipBBox, visible };
}

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeSeries.ts
var {
  fromToMotion: fromToMotion2,
  resetMotion,
  SeriesNodePickMode: SeriesNodePickMode5,
  StateMachine: StateMachine10,
  createDatumId: createDatumId3,
  ChartAxisDirection: ChartAxisDirection15,
  EMPTY_TOOLTIP_CONTENT: EMPTY_TOOLTIP_CONTENT2
} = _ModuleSupport114;
var { BBox: BBox9, Group: Group7, PointerEvents: PointerEvents2, Selection: Selection4, Rect: Rect5, Text: Text3, LinearGradient: LinearGradient2, getMarker } = _Scene53;
var { toRadians: toRadians4 } = _Util73;
var horizontalTargetPlacementRotation = {
  before: 180,
  middle: 0,
  after: 0
};
var verticalTargetPlacementRotation = {
  before: 90,
  middle: 0,
  after: -90
};
var LinearGaugeSeries = class extends _ModuleSupport114.Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode5.EXACT_SHAPE_MATCH, SeriesNodePickMode5.NEAREST_NODE]
    });
    this.canHaveAxes = true;
    this.properties = new LinearGaugeSeriesProperties();
    // REMOVE ME
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.originX = 0;
    this.originY = 0;
    this.scaleGroup = this.contentGroup.appendChild(new Group7({ name: "scaleGroup" }));
    this.itemGroup = this.contentGroup.appendChild(new Group7({ name: "itemGroup" }));
    this.itemTargetGroup = this.contentGroup.appendChild(new Group7({ name: "itemTargetGroup" }));
    this.itemTargetLabelGroup = this.contentGroup.appendChild(new Group7({ name: "itemTargetLabelGroup" }));
    // private readonly itemLabelGroup = this.contentGroup.appendChild(new Group({ name: 'itemLabelGroup' }));
    this.highlightTargetGroup = this.highlightGroup.appendChild(
      new Group7({ name: "itemTargetLabelGroup" })
    );
    this.scaleSelection = Selection4.select(
      this.scaleGroup,
      () => this.nodeFactory()
    );
    this.datumSelection = Selection4.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.targetSelection = Selection4.select(
      this.itemTargetGroup,
      (datum) => this.markerFactory(datum)
    );
    this.targetLabelSelection = Selection4.select(
      this.itemTargetLabelGroup,
      Text3
    );
    // private labelSelection: _Scene.Selection<_Scene.Text, LinearGaugeLabelDatum> = Selection.select(
    //     this.itemLabelGroup,
    //     Text
    // );
    this.highlightTargetSelection = Selection4.select(
      this.highlightTargetGroup,
      (datum) => this.markerFactory(datum)
    );
    this.nodeDatum = { series: this, datum: {} };
    this.animationState = new StateMachine10("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.animateEmptyUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      ready: {
        updateData: "waiting",
        clear: "clearing",
        // highlight: (data) => this.animateReadyHighlight(data),
        // highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
        resize: () => this.animateReadyResize(),
        reset: "empty",
        skip: "ready"
      },
      waiting: {
        update: {
          target: "ready",
          action: () => this.animateWaitingUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      clearing: {
        update: {
          target: "empty"
          // action: (data) => this.animateClearingUpdateEmpty(data),
        },
        reset: "empty",
        skip: "ready"
      }
    });
    this.itemGroup.pointerEvents = PointerEvents2.None;
    this.itemTargetLabelGroup.pointerEvents = PointerEvents2.None;
  }
  get horizontal() {
    return this.properties.direction === "horizontal";
  }
  get thickness() {
    return this.properties.thickness;
  }
  get hasData() {
    return true;
  }
  nodeFactory() {
    const rect = new Rect5();
    rect.crisp = true;
    return rect;
  }
  markerFactory({ shape }) {
    const MarkerShape = shape !== "line" ? getMarker(shape) : LineMarker;
    const marker = new MarkerShape();
    marker.size = 1;
    return marker;
  }
  async processData() {
    this.nodeDataRefresh = true;
    this.animationState.transition("updateData");
  }
  formatLabel(value) {
    const angleAxis = this.axes[ChartAxisDirection15.X];
    if (angleAxis == null)
      return "";
    const [min, max] = angleAxis.scale.domain;
    const minLog10 = min !== 0 ? Math.ceil(Math.log10(Math.abs(min))) : 0;
    const maxLog10 = max !== 0 ? Math.ceil(Math.log10(Math.abs(max))) : 0;
    const dp = Math.max(2 - Math.max(minLog10, maxLog10), 0);
    return value.toFixed(dp);
  }
  createLinearGradient(fills, fillMode) {
    const { properties, originX, originY, horizontal } = this;
    const { thickness, defaultColorRange } = properties;
    const mainAxis = horizontal ? this.axes[ChartAxisDirection15.X] : this.axes[ChartAxisDirection15.Y];
    const { domain, range: range2 } = mainAxis.scale;
    const length = range2[1] - range2[0];
    const stops = getColorStops(fills, defaultColorRange, domain, fillMode);
    return new LinearGradient2(
      "oklch",
      stops,
      horizontal ? 90 : 0,
      new BBox9(originX, originY, horizontal ? length : thickness, horizontal ? thickness : length)
    );
  }
  getTargets() {
    const { properties } = this;
    const defaultTarget = properties.defaultTarget;
    return Array.from(properties.targets).map((target) => {
      const {
        text: text2 = defaultTarget.text,
        value = defaultTarget.value ?? 0,
        shape = defaultTarget.shape ?? "triangle",
        rotation = defaultTarget.rotation ?? 0,
        strokeWidth = defaultTarget.strokeWidth ?? 0,
        placement = defaultTarget.placement ?? "middle",
        spacing = defaultTarget.spacing ?? 0,
        size = defaultTarget.size ?? 0,
        fill = defaultTarget.fill ?? "black",
        fillOpacity = defaultTarget.fillOpacity ?? 1,
        stroke: stroke2 = defaultTarget.stroke ?? "black",
        strokeOpacity = defaultTarget.strokeOpacity ?? 1,
        lineDash = defaultTarget.lineDash ?? [0],
        lineDashOffset = defaultTarget.lineDashOffset ?? 0
      } = target;
      const {
        enabled: labelEnabled = defaultTarget.label.enabled,
        color: labelColor = defaultTarget.label.color ?? "black",
        fontStyle: labelFontStyle = defaultTarget.label.fontStyle ?? "normal",
        fontWeight: labelFontWeight = defaultTarget.label.fontWeight ?? "normal",
        fontSize: labelFontSize = defaultTarget.label.fontSize,
        fontFamily: labelFontFamily = defaultTarget.label.fontFamily,
        spacing: labelSpacing = defaultTarget.label.spacing ?? 0
      } = target.label;
      return {
        text: text2,
        value,
        shape,
        placement,
        spacing,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        label: {
          enabled: labelEnabled,
          color: labelColor,
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          spacing: labelSpacing
        }
      };
    });
  }
  getTargetPoint(target) {
    const xAxis = this.axes[ChartAxisDirection15.X];
    const yAxis = this.axes[ChartAxisDirection15.Y];
    if (xAxis == null || yAxis == null)
      return { x: 0, y: 0 };
    const { properties, originX, originY, horizontal } = this;
    const { thickness } = properties;
    const { value, placement, spacing, size } = target;
    const mainAxis = horizontal ? xAxis : yAxis;
    const mainOffset = mainAxis.scale.convert(value) - mainAxis.scale.range[0];
    let crossOffset;
    switch (placement) {
      case "before":
        crossOffset = -(spacing + size / 2);
        break;
      case "after":
        crossOffset = thickness + spacing + size / 2;
        break;
      default:
        crossOffset = thickness / 2;
        break;
    }
    return {
      x: originX + xAxis.range[0] + (horizontal ? mainOffset : crossOffset),
      y: originY + yAxis.range[0] + (horizontal ? crossOffset : mainOffset)
    };
  }
  getTargetLabel(target) {
    const { size, placement, label } = target;
    const { spacing, color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    const lineHeight = void 0;
    const offset = size / 2 + spacing;
    let textAlign;
    let textBaseline;
    let offsetX = 0;
    let offsetY = 0;
    if (this.horizontal) {
      textAlign = "center";
      if (placement === "after") {
        textBaseline = "top";
        offsetY = offset;
      } else {
        textBaseline = "bottom";
        offsetY = -offset;
      }
    } else {
      textBaseline = "middle";
      if (placement === "before") {
        textAlign = "right";
        offsetX = -offset;
      } else {
        textAlign = "left";
        offsetX = offset;
      }
    }
    return {
      offsetX,
      offsetY,
      fill,
      textAlign,
      textBaseline,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      lineHeight
    };
  }
  async createNodeData() {
    const { id: seriesId, properties, originX, originY, horizontal } = this;
    if (!properties.isValid())
      return;
    const {
      value,
      segmentation,
      thickness,
      cornerRadius,
      cornerMode,
      bar,
      scale
      // label,
      // secondaryLabel,
    } = properties;
    const targets = this.getTargets();
    const xAxis = this.axes[ChartAxisDirection15.X];
    const yAxis = this.axes[ChartAxisDirection15.Y];
    if (xAxis == null || yAxis == null)
      return;
    const mainAxis = horizontal ? xAxis : yAxis;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const mainAxisScale = mainAxis.scale;
    let { domain } = mainAxis.scale;
    if (mainAxis.isReversed()) {
      domain = domain.slice().reverse();
    }
    const nodeData = [];
    const targetData = [];
    const labelData = [];
    const scaleData = [];
    const [m0, m1] = mainAxisScale.range;
    const mainAxisSize = Math.abs(m1 - m0);
    let [x0, x1] = xAxis.range;
    if (xAxis.isReversed()) {
      [x1, x0] = [x0, x1];
    }
    let [y0, y1] = yAxis.range;
    if (yAxis.isReversed()) {
      [y1, y0] = [y0, y1];
    }
    const containerX = horizontal ? xScale.convert(value) : x1;
    const containerY = horizontal ? y1 : yScale.convert(value);
    const inset = segmentation.enabled ? segmentation.spacing / 2 : 0;
    const horizontalInset = horizontal ? inset : 0;
    const verticalInset = horizontal ? 0 : inset;
    const barThickness = Math.min(bar.thickness ?? Math.round(bar.thicknessRatio * thickness), thickness);
    const barInset = -(thickness - barThickness) / 2;
    const barXInset = horizontal ? 0 : barInset;
    const barYInset = horizontal ? barInset : 0;
    const cornersOnAllItems = cornerMode === "item";
    const maxTicks = Math.ceil(mainAxisSize);
    let segments = segmentation.enabled ? segmentation.interval.getSegments(mainAxisScale, maxTicks) : void 0;
    const barFill = bar.fill ?? this.createLinearGradient(bar.fills, bar.fillMode);
    const scaleFill = scale.fill ?? (bar.enabled && scale.fills.length === 0 ? scale.defaultFill : void 0) ?? this.createLinearGradient(scale.fills, scale.fillMode);
    if (segments == null && cornersOnAllItems) {
      const segmentStart = Math.min(...domain);
      const segmentEnd = Math.max(...domain);
      const datum = { value, segmentStart, segmentEnd };
      if (bar.enabled) {
        const barAppliedCornerRadius = Math.min(cornerRadius, barThickness / 2, mainAxisSize / 2);
        const barCornerInset = barAppliedCornerRadius * (mainAxis.isReversed() ? -1 : 1);
        const barCornerXInset = horizontal ? barCornerInset : 0;
        const barCornerYInset = horizontal ? 0 : barCornerInset;
        nodeData.push({
          series: this,
          itemId: `value`,
          datum,
          type: 0 /* Node */,
          x0: originX + x0 - barCornerXInset - barXInset,
          y0: originY + y0 - barCornerYInset - barYInset,
          x1: originX + containerX + barCornerXInset + barXInset,
          y1: originY + containerY + barCornerYInset + barYInset,
          clipX0: void 0,
          clipY0: void 0,
          clipX1: void 0,
          clipY1: void 0,
          topLeftCornerRadius: cornerRadius,
          topRightCornerRadius: cornerRadius,
          bottomRightCornerRadius: cornerRadius,
          bottomLeftCornerRadius: cornerRadius,
          fill: barFill,
          horizontalInset,
          verticalInset
        });
      }
      const scaleAppliedCornerRadius = Math.min(cornerRadius, thickness / 2, mainAxisSize / 2);
      const scaleCornerInset = scaleAppliedCornerRadius * (mainAxis.isReversed() ? -1 : 1);
      const scaleCornerXInset = horizontal ? scaleCornerInset : 0;
      const scaleCornerYInset = horizontal ? 0 : scaleCornerInset;
      scaleData.push({
        series: this,
        itemId: `scale`,
        datum,
        type: 0 /* Node */,
        x0: originX + x0 - scaleCornerXInset,
        y0: originY + y0 - scaleCornerYInset,
        x1: originX + x1 + scaleCornerXInset,
        y1: originY + y1 + scaleCornerYInset,
        clipX0: void 0,
        clipY0: void 0,
        clipX1: void 0,
        clipY1: void 0,
        topLeftCornerRadius: cornerRadius,
        topRightCornerRadius: cornerRadius,
        bottomRightCornerRadius: cornerRadius,
        bottomLeftCornerRadius: cornerRadius,
        fill: scaleFill,
        horizontalInset,
        verticalInset
      });
    } else {
      segments ?? (segments = domain);
      const clipX0 = originX + x0 - barXInset;
      const clipY0 = originY + y0 - barYInset;
      const clipX1 = originX + containerX + barXInset;
      const clipY1 = originY + containerY + barYInset;
      for (let i = 0; i < segments.length - 1; i += 1) {
        const segmentStart = segments[i + 0];
        const segmentEnd = segments[i + 1];
        const datum = { value, segmentStart, segmentEnd };
        const isStart = i === 0;
        const isEnd = i === segments.length - 2;
        const itemStart = mainAxisScale.convert(segmentStart);
        const itemEnd = mainAxisScale.convert(segmentEnd);
        const startCornerRadius = cornersOnAllItems || isStart ? cornerRadius : 0;
        const endCornerRadius = cornersOnAllItems || isEnd ? cornerRadius : 0;
        const topLeftCornerRadius = horizontal ? startCornerRadius : endCornerRadius;
        const topRightCornerRadius = endCornerRadius;
        const bottomRightCornerRadius = horizontal ? endCornerRadius : startCornerRadius;
        const bottomLeftCornerRadius = startCornerRadius;
        if (bar.enabled) {
          nodeData.push({
            series: this,
            itemId: `value-${i}`,
            datum,
            type: 0 /* Node */,
            x0: originX + (horizontal ? itemStart : x0),
            y0: originY + (horizontal ? y0 : itemStart),
            x1: originX + (horizontal ? itemEnd : x1),
            y1: originY + (horizontal ? y1 : itemEnd),
            clipX0,
            clipY0,
            clipX1,
            clipY1,
            topLeftCornerRadius,
            topRightCornerRadius,
            bottomRightCornerRadius,
            bottomLeftCornerRadius,
            fill: barFill,
            horizontalInset,
            verticalInset
          });
        }
        scaleData.push({
          series: this,
          itemId: `scale-${i}`,
          datum,
          type: 0 /* Node */,
          x0: originX + (horizontal ? itemStart : x0),
          y0: originY + (horizontal ? y0 : itemStart),
          x1: originX + (horizontal ? itemEnd : x1),
          y1: originY + (horizontal ? y1 : itemEnd),
          clipX0: void 0,
          clipY0: void 0,
          clipX1: void 0,
          clipY1: void 0,
          topLeftCornerRadius,
          topRightCornerRadius,
          bottomRightCornerRadius,
          bottomLeftCornerRadius,
          fill: scaleFill,
          horizontalInset,
          verticalInset
        });
      }
    }
    const targetPlacementRotation2 = horizontal ? horizontalTargetPlacementRotation : verticalTargetPlacementRotation;
    for (let i = 0; i < targets.length; i += 1) {
      const target = targets[i];
      const {
        value: targetValue,
        text: text2,
        shape,
        size,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      } = target;
      const targetPoint = this.getTargetPoint(target);
      const targetRotation = toRadians4(target.rotation + targetPlacementRotation2[target.placement]);
      targetData.push({
        series: this,
        itemId: `target-${i}`,
        midPoint: targetPoint,
        datum: { value: targetValue },
        type: 1 /* Target */,
        value: targetValue,
        text: text2,
        x: targetPoint.x,
        y: targetPoint.y,
        shape,
        size,
        rotation: targetRotation,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        label: this.getTargetLabel(target)
      });
    }
    return {
      itemId: seriesId,
      nodeData,
      targetData,
      labelData,
      scaleData
    };
  }
  async updateSelections(resize) {
    if (this.nodeDataRefresh || resize) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  highlightDatum(node) {
    if (node != null && node.series === this && node.type === 1 /* Target */) {
      return node;
    }
  }
  async update({ seriesRect }) {
    const {
      datumSelection,
      // labelSelection,
      targetSelection,
      targetLabelSelection,
      scaleSelection,
      highlightTargetSelection
    } = this;
    const resize = this.checkResize(seriesRect);
    await this.updateSelections(resize);
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const targetData = this.contextNodeData?.targetData ?? [];
    const scaleData = this.contextNodeData?.scaleData ?? [];
    const highlightTargetDatum = this.highlightDatum(this.ctx.highlightManager.getActiveHighlight());
    this.scaleSelection = await this.updateScaleSelection({ scaleData, scaleSelection });
    await this.updateScaleNodes({ scaleSelection });
    this.targetSelection = await this.updateTargetSelection({ targetData, targetSelection });
    await this.updateTargetNodes({ targetSelection, isHighlight: false });
    this.targetLabelSelection = await this.updateTargetLabelSelection({ targetData, targetLabelSelection });
    await this.updateTargetLabelNodes({ targetLabelSelection });
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection });
    this.highlightTargetSelection = await this.updateTargetSelection({
      targetData: highlightTargetDatum != null ? [highlightTargetDatum] : [],
      targetSelection: highlightTargetSelection
    });
    await this.updateTargetNodes({ targetSelection: highlightTargetSelection, isHighlight: true });
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => {
      return createDatumId3(opts.nodeData.length, datum.itemId);
    });
  }
  async updateDatumNodes(opts) {
    const { datumSelection } = opts;
    const { ctx, properties } = this;
    const { bar } = properties;
    const { fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = bar;
    const strokeWidth = this.getStrokeWidth(bar.strokeWidth);
    const animationDisabled = ctx.animationManager.isSkipped();
    datumSelection.each((rect, datum) => {
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius, fill } = datum;
      rect.fill = fill;
      rect.fillOpacity = fillOpacity;
      rect.stroke = stroke2;
      rect.strokeOpacity = strokeOpacity;
      rect.strokeWidth = strokeWidth;
      rect.lineDash = lineDash;
      rect.lineDashOffset = lineDashOffset;
      rect.topLeftCornerRadius = topLeftCornerRadius;
      rect.topRightCornerRadius = topRightCornerRadius;
      rect.bottomRightCornerRadius = bottomRightCornerRadius;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius;
      if (animationDisabled || rect.previousDatum == null) {
        rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, datum));
      }
    });
  }
  async updateScaleSelection(opts) {
    return opts.scaleSelection.update(opts.scaleData, void 0, (datum) => {
      return createDatumId3(opts.scaleData.length, datum.itemId);
    });
  }
  async updateScaleNodes(opts) {
    const { scaleSelection } = opts;
    const { scale } = this.properties;
    const { fillOpacity, stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = scale;
    scaleSelection.each((rect, datum) => {
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius, fill } = datum;
      rect.fill = fill;
      rect.fillOpacity = fillOpacity;
      rect.stroke = stroke2;
      rect.strokeOpacity = strokeOpacity;
      rect.strokeWidth = strokeWidth;
      rect.lineDash = lineDash;
      rect.lineDashOffset = lineDashOffset;
      rect.topLeftCornerRadius = topLeftCornerRadius;
      rect.topRightCornerRadius = topRightCornerRadius;
      rect.bottomRightCornerRadius = bottomRightCornerRadius;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius;
      rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, datum));
    });
  }
  async updateTargetSelection(opts) {
    return opts.targetSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  async updateTargetNodes(opts) {
    const { targetSelection, isHighlight } = opts;
    const highlightStyle = isHighlight ? this.properties.highlightStyle.item : void 0;
    targetSelection.each((target, datum) => {
      const {
        x,
        y,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      } = datum;
      target.size = size;
      target.fill = highlightStyle?.fill ?? fill;
      target.fillOpacity = highlightStyle?.fillOpacity ?? fillOpacity;
      target.stroke = highlightStyle?.stroke ?? stroke2;
      target.strokeOpacity = highlightStyle?.strokeOpacity ?? strokeOpacity;
      target.strokeWidth = highlightStyle?.strokeWidth ?? strokeWidth;
      target.lineDash = highlightStyle?.lineDash ?? lineDash;
      target.lineDashOffset = highlightStyle?.lineDashOffset ?? lineDashOffset;
      target.translationX = x;
      target.translationY = y;
      target.rotation = rotation;
    });
  }
  async updateTargetLabelSelection(opts) {
    return opts.targetLabelSelection.update(opts.targetData);
  }
  async updateTargetLabelNodes(opts) {
    const { targetLabelSelection } = opts;
    targetLabelSelection.each((label, target) => {
      const { x, y, text: text2 } = target;
      const { offsetX, offsetY, fill, fontStyle, fontWeight, fontSize, fontFamily, textAlign, textBaseline } = target.label;
      label.visible = true;
      label.x = x + offsetX;
      label.y = y + offsetY;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = textAlign;
      label.textBaseline = textBaseline;
    });
  }
  // private async updateLabelSelection(opts: {
  //     labelData: LinearGaugeLabelDatum[];
  //     labelSelection: _Scene.Selection<_Scene.Text, LinearGaugeLabelDatum>;
  // }) {
  //     return opts.labelSelection.update(opts.labelData, undefined, (datum) => datum.label);
  // }
  // private async updateLabelNodes(opts: { labelSelection: _Scene.Selection<_Scene.Text, LinearGaugeLabelDatum> }) {
  //     const { labelSelection } = opts;
  //     const animationDisabled = this.ctx.animationManager.isSkipped();
  //     labelSelection.each((label, datum) => {
  //         label.fill = datum.fill;
  //         label.fontStyle = datum.fontStyle;
  //         label.fontWeight = datum.fontWeight;
  //         label.fontFamily = datum.fontFamily;
  //     });
  //     if (animationDisabled || this.labelsHaveExplicitText()) {
  //         this.formatLabelText();
  //     }
  // }
  // labelsHaveExplicitText() {
  //     for (const { datum } of this.labelSelection) {
  //         if (datum.text == null) {
  //             return false;
  //         }
  //     }
  //     return true;
  // }
  // formatLabelText(datum?: { label: number; secondaryLabel: number }) {
  //     const angleAxis = this.axes[ChartAxisDirection.X];
  //     if (angleAxis == null) return;
  //     const { labelSelection, textAlign, verticalAlign } = this;
  //     const { label, secondaryLabel, margin: padding } = this.properties;
  //     formatLinearGaugeLabels(
  //         this,
  //         labelSelection,
  //         label,
  //         secondaryLabel,
  //         { padding, textAlign, verticalAlign },
  //         0,
  //         (value) => this.formatLabel(value),
  //         datum
  //     );
  // }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    resetMotion([this.datumSelection], resetLinearGaugeSeriesResetRectFunction);
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  // private animateLabelText(params: { from?: number; phase?: _ModuleSupport.AnimationPhase } = {}) {
  //     const { animationManager } = this.ctx;
  //     let labelFrom = 0;
  //     let labelTo = 0;
  //     let secondaryLabelFrom = 0;
  //     let secondaryLabelTo = 0;
  //     this.labelSelection.each((label, datum) => {
  //         // Reset animation
  //         label.opacity = 1;
  //         if (datum.label === LabelType.Primary) {
  //             labelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
  //             labelTo = datum.value;
  //         } else if (datum.label === LabelType.Secondary) {
  //             secondaryLabelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
  //             secondaryLabelTo = datum.value;
  //         }
  //     });
  //     if (this.labelsHaveExplicitText()) {
  //         // Ignore
  //     } else if (labelFrom === labelTo && secondaryLabelFrom === secondaryLabelTo) {
  //         this.formatLabelText({ label: labelTo, secondaryLabel: secondaryLabelTo });
  //     } else if (!this.labelsHaveExplicitText()) {
  //         const animationId = `${this.id}_labels`;
  //         animationManager.animate({
  //             id: animationId,
  //             groupId: 'label',
  //             from: { label: labelFrom, secondaryLabel: secondaryLabelFrom },
  //             to: { label: labelTo, secondaryLabel: secondaryLabelTo },
  //             phase: params.phase ?? 'update',
  //             onUpdate: (datum) => this.formatLabelText(datum),
  //         });
  //     }
  // }
  animateEmptyUpdateReady() {
    const { animationManager } = this.ctx;
    const { node } = prepareLinearGaugeSeriesAnimationFunctions(true, this.horizontal);
    fromToMotion2(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
  }
  animateWaitingUpdateReady() {
    const { animationManager } = this.ctx;
    const { node } = prepareLinearGaugeSeriesAnimationFunctions(false, this.horizontal);
    fromToMotion2(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
  }
  animateReadyResize() {
    this.resetAllAnimation();
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  pickNode(point, intent) {
    switch (intent) {
      case "event":
      case "context-menu": {
        const sectorTarget = this.scaleGroup.pickNode(point.x, point.y);
        return sectorTarget != null ? {
          pickMode: _ModuleSupport114.SeriesNodePickMode.EXACT_SHAPE_MATCH,
          match: sectorTarget.datum,
          distance: 0
        } : void 0;
      }
      case "tooltip":
      case "highlight":
      case "highlight-tooltip": {
        const highlightedTarget = this.itemTargetGroup.pickNode(point.x, point.y);
        return highlightedTarget != null ? {
          pickMode: _ModuleSupport114.SeriesNodePickMode.EXACT_SHAPE_MATCH,
          match: highlightedTarget.datum,
          distance: 0
        } : {
          pickMode: _ModuleSupport114.SeriesNodePickMode.NEAREST_NODE,
          match: this.nodeDatum,
          distance: 0
        };
      }
    }
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, properties } = this;
    if (!properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT2;
    }
    const highlightDatum = this.highlightDatum(nodeDatum);
    const value = highlightDatum?.value ?? properties.value;
    const text2 = highlightDatum?.text;
    const { tooltip } = properties;
    const title = text2 ?? "";
    const content = this.formatLabel(value);
    const itemId = highlightDatum?.itemId;
    const datum = void 0;
    const color = highlightDatum?.fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        itemId,
        title,
        datum,
        color,
        value,
        ...this.getModuleTooltipParams()
      }
    );
  }
  pickFocus(opts) {
    const targetData = this.contextNodeData?.targetData;
    if (targetData == null || targetData.length === 0)
      return;
    const datumIndex = Math.min(Math.max(opts.datumIndex, 0), targetData.length - 1);
    const datum = targetData[datumIndex];
    for (const node of this.targetSelection) {
      if (node.datum === datum) {
        const bounds = node.node;
        return { bounds, showFocusBox: true, datum, datumIndex };
      }
    }
  }
  getCaptionText() {
    const { value } = this.properties;
    const description = [];
    description.push(this.formatLabel(value));
    return description.join(". ");
  }
};
LinearGaugeSeries.className = "LinearGaugeSeries";
LinearGaugeSeries.type = "linear-gauge";

// packages/ag-charts-enterprise/src/series/linear-gauge/linearGaugeModule.ts
var {
  FONT_WEIGHT: FONT_WEIGHT3,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY2,
  DEFAULT_HIERARCHY_FILLS,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR2,
  DEFAULT_MUTED_LABEL_COLOUR,
  CARTESIAN_AXIS_TYPE
} = _Theme18;
var LinearGaugeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["gauge"],
  identifier: "linear-gauge",
  moduleFactory: (ctx) => new LinearGaugeSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    { type: CARTESIAN_AXIS_TYPE.NUMBER, line: { enabled: false } },
    { type: CARTESIAN_AXIS_TYPE.NUMBER, line: { enabled: false } }
  ],
  themeTemplate: {
    minWidth: 200,
    minHeight: 200,
    series: {
      thickness: 50,
      bar: {
        strokeWidth: 0
      },
      segmentation: {
        enabled: false,
        interval: {},
        spacing: 1
      },
      // @ts-expect-error Private
      defaultTarget: {
        fill: DEFAULT_LABEL_COLOUR2,
        stroke: DEFAULT_LABEL_COLOUR2,
        size: 10,
        shape: "triangle",
        placement: "after",
        spacing: 5,
        label: {
          enabled: true,
          fontWeight: FONT_WEIGHT3.NORMAL,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY2,
          color: DEFAULT_LABEL_COLOUR2,
          spacing: 5
        }
      },
      label: {
        enabled: true,
        fontWeight: FONT_WEIGHT3.NORMAL,
        fontSize: 56,
        minimumFontSize: 18,
        fontFamily: DEFAULT_FONT_FAMILY2,
        color: DEFAULT_LABEL_COLOUR2
      },
      secondaryLabel: {
        enabled: true,
        fontWeight: FONT_WEIGHT3.NORMAL,
        fontSize: 14,
        minimumFontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY2,
        color: DEFAULT_MUTED_LABEL_COLOUR
      },
      tooltip: {
        enabled: false
      }
    }
  },
  paletteFactory(params) {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = params;
    const { fills } = takeColors(colorsCount);
    const defaultColorRange = themeTemplateParameters.get(_Theme18.DEFAULT_GAUGE_SERIES_COLOUR_RANGE);
    const hierarchyFills = themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS);
    const colorRange = userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]];
    return {
      scale: {
        defaultFill: hierarchyFills?.[1],
        stroke: hierarchyFills?.[2]
      },
      defaultColorRange: defaultColorStops(colorRange)
    };
  }
};

// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundModule.ts
import { _Theme as _Theme19 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/mapThemeDefaults.ts
var MAP_THEME_DEFAULTS = {
  zoom: {
    axes: "xy",
    anchorPointX: "pointer",
    anchorPointY: "pointer"
  },
  legend: {
    enabled: false
  },
  gradientLegend: {
    enabled: false
  },
  tooltip: {
    range: "exact"
  }
};

// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeries.ts
import { _ModuleSupport as _ModuleSupport119, _Scene as _Scene55, _Util as _Util74 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/geoGeometry.ts
import { _Scene as _Scene54 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/lineStringUtil.ts
var delta = 1e-9;
function lineSegmentDistanceToPointSquared(a, b, x, y) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const l = abx * abx + aby * aby;
  let x0;
  let y0;
  if (Math.abs(l) < delta) {
    x0 = ax;
    y0 = ay;
  } else {
    let t = ((x - ax) * abx + (y - ay) * aby) / l;
    t = Math.max(0, Math.min(1, t));
    x0 = ax + t * (bx - ax);
    y0 = ay + t * (by - ay);
  }
  const dx2 = x - x0;
  const dy2 = y - y0;
  return dx2 * dx2 + dy2 * dy2;
}
function lineStringDistance(lineString, x, y) {
  let minDistanceSquared = Infinity;
  let p0 = lineString[lineString.length - 1];
  for (const p1 of lineString) {
    minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
    p0 = p1;
  }
  return Math.sqrt(minDistanceSquared);
}
function lineStringLength(lineSegment) {
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const distance = Math.hypot(x1 - x0, y1 - y0);
    totalDistance += distance;
    x0 = x1;
    y0 = y1;
  }
  return totalDistance;
}
function lineStringCenter(lineSegment) {
  if (lineSegment.length === 0)
    return;
  const targetDistance = lineStringLength(lineSegment) / 2;
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const segmentDistance = Math.hypot(x1 - x0, y1 - y0);
    const nextDistance = totalDistance + segmentDistance;
    if (nextDistance > targetDistance) {
      const ratio = (targetDistance - totalDistance) / segmentDistance;
      const point = [x0 + (x1 - x0) * ratio, y0 + (y1 - y0) * ratio];
      const angle = Math.atan2(y1 - y0, x1 - x0);
      return { point, angle };
    }
    totalDistance = nextDistance;
    x0 = x1;
    y0 = y1;
  }
}

// packages/ag-charts-enterprise/src/series/map-util/bboxUtil.ts
import { _ModuleSupport as _ModuleSupport115 } from "ag-charts-community";
var { LonLatBBox } = _ModuleSupport115;
function extendBbox(into, lon0, lat0, lon1, lat1) {
  if (into == null) {
    into = new LonLatBBox(lon0, lat0, lon1, lat1);
  } else {
    into.lon0 = Math.min(into.lon0, lon0);
    into.lat0 = Math.min(into.lat0, lat0);
    into.lon1 = Math.max(into.lon1, lon1);
    into.lat1 = Math.max(into.lat1, lat1);
  }
  return into;
}

// packages/ag-charts-enterprise/src/series/map-util/linkedList.ts
var insertManySorted = (list, items, cmp) => {
  let head = list;
  let current = head;
  for (const value of items) {
    if (head == null || cmp(head.value, value) > 0) {
      head = { value, next: head };
      current = head;
    } else {
      current = current;
      while (current.next != null && cmp(current.next.value, value) <= 0) {
        current = current.next;
      }
      current.next = { value, next: current.next };
    }
  }
  return head;
};

// packages/ag-charts-enterprise/src/series/map-util/polygonUtil.ts
function polygonBbox(polygon, into) {
  polygon.forEach((coordinates) => {
    const [lon, lat] = coordinates;
    into = extendBbox(into, lon, lat, lon, lat);
  });
  return into;
}
function polygonCentroid(polygon) {
  if (polygon.length === 0)
    return;
  let x = 0;
  let y = 0;
  let k = 0;
  let [x0, y0] = polygon[polygon.length - 1];
  for (const [x1, y1] of polygon) {
    const c = x0 * y1 - x1 * y0;
    k += c;
    x += (x0 + x1) * c;
    y += (y0 + y1) * c;
    x0 = x1;
    y0 = y1;
  }
  k *= 3;
  return [x / k, y / k];
}
function polygonDistance(polygons, x, y) {
  let inside = false;
  let minDistanceSquared = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? -1 : 1) * Math.sqrt(minDistanceSquared);
}

// packages/ag-charts-enterprise/src/series/map-util/geoGeometry.ts
var { Path: Path6, ExtendedPath2D, BBox: BBox10, ScenePathChangeDetection: ScenePathChangeDetection2 } = _Scene54;
var GeoGeometry = class extends Path6 {
  constructor() {
    super(...arguments);
    this.projectedGeometry = void 0;
    this.renderMode = 3 /* All */;
    // Keep non-filled shapes separate so we don't fill them
    this.strokePath = new ExtendedPath2D();
  }
  computeBBox() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
    return this.bbox?.clone();
  }
  updatePath() {
    const { projectedGeometry } = this;
    this.strokePath.clear();
    this.path.clear();
    this.bbox = projectedGeometry != null ? this.drawGeometry(projectedGeometry, void 0) : void 0;
  }
  drawPath(ctx) {
    super.drawPath(ctx);
    this.renderStroke(ctx, this.strokePath.getPath2D());
  }
  containsPoint(x, y) {
    const { projectedGeometry } = this;
    if (projectedGeometry == null)
      return false;
    if (!this.getBBox().containsPoint(x, y))
      return false;
    return this.geometryDistance(projectedGeometry, x, y) <= 0;
  }
  distanceToPoint(x, y) {
    const { projectedGeometry } = this;
    return projectedGeometry != null ? this.geometryDistance(projectedGeometry, x, y) : Infinity;
  }
  geometryDistance(geometry, x, y) {
    const { renderMode, strokeWidth } = this;
    const drawPolygons = (renderMode & 1 /* Polygons */) !== 0;
    const drawLines = (renderMode & 2 /* Lines */) !== 0;
    const minStrokeDistance = Math.max(strokeWidth / 2, 1) + 1;
    switch (geometry.type) {
      case "GeometryCollection":
        return geometry.geometries.reduce(
          (minDistance, g) => Math.min(minDistance, this.geometryDistance(g, x, y)),
          Infinity
        );
      case "MultiPolygon":
        return drawPolygons ? geometry.coordinates.reduce(
          (minDistance, polygon) => Math.min(minDistance, Math.max(polygonDistance(polygon, x, y), 0)),
          Infinity
        ) : Infinity;
      case "Polygon":
        return drawPolygons ? Math.max(polygonDistance(geometry.coordinates, x, y), 0) : Infinity;
      case "MultiLineString":
        return drawLines ? geometry.coordinates.reduce((minDistance, lineString) => {
          return Math.min(
            minDistance,
            Math.max(lineStringDistance(lineString, x, y) - minStrokeDistance, 0)
          );
        }, Infinity) : Infinity;
      case "LineString":
        return drawLines ? Math.max(lineStringDistance(geometry.coordinates, x, y) - minStrokeDistance, 0) : Infinity;
      case "MultiPoint":
      case "Point":
      default:
        return Infinity;
    }
  }
  drawGeometry(geometry, bbox) {
    const { renderMode, path, strokePath } = this;
    const drawPolygons = (renderMode & 1 /* Polygons */) !== 0;
    const drawLines = (renderMode & 2 /* Lines */) !== 0;
    switch (geometry.type) {
      case "GeometryCollection":
        geometry.geometries.forEach((g) => {
          bbox = this.drawGeometry(g, bbox);
        });
        break;
      case "MultiPolygon":
        if (drawPolygons) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawPolygon(path, coordinates, bbox);
          });
        }
        break;
      case "Polygon":
        if (drawPolygons) {
          bbox = this.drawPolygon(path, geometry.coordinates, bbox);
        }
        break;
      case "LineString":
        if (drawLines) {
          bbox = this.drawLineString(strokePath, geometry.coordinates, bbox, false);
        }
        break;
      case "MultiLineString":
        if (drawLines) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawLineString(strokePath, coordinates, bbox, false);
          });
        }
        break;
      case "Point":
      case "MultiPoint":
        break;
    }
    return bbox;
  }
  drawPolygon(path, polygons, bbox) {
    if (polygons.length < 1)
      return bbox;
    bbox = this.drawLineString(path, polygons[0], bbox, true);
    for (let i = 1; i < polygons.length; i += 1) {
      const enclave = polygons[i];
      this.drawLineString(path, enclave, void 0, true);
    }
    return bbox;
  }
  drawLineString(path, coordinates, bbox, isClosed) {
    if (coordinates.length < 2)
      return bbox;
    const end = isClosed ? coordinates.length - 1 : coordinates.length;
    for (let i = 0; i < end; i += 1) {
      const [x, y] = coordinates[i];
      if (i === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
      if (bbox == null) {
        bbox = new BBox10(x, y, 0, 0);
      } else {
        const { x: x0, y: y0 } = bbox;
        const x1 = x0 + bbox.width;
        const y1 = y0 + bbox.height;
        bbox.x = Math.min(x0, x);
        bbox.y = Math.min(y0, y);
        bbox.width = Math.max(x1, x) - bbox.x;
        bbox.height = Math.max(y1, y) - bbox.y;
      }
    }
    if (isClosed) {
      path.closePath();
    }
    return bbox;
  }
};
__decorateClass([
  ScenePathChangeDetection2()
], GeoGeometry.prototype, "projectedGeometry", 2);
__decorateClass([
  ScenePathChangeDetection2()
], GeoGeometry.prototype, "renderMode", 2);

// packages/ag-charts-enterprise/src/series/map-util/geometryUtil.ts
function geometryBbox(geometry, into) {
  if (geometry.bbox != null) {
    const [lon0, lat0, lon1, lat1] = geometry.bbox;
    into = extendBbox(into, lon0, lat0, lon1, lat1);
    return into;
  }
  switch (geometry.type) {
    case "GeometryCollection":
      geometry.geometries.forEach((g) => {
        into = geometryBbox(g, into);
      });
      break;
    case "MultiPolygon":
      geometry.coordinates.forEach((c) => {
        if (c.length > 0) {
          into = polygonBbox(c[0], into);
        }
      });
      break;
    case "Polygon":
      if (geometry.coordinates.length > 0) {
        into = polygonBbox(geometry.coordinates[0], into);
      }
      break;
    case "MultiLineString":
      geometry.coordinates.forEach((c) => {
        into = polygonBbox(c, into);
      });
      break;
    case "LineString":
      into = polygonBbox(geometry.coordinates, into);
      break;
    case "MultiPoint":
      geometry.coordinates.forEach((p) => {
        const [lon, lat] = p;
        into = extendBbox(into, lon, lat, lon, lat);
      });
      break;
    case "Point": {
      const [lon, lat] = geometry.coordinates;
      into = extendBbox(into, lon, lat, lon, lat);
      break;
    }
  }
  return into;
}
function largestPolygon(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxArea;
      let maxPolygon;
      geometry.geometries.map((g) => {
        const polygon = largestPolygon(g);
        if (polygon == null)
          return;
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area > maxArea) {
          maxArea = area;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "MultiPolygon": {
      let maxArea;
      let maxPolygon;
      geometry.coordinates.forEach((polygon) => {
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area > maxArea) {
          maxArea = area;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "Polygon":
      return geometry.coordinates;
    case "MultiLineString":
    case "LineString":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function largestLineString(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxLength;
      let maxLineString;
      geometry.geometries.map((g) => {
        const lineString = largestLineString(g);
        if (lineString == null)
          return;
        const length = lineStringLength(lineString);
        if (length == null)
          return;
        if (maxLength == null || length > maxLength) {
          maxLength = length;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "MultiLineString": {
      let maxLength = 0;
      let maxLineString;
      geometry.coordinates.forEach((lineString) => {
        const length = lineStringLength(lineString);
        if (length > maxLength) {
          maxLength = length;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "LineString":
      return geometry.coordinates;
    case "MultiPolygon":
    case "Polygon":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function containsType(geometry, type) {
  if (geometry == null)
    return false;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.some((g) => containsType(g, type));
    case "MultiPolygon":
    case "Polygon":
      return (type & 1 /* Polygon */) !== 0;
    case "MultiLineString":
    case "LineString":
      return (type & 2 /* LineString */) !== 0;
    case "MultiPoint":
    case "Point":
      return (type & 4 /* Point */) !== 0;
  }
}
function projectGeometry(geometry, scale) {
  switch (geometry.type) {
    case "GeometryCollection":
      return {
        type: "GeometryCollection",
        geometries: geometry.geometries.map((g) => projectGeometry(g, scale))
      };
    case "Polygon":
      return {
        type: "Polygon",
        coordinates: projectPolygon(geometry.coordinates, scale)
      };
    case "MultiPolygon":
      return {
        type: "MultiPolygon",
        coordinates: projectMultiPolygon(geometry.coordinates, scale)
      };
    case "MultiLineString":
      return {
        type: "MultiLineString",
        coordinates: projectPolygon(geometry.coordinates, scale)
      };
    case "LineString":
      return {
        type: "LineString",
        coordinates: projectLineString(geometry.coordinates, scale)
      };
    case "MultiPoint":
      return {
        type: "MultiPoint",
        coordinates: projectLineString(geometry.coordinates, scale)
      };
    case "Point":
      return {
        type: "Point",
        coordinates: scale.convert(geometry.coordinates)
      };
  }
}
function projectMultiPolygon(multiPolygon, scale) {
  return multiPolygon.map((polygon) => projectPolygon(polygon, scale));
}
function projectPolygon(polygon, scale) {
  return polygon.map((lineString) => projectLineString(lineString, scale));
}
function projectLineString(lineString, scale) {
  return lineString.map((lonLat) => scale.convert(lonLat));
}

// packages/ag-charts-enterprise/src/series/map-util/validation.ts
import { _ModuleSupport as _ModuleSupport117 } from "ag-charts-community";
function isValidCoordinate(v) {
  return Array.isArray(v) && v.length >= 2 && v.every(_ModuleSupport117.isFiniteNumber);
}
function isValidCoordinates(v) {
  return Array.isArray(v) && v.length >= 2 && v.every(isValidCoordinate);
}
var delta2 = 1e-3;
function hasSameStartEndPoint(c) {
  return Math.abs(c[0][0] - c[c.length - 1][0]) < delta2 && Math.abs(c[0][1] - c[c.length - 1][1]) < delta2;
}
function isValidPolygon(v) {
  return Array.isArray(v) && v.every(isValidCoordinates) && v.every(hasSameStartEndPoint);
}
function isValidGeometry(v) {
  if (v === null)
    return true;
  if (typeof v !== "object" || v.type == null)
    return false;
  const { type, coordinates } = v;
  switch (type) {
    case "GeometryCollection":
      return Array.isArray(v.geometries) && v.geometries.every(isValidGeometry);
    case "MultiPolygon":
      return Array.isArray(coordinates) && coordinates.every(isValidPolygon);
    case "Polygon":
      return isValidPolygon(coordinates);
    case "MultiLineString":
      return Array.isArray(coordinates) && coordinates.every(isValidCoordinates);
    case "LineString":
      return isValidCoordinates(coordinates);
    case "MultiPoint":
      return isValidCoordinates(coordinates);
    case "Point":
      return isValidCoordinate(coordinates);
  }
}
function isValidFeature(v) {
  return v !== null && typeof v === "object" && v.type === "Feature" && isValidGeometry(v.geometry);
}
function isValidFeatureCollection(v) {
  return v !== null && typeof v === "object" && v.type === "FeatureCollection" && Array.isArray(v.features) && v.features.every(isValidFeature);
}
var GEOJSON_OBJECT = _ModuleSupport117.predicateWithMessage(isValidFeatureCollection, "a GeoJSON object");

// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport118 } from "ag-charts-community";
var { COLOR_STRING: COLOR_STRING15, LINE_DASH: LINE_DASH10, OBJECT: OBJECT23, POSITIVE_NUMBER: POSITIVE_NUMBER17, RATIO: RATIO19, Validate: Validate53, SeriesProperties: SeriesProperties3, SeriesTooltip: SeriesTooltip7 } = _ModuleSupport118;
var MapLineBackgroundSeriesProperties = class extends SeriesProperties3 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = new SeriesTooltip7();
  }
};
__decorateClass([
  Validate53(GEOJSON_OBJECT, { optional: true })
], MapLineBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass([
  Validate53(COLOR_STRING15)
], MapLineBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate53(RATIO19)
], MapLineBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate53(POSITIVE_NUMBER17)
], MapLineBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate53(LINE_DASH10)
], MapLineBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate53(POSITIVE_NUMBER17)
], MapLineBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate53(OBJECT23)
], MapLineBackgroundSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeries.ts
var { createDatumId: createDatumId4, DataModelSeries: DataModelSeries2, SeriesNodePickMode: SeriesNodePickMode6, Validate: Validate54 } = _ModuleSupport119;
var { Group: Group8, Selection: Selection5, PointerEvents: PointerEvents3 } = _Scene55;
var { Logger: Logger14 } = _Util74;
var MapLineBackgroundSeries = class extends DataModelSeries2 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode6.EXACT_SHAPE_MATCH]
    });
    this.properties = new MapLineBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group8({ name: "itemGroup" }));
    this.datumSelection = Selection5.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  get hasData() {
    return false;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2 /* Lines */;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    geoGeometry.pointerEvents = PointerEvents3.None;
    return geoGeometry;
  }
  async processData() {
    const { topology } = this;
    this.topologyBounds = topology?.features.reduce((current, feature) => {
      const geometry = feature.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (topology == null) {
      Logger14.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
    }
  }
  async createNodeData() {
    const { id: seriesId, topology, scale } = this;
    if (topology == null)
      return;
    const nodeData = [];
    const labelData = [];
    topology.features.forEach((feature, index) => {
      const { geometry } = feature;
      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;
      if (projectedGeometry == null)
        return;
      nodeData.push({
        series: this,
        itemId: index,
        datum: feature,
        index,
        projectedGeometry
      });
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  async update() {
    const { datumSelection } = this;
    await this.updateSelections();
    this.contentGroup.visible = this.visible;
    const { nodeData = [] } = this.contextNodeData ?? {};
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection });
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId4(datum.index));
  }
  async updateDatumNodes(opts) {
    const { properties } = this;
    const { datumSelection } = opts;
    const { stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = properties;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.stroke = stroke2;
      geoGeometry.strokeWidth = strokeWidth;
      geoGeometry.strokeOpacity = strokeOpacity;
      geoGeometry.lineDash = lineDash;
      geoGeometry.lineDashOffset = lineDashOffset;
    });
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipHtml() {
    return _ModuleSupport119.EMPTY_TOOLTIP_CONTENT;
  }
  computeFocusBounds(_opts) {
    return void 0;
  }
};
MapLineBackgroundSeries.className = "MapLineBackgroundSeries";
MapLineBackgroundSeries.type = "map-line-background";
__decorateClass([
  Validate54(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapLineBackgroundSeries.prototype, "_chartTopology", 2);

// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundModule.ts
var { DEFAULT_HIERARCHY_STROKES } = _Theme19;
var MapLineBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line-background",
  moduleFactory: (ctx) => new MapLineBackgroundSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0
    }
  },
  paletteFactory: ({ themeTemplateParameters }) => {
    return {
      stroke: themeTemplateParameters.get(DEFAULT_HIERARCHY_STROKES)?.[1]
    };
  }
};

// packages/ag-charts-enterprise/src/series/map-line/mapLineModule.ts
import { _Theme as _Theme20 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-line/mapLineSeries.ts
import { _ModuleSupport as _ModuleSupport122, _Scale as _Scale14, _Scene as _Scene57, _Util as _Util76 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/mapUtil.ts
function prepareMapMarkerAnimationFunctions() {
  const fromFn = (marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 1, scalingY: 1 };
    } else if (marker.previousDatum == null) {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: marker.scalingX, scalingY: marker.scalingY };
  };
  const toFn = (_marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: 1, scalingY: 1 };
  };
  return { fromFn, toFn };
}
function findFocusedGeoGeometry(series, opts) {
  const datum = series.contextNodeData?.nodeData[opts.datumIndex];
  if (datum === void 0)
    return void 0;
  for (const node of series.datumSelection.nodes()) {
    if (node.datum === datum) {
      return node;
    }
  }
  return void 0;
}

// packages/ag-charts-enterprise/src/series/map-line/mapLineSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport121, _Scene as _Scene56 } from "ag-charts-community";
var {
  AND: AND8,
  ARRAY: ARRAY7,
  COLOR_STRING: COLOR_STRING16,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY4,
  FUNCTION: FUNCTION10,
  LINE_DASH: LINE_DASH11,
  NUMBER_ARRAY: NUMBER_ARRAY2,
  OBJECT: OBJECT24,
  POSITIVE_NUMBER: POSITIVE_NUMBER18,
  RATIO: RATIO20,
  STRING: STRING26,
  Validate: Validate55,
  SeriesProperties: SeriesProperties4,
  SeriesTooltip: SeriesTooltip8
} = _ModuleSupport121;
var { Label: Label5 } = _Scene56;
var MapLineSeriesProperties = class extends SeriesProperties4 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.maxStrokeWidth = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.label = new Label5();
    this.tooltip = new SeriesTooltip8();
  }
};
__decorateClass([
  Validate55(GEOJSON_OBJECT, { optional: true })
], MapLineSeriesProperties.prototype, "topology", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Validate55(STRING26)
], MapLineSeriesProperties.prototype, "idKey", 2);
__decorateClass([
  Validate55(STRING26)
], MapLineSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "idName", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate55(STRING26, { optional: true })
], MapLineSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate55(NUMBER_ARRAY2, { optional: true })
], MapLineSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass([
  Validate55(AND8(COLOR_STRING_ARRAY4, ARRAY7.restrict({ minLength: 1 })), { optional: true })
], MapLineSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate55(POSITIVE_NUMBER18, { optional: true })
], MapLineSeriesProperties.prototype, "maxStrokeWidth", 2);
__decorateClass([
  Validate55(COLOR_STRING16)
], MapLineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate55(RATIO20)
], MapLineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate55(POSITIVE_NUMBER18)
], MapLineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate55(LINE_DASH11)
], MapLineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate55(POSITIVE_NUMBER18)
], MapLineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate55(FUNCTION10, { optional: true })
], MapLineSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate55(OBJECT24)
], MapLineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate55(OBJECT24)
], MapLineSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/map-line/mapLineSeries.ts
var {
  getMissCount: getMissCount2,
  createDatumId: createDatumId5,
  DataModelSeries: DataModelSeries3,
  SeriesNodePickMode: SeriesNodePickMode7,
  valueProperty: valueProperty8,
  CachedTextMeasurerPool: CachedTextMeasurerPool5,
  Validate: Validate56
} = _ModuleSupport122;
var { ColorScale: ColorScale4, LinearScale: LinearScale3 } = _Scale14;
var { Selection: Selection6, Text: Text4 } = _Scene57;
var { sanitizeHtml: sanitizeHtml5, Logger: Logger15 } = _Util76;
var MapLineSeries = class extends DataModelSeries3 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode7.EXACT_SHAPE_MATCH, SeriesNodePickMode7.NEAREST_NODE]
    });
    this.properties = new MapLineSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale4();
    this.sizeScale = new LinearScale3();
    this.datumSelection = Selection6.select(
      this.contentGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection6.select(
      this.labelGroup,
      Text4
    );
    this.highlightDatumSelection = Selection6.select(
      this.highlightNode,
      () => this.nodeFactory()
    );
    this._previousDatumMidPoint = void 0;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2 /* Lines */;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    return geoGeometry;
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    const { data, topology, sizeScale, colorScale } = this;
    const { topologyIdKey, idKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null || !containsType(feature.geometry, 2 /* LineString */))
        return;
      featureById.set(property, feature);
    });
    const sizeScaleType = this.sizeScale.type;
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        valueProperty8(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
        valueProperty8(idKey, mercatorScaleType, {
          id: "featureValue",
          includeProperty: false,
          processor: () => (datum) => featureById.get(datum)
        }),
        ...labelKey != null ? [valueProperty8(labelKey, "band", { id: "labelValue" })] : [],
        ...sizeKey != null ? [valueProperty8(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
        ...colorKey != null ? [valueProperty8(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
    this.topologyBounds = processedData.data.reduce(
      (current, { values }) => {
        const feature = values[featureIdx];
        const geometry = feature?.geometry;
        if (geometry == null)
          return current;
        return geometryBbox(geometry, current);
      },
      void 0
    );
    if (sizeKey != null) {
      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
      const processedSize = processedData.domain.values[sizeIdx] ?? [];
      sizeScale.domain = sizeDomain ?? processedSize;
    }
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    if (topology == null) {
      Logger15.warnOnce(`no topology was provided for [MapLineSeries]; nothing will be rendered.`);
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount2(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, projectedGeometry, font2) {
    if (labelValue == null || projectedGeometry == null)
      return;
    const lineString = largestLineString(projectedGeometry);
    if (lineString == null)
      return;
    const { idKey, idName, sizeKey, sizeName, colorKey, colorName, labelKey, labelName, label } = this.properties;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const labelSize = CachedTextMeasurerPool5.measureText(String(labelText), { font: font2 });
    const labelCenter = lineStringCenter(lineString);
    if (labelCenter == null)
      return;
    const [x, y] = labelCenter.point;
    const { width, height } = labelSize;
    return {
      point: { x, y, size: 0 },
      label: { width, height, text: labelText },
      marker: void 0,
      placement: void 0
    };
  }
  async createNodeData() {
    const { id: seriesId, dataModel, processedData, sizeScale, colorScale, properties, scale } = this;
    const { idKey, sizeKey, colorKey, labelKey, label } = properties;
    if (dataModel == null || processedData == null)
      return;
    const colorScaleValid = this.isColorScaleValid();
    const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);
    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
    const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
    const maxStrokeWidth = properties.maxStrokeWidth ?? properties.strokeWidth;
    sizeScale.range = [Math.min(properties.strokeWidth, maxStrokeWidth), maxStrokeWidth];
    const font2 = label.getFont();
    const projectedGeometries = /* @__PURE__ */ new Map();
    processedData.data.forEach(({ values }) => {
      const id = values[idIdx];
      const geometry = values[featureIdx]?.geometry;
      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;
      if (id != null && projectedGeometry != null) {
        projectedGeometries.set(id, projectedGeometry);
      }
    });
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    processedData.data.forEach(({ datum, values }) => {
      const idValue = values[idIdx];
      const colorValue = colorIdx != null ? values[colorIdx] : void 0;
      const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;
      const labelValue = labelIdx != null ? values[labelIdx] : void 0;
      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
      const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: "clamped" }) : void 0;
      const projectedGeometry = projectedGeometries.get(idValue);
      if (projectedGeometry == null) {
        missingGeometries.push(idValue);
      }
      const labelDatum = this.getLabelDatum(datum, labelValue, projectedGeometry, font2);
      if (labelDatum != null) {
        labelData.push(labelDatum);
      }
      nodeData.push({
        series: this,
        itemId: idKey,
        datum,
        stroke: color,
        strokeWidth: size,
        idValue,
        labelValue,
        colorValue,
        sizeValue,
        projectedGeometry
      });
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      Logger15.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  async update() {
    const { datumSelection, labelSelection, highlightDatumSelection } = this;
    await this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection, isHighlight: false });
    this.labelSelection = await this.updateLabelSelection({ labelSelection });
    await this.updateLabelNodes({ labelSelection });
    this.highlightDatumSelection = await this.updateDatumSelection({
      nodeData: highlightedDatum != null ? [highlightedDatum] : [],
      datumSelection: highlightDatumSelection
    });
    await this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId5(datum.idValue));
  }
  async updateDatumNodes(opts) {
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { datumSelection, isHighlight } = opts;
    const { idKey, labelKey, sizeKey, colorKey, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset, itemStyler } = properties;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          idKey,
          labelKey,
          sizeKey,
          colorKey,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: isHighlight
        });
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.stroke = highlightStyle?.stroke ?? format?.stroke ?? datum.stroke ?? stroke2;
      geoGeometry.strokeWidth = Math.max(
        highlightStyle?.strokeWidth ?? 0,
        format?.strokeWidth ?? datum.strokeWidth ?? strokeWidth
      );
      geoGeometry.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      geoGeometry.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      geoGeometry.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
    });
  }
  async updateLabelSelection(opts) {
    const placedLabels = (this.isLabelEnabled() ? this.chart?.placeLabels().get(this) : void 0) ?? [];
    return opts.labelSelection.update(placedLabels);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
    labelSelection.each((label, { x, y, width, height, text: text2 }) => {
      label.visible = true;
      label.x = x + width / 2;
      label.y = y + height / 2;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  resetAnimation() {
  }
  getLabelData() {
    return this.contextNodeData?.labelData ?? [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistance = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distance = node.distanceToPoint(x, y);
      if (distance < minDistance) {
        minDistance = distance;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;
  }
  datumMidPoint(datum) {
    const { _previousDatumMidPoint } = this;
    if (_previousDatumMidPoint?.datum === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const lineString = projectedGeometry != null ? largestLineString(projectedGeometry) : void 0;
    const center = lineString != null ? lineStringCenter(lineString)?.point : void 0;
    const point = center != null ? { x: center[0], y: center[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      colorRange,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      visible
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: legendItemName ?? title ?? idName ?? idKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey },
        symbols: [
          {
            marker: {
              fill: stroke2,
              fillOpacity: strokeOpacity,
              stroke: void 0,
              strokeWidth: 0,
              strokeOpacity: 0,
              enabled: false
            },
            line: {
              stroke: stroke2,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ],
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      properties,
      ctx: { callbackCache }
    } = this;
    if (!processedData || !properties.isValid()) {
      return _ModuleSupport122.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      itemStyler,
      tooltip,
      strokeOpacity,
      lineDash,
      lineDashOffset
    } = properties;
    const { datum, stroke: stroke2, idValue, colorValue, sizeValue, labelValue, itemId } = nodeDatum;
    const title = sanitizeHtml5(properties.title ?? legendItemName) ?? "";
    const contentLines = [];
    contentLines.push(sanitizeHtml5((idName != null ? `${idName}: ` : "") + idValue));
    if (colorValue != null) {
      contentLines.push(sanitizeHtml5((colorName ?? colorKey) + ": " + colorValue));
    }
    if (sizeValue != null) {
      contentLines.push(sanitizeHtml5((sizeName ?? sizeKey) + ": " + sizeValue));
    }
    if (labelValue != null && labelKey !== idKey) {
      contentLines.push(sanitizeHtml5((labelName ?? labelKey) + ": " + labelValue));
    }
    const content = contentLines.join("<br>");
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        highlighted: false,
        seriesId,
        datum,
        idKey,
        sizeKey,
        colorKey,
        labelKey,
        stroke: stroke2,
        strokeWidth: this.getStrokeWidth(nodeDatum.strokeWidth ?? properties.strokeWidth),
        strokeOpacity,
        lineDash,
        lineDashOffset
      });
    }
    const color = format?.stroke ?? stroke2 ?? properties.stroke;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        idKey,
        title,
        color,
        itemId,
        sizeKey,
        colorKey,
        colorName,
        idName,
        labelKey,
        labelName,
        sizeName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  computeFocusBounds(opts) {
    const geometry = findFocusedGeoGeometry(this, opts);
    return geometry ? _Scene57.Transformable.toCanvas(geometry) : void 0;
  }
};
MapLineSeries.className = "MapLineSeries";
MapLineSeries.type = "map-line";
__decorateClass([
  Validate56(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapLineSeries.prototype, "_chartTopology", 2);

// packages/ag-charts-enterprise/src/series/map-line/mapLineModule.ts
var { DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY3, DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR3, singleSeriesPaletteFactory } = _Theme20;
var MapLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line",
  moduleFactory: (ctx) => new MapLineSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      strokeWidth: 1,
      maxStrokeWidth: 3,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: true,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY3,
        color: DEFAULT_LABEL_COLOUR3
      }
    }
  },
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill } = singleSeriesPaletteFactory(opts);
    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    const { fills } = takeColors(colorsCount);
    return {
      colorRange: userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]],
      stroke: fill
    };
  }
};

// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerModule.ts
import { _Theme as _Theme21 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeries.ts
import { _ModuleSupport as _ModuleSupport125, _Scale as _Scale15, _Scene as _Scene59, _Util as _Util78 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/polygonPointSearch.ts
function polygonPointSearch(polygons, precision, valueFn) {
  const bbox = polygonBbox(polygons[0], void 0);
  if (bbox == null)
    return;
  const boundingXCenter = (bbox.lon0 + bbox.lon1) / 2;
  const boundingYCenter = (bbox.lat0 + bbox.lat1) / 2;
  const boundingWidth = Math.abs(bbox.lon1 - bbox.lon0);
  const boundingHeight = Math.abs(bbox.lat1 - bbox.lat0);
  const centroid = polygonCentroid(polygons[0]);
  const [cx, cy] = centroid;
  const centroidDistanceToPolygon = -polygonDistance(polygons, cx, cy);
  let bestResult;
  const cellValue = (distanceToPolygon, distanceToCentroid) => {
    const centroidDriftFactor = 0.5;
    const centroidDrift = Math.max(distanceToCentroid - centroidDistanceToPolygon, 0);
    return distanceToPolygon - centroidDriftFactor * centroidDrift;
  };
  const createLabelPlacement = (x2, y2, stride) => {
    const { distance: distance2, maxDistance } = valueFn(polygons, x2, y2, stride);
    const distanceToCentroid = Math.hypot(cx - x2, cy - y2);
    const maxXTowardsCentroid = Math.min(Math.max(cx, x2 - stride / 2), x2 + stride / 2);
    const maxYTowardsCentroid = Math.min(Math.max(cy, y2 - stride / 2), y2 + stride / 2);
    const minDistanceToCentroid = Math.hypot(cx - maxXTowardsCentroid, cy - maxYTowardsCentroid);
    const value = cellValue(distance2, distanceToCentroid);
    const maxValue = cellValue(maxDistance, minDistanceToCentroid);
    return { distance: distance2, maxDistance, value, maxValue, x: x2, y: y2, stride };
  };
  const appendLabelPlacement = (into, x2, y2, stride) => {
    const labelPlacement = createLabelPlacement(x2, y2, stride);
    if (labelPlacement.maxDistance >= 0) {
      into.push(labelPlacement);
    }
  };
  const initialStride = Math.min(boundingWidth, boundingHeight) / 2;
  let queue = {
    value: createLabelPlacement(boundingXCenter, boundingYCenter, initialStride),
    next: null
  };
  while (queue != null) {
    const item = queue.value;
    const { distance: distance2, value, maxValue, x: x2, y: y2, stride } = item;
    queue = queue.next;
    if (distance2 > 0 && (bestResult == null || value > bestResult.value)) {
      bestResult = item;
    }
    if (bestResult != null && maxValue - bestResult.value <= precision) {
      continue;
    }
    const nextStride = stride / 2;
    const newLabelPlacements = [];
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 + nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 + nextStride, nextStride);
    newLabelPlacements.sort(labelPlacementCmp);
    queue = insertManySorted(queue, newLabelPlacements, labelPlacementCmp);
  }
  if (bestResult == null)
    return;
  const { distance, x, y } = bestResult;
  return { x, y, distance };
}
var labelPlacementCmp = (a, b) => b.maxValue - a.maxValue;

// packages/ag-charts-enterprise/src/series/map-util/markerUtil.ts
function polygonMarkerCenter(polygons, precision) {
  const result = polygonPointSearch(polygons, precision, (p, x2, y2, stride) => {
    const distance = -polygonDistance(p, x2, y2);
    const maxDistance = distance + stride * Math.SQRT2;
    return { distance, maxDistance };
  });
  if (result == null)
    return;
  const { x, y } = result;
  return [x, y];
}
function markerPositions(geometry, precision) {
  let center;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.flatMap((g) => markerPositions(g, precision));
    case "MultiPoint":
      return geometry.coordinates;
    case "Point":
      return [geometry.coordinates];
    case "MultiPolygon": {
      const polygon = largestPolygon(geometry);
      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "Polygon": {
      const polygon = geometry.coordinates;
      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "MultiLineString": {
      const lineString = largestLineString(geometry);
      center = lineString != null ? lineStringCenter(lineString)?.point : void 0;
      break;
    }
    case "LineString": {
      const lineString = geometry.coordinates;
      center = lineStringCenter(lineString)?.point;
      break;
    }
  }
  return center != null ? [center] : [];
}

// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport124, _Scene as _Scene58, _Util as _Util77 } from "ag-charts-community";
var {
  AND: AND9,
  ARRAY: ARRAY8,
  COLOR_STRING: COLOR_STRING17,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY5,
  FUNCTION: FUNCTION11,
  NUMBER_ARRAY: NUMBER_ARRAY3,
  OBJECT: OBJECT25,
  POSITIVE_NUMBER: POSITIVE_NUMBER19,
  RATIO: RATIO21,
  STRING: STRING27,
  MARKER_SHAPE: MARKER_SHAPE2,
  Validate: Validate57,
  SeriesProperties: SeriesProperties5,
  SeriesTooltip: SeriesTooltip9
} = _ModuleSupport124;
var { Label: Label6, Circle } = _Scene58;
var { Logger: Logger16 } = _Util77;
var MapMarkerSeriesLabel = class extends Label6 {
  constructor() {
    super(...arguments);
    this.placement = "bottom";
  }
};
__decorateClass([
  Validate57(STRING27)
], MapMarkerSeriesLabel.prototype, "placement", 2);
var MapMarkerSeriesProperties = class extends SeriesProperties5 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = void 0;
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.latitudeKey = void 0;
    this.latitudeName = void 0;
    this.longitudeKey = void 0;
    this.longitudeName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.shape = Circle;
    this.size = 6;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.label = new MapMarkerSeriesLabel();
    this.tooltip = new SeriesTooltip9();
  }
  isValid() {
    const superIsValid = super.isValid();
    const hasTopology = this.idKey != null;
    const hasLatLon = this.latitudeKey != null && this.longitudeKey != null;
    if (!hasTopology && !hasLatLon) {
      Logger16.warnOnce(
        "Either both [topology] and [idKey] or both [latitudeKey] and [longitudeKey] must be set to render a map marker series."
      );
      return false;
    }
    return superIsValid;
  }
};
__decorateClass([
  Validate57(GEOJSON_OBJECT, { optional: true })
], MapMarkerSeriesProperties.prototype, "topology", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "idKey", 2);
__decorateClass([
  Validate57(STRING27)
], MapMarkerSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "idName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "latitudeKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "latitudeName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "longitudeKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "longitudeName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate57(STRING27, { optional: true })
], MapMarkerSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate57(AND9(COLOR_STRING_ARRAY5, ARRAY8.restrict({ minLength: 1 })), { optional: true })
], MapMarkerSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate57(MARKER_SHAPE2)
], MapMarkerSeriesProperties.prototype, "shape", 2);
__decorateClass([
  Validate57(POSITIVE_NUMBER19)
], MapMarkerSeriesProperties.prototype, "size", 2);
__decorateClass([
  Validate57(POSITIVE_NUMBER19, { optional: true })
], MapMarkerSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
  Validate57(NUMBER_ARRAY3, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass([
  Validate57(COLOR_STRING17, { optional: true })
], MapMarkerSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate57(RATIO21)
], MapMarkerSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate57(COLOR_STRING17, { optional: true })
], MapMarkerSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate57(POSITIVE_NUMBER19)
], MapMarkerSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate57(RATIO21)
], MapMarkerSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate57(FUNCTION11, { optional: true })
], MapMarkerSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate57(OBJECT25)
], MapMarkerSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate57(OBJECT25)
], MapMarkerSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeries.ts
var {
  CachedTextMeasurerPool: CachedTextMeasurerPool6,
  Validate: Validate58,
  fromToMotion: fromToMotion3,
  StateMachine: StateMachine11,
  getMissCount: getMissCount3,
  createDatumId: createDatumId6,
  DataModelSeries: DataModelSeries4,
  SeriesNodePickMode: SeriesNodePickMode8,
  Layers: Layers10,
  valueProperty: valueProperty9,
  computeMarkerFocusBounds
} = _ModuleSupport125;
var { ColorScale: ColorScale5, LinearScale: LinearScale4 } = _Scale15;
var { Group: Group9, Selection: Selection7, Text: Text5, getMarker: getMarker2 } = _Scene59;
var { sanitizeHtml: sanitizeHtml6, Logger: Logger17 } = _Util78;
var MapMarkerSeries = class extends DataModelSeries4 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: true,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode8.EXACT_SHAPE_MATCH, SeriesNodePickMode8.NEAREST_NODE]
    });
    this.properties = new MapMarkerSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale5();
    this.sizeScale = new LinearScale4();
    this.markerGroup = this.contentGroup.appendChild(
      new Group9({
        name: "markerGroup",
        layer: true,
        isVirtual: false,
        zIndex: Layers10.SERIES_LAYER_ZINDEX,
        zIndexSubOrder: this.getGroupZIndexSubOrder("marker")
      })
    );
    this.labelSelection = Selection7.select(
      this.labelGroup,
      Text5,
      false
    );
    this.markerSelection = Selection7.select(
      this.markerGroup,
      () => this.markerFactory(),
      false
    );
    this.highlightMarkerSelection = Selection7.select(
      this.highlightNode,
      () => this.markerFactory()
    );
    this.animationState = new StateMachine11(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          resize: () => this.resetAllAnimation(),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          // chart.ts transitions to updateData on zoom change
          resize: {
            target: "ready",
            action: () => this.resetAllAnimation()
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: () => this.resetAllAnimation()
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    const hasLatLon = this.properties.latitudeKey != null && this.properties.longitudeKey != null;
    return super.hasData && (this.topology != null || hasLatLon);
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  markerFactory() {
    const { shape } = this.properties;
    const MarkerShape = getMarker2(shape);
    return new MarkerShape();
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    const { data, topology, sizeScale, colorScale } = this;
    const { topologyIdKey, idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null)
        return;
      featureById.set(property, feature);
    });
    const sizeScaleType = this.sizeScale.type;
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const hasLatLon = latitudeKey != null && longitudeKey != null;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        ...idKey != null ? [
          valueProperty9(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
          valueProperty9(idKey, mercatorScaleType, {
            id: "featureValue",
            includeProperty: false,
            processor: () => (datum) => featureById.get(datum)
          })
        ] : [],
        ...hasLatLon ? [
          valueProperty9(latitudeKey, mercatorScaleType, { id: "latValue" }),
          valueProperty9(longitudeKey, mercatorScaleType, { id: "lonValue" })
        ] : [],
        ...labelKey ? [valueProperty9(labelKey, "band", { id: "labelValue" })] : [],
        ...sizeKey ? [valueProperty9(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
        ...colorKey ? [valueProperty9(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;
    const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;
    const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;
    this.topologyBounds = processedData.data.reduce(
      (current, { values }) => {
        const feature = featureIdx != null ? values[featureIdx] : void 0;
        const geometry = feature?.geometry;
        if (geometry != null) {
          current = geometryBbox(geometry, current);
        }
        if (latIdx != null && lonIdx != null) {
          const lon = values[lonIdx];
          const lat = values[latIdx];
          current = extendBbox(current, lon, lat, lon, lat);
        }
        return current;
      },
      void 0
    );
    if (sizeKey != null) {
      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
      const processedSize = processedData.domain.values[sizeIdx] ?? [];
      sizeScale.domain = sizeDomain ?? processedSize;
    }
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    this.animationState.transition("updateData");
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount3(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, x, y, size, font2) {
    if (labelValue == null)
      return;
    const {
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      label
    } = this.properties;
    const { placement } = label;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const { width, height } = CachedTextMeasurerPool6.measureText(String(labelText), { font: font2 });
    return {
      point: { x, y, size },
      label: { width, height, text: labelText },
      marker: getMarker2(this.properties.shape),
      placement
    };
  }
  async createNodeData() {
    const { id: seriesId, dataModel, processedData, colorScale, sizeScale, properties, scale } = this;
    const { idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, label } = properties;
    if (dataModel == null || processedData == null || scale == null)
      return;
    const colorScaleValid = this.isColorScaleValid();
    const hasLatLon = latitudeKey != null && longitudeKey != null;
    const idIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `idValue`) : void 0;
    const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;
    const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;
    const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;
    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
    const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
    const markerMaxSize = properties.maxSize ?? properties.size;
    sizeScale.range = [Math.min(properties.size, markerMaxSize), markerMaxSize];
    const font2 = label.getFont();
    let projectedGeometries;
    if (idIdx != null && featureIdx != null) {
      projectedGeometries = /* @__PURE__ */ new Map();
      processedData.data.forEach(({ values }) => {
        const id = values[idIdx];
        const geometry = values[featureIdx]?.geometry;
        const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;
        if (id != null && projectedGeometry != null) {
          projectedGeometries.set(id, projectedGeometry);
        }
      });
    }
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    processedData.data.forEach(({ datum, values }) => {
      const idValue = idIdx != null ? values[idIdx] : void 0;
      const lonValue = lonIdx != null ? values[lonIdx] : void 0;
      const latValue = latIdx != null ? values[latIdx] : void 0;
      const colorValue = colorIdx != null ? values[colorIdx] : void 0;
      const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;
      const labelValue = labelIdx != null ? values[labelIdx] : void 0;
      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
      const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: "clamped" }) : properties.size;
      const projectedGeometry = idValue != null ? projectedGeometries?.get(idValue) : void 0;
      if (idValue != null && projectGeometry == null) {
        missingGeometries.push(idValue);
      }
      if (lonValue != null && latValue != null) {
        const [x, y] = scale.convert([lonValue, latValue]);
        const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font2);
        if (labelDatum) {
          labelData.push(labelDatum);
        }
        nodeData.push({
          series: this,
          itemId: latitudeKey,
          datum,
          index: -1,
          fill: color,
          idValue,
          lonValue,
          latValue,
          labelValue,
          sizeValue,
          colorValue,
          point: { x, y, size },
          midPoint: { x, y }
        });
      } else if (projectedGeometry != null) {
        markerPositions(projectedGeometry, 1).forEach(([x, y], index) => {
          const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font2);
          if (labelDatum) {
            labelData.push(labelDatum);
          }
          nodeData.push({
            series: this,
            itemId: latitudeKey,
            datum,
            index,
            fill: color,
            idValue,
            lonValue,
            latValue,
            labelValue,
            sizeValue,
            colorValue,
            point: { x, y, size },
            midPoint: { x, y }
          });
        });
      }
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      Logger17.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  checkScaleChange() {
    if (this.previousScale === this.scale)
      return false;
    this.previousScale = this.scale;
    return true;
  }
  async update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    const scaleChange = this.checkScaleChange();
    const { labelSelection, markerSelection, highlightMarkerSelection } = this;
    await this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    this.labelSelection = await this.updateLabelSelection({ labelSelection });
    await this.updateLabelNodes({ labelSelection });
    this.markerSelection = await this.updateMarkerSelection({ markerData: nodeData, markerSelection });
    await this.updateMarkerNodes({ markerSelection, isHighlight: false, highlightedDatum });
    this.highlightMarkerSelection = await this.updateMarkerSelection({
      markerData: highlightedDatum != null ? [highlightedDatum] : [],
      markerSelection: highlightMarkerSelection
    });
    await this.updateMarkerNodes({
      markerSelection: highlightMarkerSelection,
      isHighlight: true,
      highlightedDatum
    });
    if (scaleChange || resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  async updateLabelSelection(opts) {
    const placedLabels = (this.isLabelEnabled() ? this.chart?.placeLabels().get(this) : void 0) ?? [];
    return opts.labelSelection.update(placedLabels);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
    labelSelection.each((label, { x, y, width, height, text: text2 }) => {
      label.visible = true;
      label.x = x + width / 2;
      label.y = y + height / 2;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
    });
  }
  async updateMarkerSelection(opts) {
    const { markerData, markerSelection } = opts;
    return markerSelection.update(
      markerData,
      void 0,
      (datum) => createDatumId6([datum.index, datum.idValue, datum.lonValue, datum.latValue])
    );
  }
  async updateMarkerNodes(opts) {
    const { properties } = this;
    const { markerSelection, isHighlight, highlightedDatum } = opts;
    const { fill, fillOpacity, stroke: stroke2, strokeOpacity } = properties;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    markerSelection.each((marker, markerDatum) => {
      const { datum, point } = markerDatum;
      const format = this.getMapMarkerStyle(markerDatum, isHighlight);
      marker.size = format?.size ?? point.size;
      marker.fill = highlightStyle?.fill ?? format?.fill ?? markerDatum.fill ?? fill;
      marker.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      marker.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      marker.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;
      marker.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      marker.translationX = point.x;
      marker.translationY = point.y;
      marker.zIndex = !isHighlight && highlightedDatum != null && datum === highlightedDatum.datum ? 1 : 0;
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  isProcessedDataAnimatable() {
    return true;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.ctx.animationManager.skipCurrentBatch();
    this.labelSelection.cleanup();
    this.markerSelection.cleanup();
    this.highlightMarkerSelection.cleanup();
  }
  animateMarkers() {
    const { animationManager } = this.ctx;
    const fns = prepareMapMarkerAnimationFunctions();
    fromToMotion3(this.id, "markers", animationManager, [this.markerSelection, this.highlightMarkerSelection], fns);
  }
  getLabelData() {
    return this.contextNodeData?.labelData ?? [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum(p) {
    const { x: x0, y: y0 } = p;
    let minDistanceSquared = Infinity;
    let minDatum;
    this.contextNodeData?.nodeData.forEach((datum) => {
      const { x, y, size } = datum.point;
      const dx2 = Math.max(Math.abs(x - x0) - size, 0);
      const dy2 = Math.max(Math.abs(y - y0) - size, 0);
      const distanceSquared = dx2 * dx2 + dy2 * dy2;
      if (distanceSquared < minDistanceSquared) {
        minDistanceSquared = distanceSquared;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idName,
      idKey,
      colorKey,
      colorName,
      colorRange,
      visible,
      shape,
      fill,
      stroke: stroke2,
      fillOpacity,
      strokeOpacity,
      strokeWidth
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: legendItemName ?? title ?? idName ?? idKey ?? this.id,
        seriesId: this.id,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey ?? this.id },
        symbols: [
          {
            marker: {
              shape,
              fill,
              fillOpacity,
              stroke: stroke2,
              strokeWidth,
              strokeOpacity
            }
          }
        ],
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !this.properties.isValid()) {
      return _ModuleSupport125.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      latitudeKey,
      longitudeKey,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      itemStyler,
      tooltip,
      latitudeName,
      longitudeName,
      shape,
      size,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity
    } = properties;
    const { datum, fill, idValue, latValue, lonValue, sizeValue, colorValue, labelValue, itemId } = nodeDatum;
    const title = sanitizeHtml6(properties.title ?? legendItemName) ?? "";
    const contentLines = [];
    if (idValue != null) {
      contentLines.push(sanitizeHtml6((idName != null ? `${idName}: ` : "") + idValue));
    }
    if (colorValue != null) {
      contentLines.push(sanitizeHtml6((colorName ?? colorKey) + ": " + colorValue));
    }
    if (sizeValue != null) {
      contentLines.push(sanitizeHtml6((sizeName ?? sizeKey) + ": " + sizeValue));
    }
    if (labelValue != null && (idKey == null || idKey !== labelKey)) {
      contentLines.push(sanitizeHtml6((labelName ?? labelKey) + ": " + labelValue));
    }
    if (latValue != null && lonValue != null) {
      contentLines.push(
        sanitizeHtml6(
          `${Math.abs(latValue).toFixed(4)}\xB0 ${latValue >= 0 ? "N" : "S"}, ${Math.abs(lonValue).toFixed(4)}\xB0 ${latValue >= 0 ? "W" : "E"}`
        )
      );
    }
    const content = contentLines.join("<br>");
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        highlighted: false,
        seriesId,
        datum,
        idKey,
        sizeKey,
        colorKey,
        labelKey,
        latitudeKey,
        longitudeKey,
        shape,
        size,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity
      });
    }
    const color = format?.fill ?? fill ?? properties.fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        idKey,
        latitudeKey,
        longitudeKey,
        title,
        color,
        colorKey,
        colorName,
        idName,
        itemId,
        labelKey,
        labelName,
        latitudeName,
        longitudeName,
        sizeKey,
        sizeName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getMapMarkerStyle(markerDatum, highlighted) {
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { datum, point } = markerDatum;
    const {
      idKey,
      latitudeKey,
      longitudeKey,
      labelKey,
      sizeKey,
      colorKey,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeOpacity,
      shape,
      itemStyler
    } = properties;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    if (itemStyler !== void 0) {
      return callbackCache.call(itemStyler, {
        seriesId,
        datum,
        size: point.size,
        idKey,
        latitudeKey,
        longitudeKey,
        labelKey,
        sizeKey,
        colorKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        shape,
        highlighted
      });
    }
  }
  getFormattedMarkerStyle(markerDatum) {
    const style = this.getMapMarkerStyle(markerDatum, true);
    return { size: style?.size ?? markerDatum.point.size };
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
MapMarkerSeries.className = "MapMarkerSeries";
MapMarkerSeries.type = "map-marker";
__decorateClass([
  Validate58(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapMarkerSeries.prototype, "_chartTopology", 2);

// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerModule.ts
var { DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR4, DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2, singleSeriesPaletteFactory: singleSeriesPaletteFactory2 } = _Theme21;
var MapMarkerModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-marker",
  moduleFactory: (ctx) => new MapMarkerSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      shape: "circle",
      maxSize: 30,
      fillOpacity: 0.5,
      label: {
        color: DEFAULT_LABEL_COLOUR4
      }
    }
  },
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill, stroke: stroke2 } = singleSeriesPaletteFactory2(opts);
    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2);
    const { fills } = takeColors(colorsCount);
    return {
      fill,
      stroke: stroke2,
      colorRange: userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]]
    };
  }
};

// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundModule.ts
import { _Theme as _Theme22 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeries.ts
import { _ModuleSupport as _ModuleSupport128, _Scene as _Scene60, _Util as _Util79 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport127 } from "ag-charts-community";
var { COLOR_STRING: COLOR_STRING18, LINE_DASH: LINE_DASH12, OBJECT: OBJECT26, POSITIVE_NUMBER: POSITIVE_NUMBER20, RATIO: RATIO22, Validate: Validate59, SeriesProperties: SeriesProperties6, SeriesTooltip: SeriesTooltip10 } = _ModuleSupport127;
var MapShapeBackgroundSeriesProperties = class extends SeriesProperties6 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = new SeriesTooltip10();
  }
};
__decorateClass([
  Validate59(GEOJSON_OBJECT, { optional: true })
], MapShapeBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass([
  Validate59(COLOR_STRING18)
], MapShapeBackgroundSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate59(RATIO22)
], MapShapeBackgroundSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate59(COLOR_STRING18)
], MapShapeBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate59(RATIO22)
], MapShapeBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate59(POSITIVE_NUMBER20)
], MapShapeBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate59(LINE_DASH12)
], MapShapeBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate59(POSITIVE_NUMBER20)
], MapShapeBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate59(OBJECT26)
], MapShapeBackgroundSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeries.ts
var { createDatumId: createDatumId7, Series, SeriesNodePickMode: SeriesNodePickMode9, Validate: Validate60 } = _ModuleSupport128;
var { Selection: Selection8, Group: Group10, PointerEvents: PointerEvents4 } = _Scene60;
var { Logger: Logger18 } = _Util79;
var MapShapeBackgroundSeries = class extends Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode9.EXACT_SHAPE_MATCH]
    });
    this.properties = new MapShapeBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group10({ name: "itemGroup" }));
    this.datumSelection = Selection8.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  get hasData() {
    return false;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1 /* Polygons */;
    geoGeometry.lineJoin = "round";
    geoGeometry.pointerEvents = PointerEvents4.None;
    return geoGeometry;
  }
  async processData() {
    const { topology } = this;
    this.topologyBounds = topology?.features.reduce((current, feature) => {
      const geometry = feature.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (topology == null) {
      Logger18.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
    }
  }
  async createNodeData() {
    const { id: seriesId, topology, scale } = this;
    if (topology == null)
      return;
    const nodeData = [];
    const labelData = [];
    topology.features.forEach((feature, index) => {
      const { geometry } = feature;
      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;
      if (projectedGeometry == null)
        return;
      nodeData.push({
        series: this,
        itemId: index,
        datum: feature,
        index,
        projectedGeometry
      });
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  async update() {
    const { datumSelection } = this;
    await this.updateSelections();
    this.contentGroup.visible = this.visible;
    const { nodeData = [] } = this.contextNodeData ?? {};
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection });
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId7(datum.index));
  }
  async updateDatumNodes(opts) {
    const { properties } = this;
    const { datumSelection } = opts;
    const { fill, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = properties;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.fill = fill;
      geoGeometry.fillOpacity = fillOpacity;
      geoGeometry.stroke = stroke2;
      geoGeometry.strokeWidth = strokeWidth;
      geoGeometry.strokeOpacity = strokeOpacity;
      geoGeometry.lineDash = lineDash;
      geoGeometry.lineDashOffset = lineDashOffset;
    });
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipHtml() {
    return _ModuleSupport128.EMPTY_TOOLTIP_CONTENT;
  }
  pickFocus(_opts) {
    return void 0;
  }
};
MapShapeBackgroundSeries.className = "MapShapeBackgroundSeries";
MapShapeBackgroundSeries.type = "map-shape-background";
__decorateClass([
  Validate60(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapShapeBackgroundSeries.prototype, "_chartTopology", 2);

// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundModule.ts
var { DEFAULT_BACKGROUND_COLOUR, DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS2 } = _Theme22;
var MapShapeBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape-background",
  moduleFactory: (ctx) => new MapShapeBackgroundSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      stroke: DEFAULT_BACKGROUND_COLOUR,
      strokeWidth: 1
    }
  },
  paletteFactory: ({ themeTemplateParameters }) => {
    return {
      fill: themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS2)?.[1]
    };
  }
};

// packages/ag-charts-enterprise/src/series/map-shape/mapShapeModule.ts
import { _Theme as _Theme23 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeries.ts
import { _ModuleSupport as _ModuleSupport131, _Scale as _Scale17, _Scene as _Scene62, _Util as _Util81 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/map-util/polygonLabelUtil.ts
function preferredLabelCenter(polygons, { aspectRatio, precision }) {
  const result = polygonPointSearch(polygons, precision, (p, cx, cy, stride) => {
    const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(p, cx, cy, aspectRatio);
    const maxWidth2 = width + 2 * stride * aspectRatio;
    const distance2 = width * Math.SQRT2;
    const maxDistance = maxWidth2 * Math.SQRT2;
    return { distance: distance2, maxDistance };
  });
  if (result == null)
    return;
  const { x, y, distance } = result;
  const maxWidth = distance / Math.SQRT2;
  return { x, y, maxWidth };
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(a, b, cx, cy, aspectRatio) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const positiveM = 1 / aspectRatio;
  const abx = bx - ax;
  const aby = by - ay;
  const [topPointX, topPointY] = ay <= by ? a : b;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [bottomPointX, bottomPointY] = ay <= by ? b : a;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  let maxWidth = Infinity;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const x = (abm * ax - ay - m * cx + cy) / (abm - m);
      if (x >= leftPointX && x <= rightPointX) {
        const width = Math.abs(cx - x) * 2;
        maxWidth = Math.min(maxWidth, width);
      }
    }
  } else {
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const y = m * (ax - cx) + cy;
      if (y >= topPointY && y <= bottomPointY) {
        const height = Math.abs(cy - y) * 2;
        const width = height * aspectRatio;
        maxWidth = Math.min(maxWidth, width);
      }
    }
  }
  const positiveMRecip = aspectRatio;
  const centerToTopMRecip = Math.abs((topPointX - cx) / (topPointY - cy));
  const centerToBottomMRecip = Math.abs((bottomPointX - cx) / (bottomPointY - cy));
  if (bottomPointY < cy && centerToBottomMRecip < positiveMRecip) {
    const height = Math.abs(cy - bottomPointY) * 2;
    const width = height * aspectRatio;
    maxWidth = Math.min(maxWidth, width);
  } else if (topPointY > cy && centerToTopMRecip < positiveMRecip) {
    const height = Math.abs(cy - topPointY) * 2;
    const width = height * aspectRatio;
    maxWidth = Math.min(maxWidth, width);
  }
  const centerToLeftM = Math.abs((leftPointY - cy) / (leftPointX - cx));
  const centerToRightM = Math.abs((rightPointY - cy) / (rightPointX - cx));
  if (rightPointX < cx && centerToRightM < positiveM) {
    const width = Math.abs(cx - rightPointX) * 2;
    maxWidth = Math.min(maxWidth, width);
  } else if (leftPointX > cx && centerToLeftM < positiveM) {
    const width = Math.abs(cx - leftPointX) * 2;
    maxWidth = Math.min(maxWidth, width);
  }
  return maxWidth;
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(polygons, cx, cy, aspectRatio) {
  let inside = false;
  let minWidth = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > cy !== y0 > cy && cx < (x0 - x1) * (cy - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(p0, p1, cx, cy, aspectRatio);
      minWidth = Math.min(minWidth, width);
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? 1 : -1) * minWidth;
}
function applyX(into, cx, x) {
  if (x >= cx) {
    into.maxX = Math.min(into.maxX, x - cx);
  }
  if (x <= cx) {
    into.minX = Math.max(into.minX, x - cx);
  }
}
function xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(into, a, b, cx, cy, height) {
  const ry0 = cy - height / 2;
  const ry1 = cy + height / 2;
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const y = i === 0 ? ry0 : ry1;
      const x = (y - ay) / abm + ax;
      if (x >= leftPointX && x <= rightPointX) {
        applyX(into, cx, x);
      }
    }
  } else if (Math.max(ry0, Math.min(ay, by)) <= Math.min(ry1, Math.max(ay, by))) {
    applyX(into, cx, ax);
  }
  if (rightPointX < cx && rightPointY >= ry0 && rightPointY <= ry1) {
    applyX(into, cx, rightPointX);
  } else if (leftPointX > cx && leftPointY >= ry0 && leftPointY <= ry1) {
    applyX(into, cx, leftPointX);
  }
  return into;
}
function maxWidthInPolygonForRectOfHeight(polygons, cx, cy, height) {
  const result = {
    minX: -Infinity,
    maxX: Infinity
  };
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    for (const p1 of polygon) {
      xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(result, p0, p1, cx, cy, height);
      p0 = p1;
    }
  }
  const { minX, maxX } = result;
  if (Number.isFinite(minX) && Number.isFinite(maxX)) {
    return { x: cx + (minX + maxX) / 2, width: maxX - minX };
  } else {
    return { x: cx, width: 0 };
  }
}

// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport130 } from "ag-charts-community";
var {
  AND: AND10,
  ARRAY: ARRAY9,
  COLOR_STRING: COLOR_STRING19,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY6,
  FUNCTION: FUNCTION12,
  LINE_DASH: LINE_DASH13,
  OBJECT: OBJECT27,
  POSITIVE_NUMBER: POSITIVE_NUMBER21,
  RATIO: RATIO23,
  STRING: STRING28,
  Validate: Validate61,
  SeriesProperties: SeriesProperties7,
  SeriesTooltip: SeriesTooltip11
} = _ModuleSupport130;
var MapShapeSeriesProperties = class extends SeriesProperties7 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.idName = void 0;
    this.topologyIdKey = "name";
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.padding = 0;
    this.label = new AutoSizedSecondaryLabel();
    this.tooltip = new SeriesTooltip11();
  }
};
__decorateClass([
  Validate61(GEOJSON_OBJECT, { optional: true })
], MapShapeSeriesProperties.prototype, "topology", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Validate61(STRING28)
], MapShapeSeriesProperties.prototype, "idKey", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "idName", 2);
__decorateClass([
  Validate61(STRING28)
], MapShapeSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate61(STRING28, { optional: true })
], MapShapeSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate61(AND10(COLOR_STRING_ARRAY6, ARRAY9.restrict({ minLength: 1 })), { optional: true })
], MapShapeSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate61(COLOR_STRING19)
], MapShapeSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate61(RATIO23)
], MapShapeSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate61(COLOR_STRING19)
], MapShapeSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate61(RATIO23)
], MapShapeSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate61(POSITIVE_NUMBER21)
], MapShapeSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate61(LINE_DASH13)
], MapShapeSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate61(POSITIVE_NUMBER21)
], MapShapeSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate61(POSITIVE_NUMBER21)
], MapShapeSeriesProperties.prototype, "padding", 2);
__decorateClass([
  Validate61(FUNCTION12, { optional: true })
], MapShapeSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate61(OBJECT27)
], MapShapeSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate61(OBJECT27)
], MapShapeSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeries.ts
var {
  getMissCount: getMissCount4,
  createDatumId: createDatumId8,
  DataModelSeries: DataModelSeries5,
  SeriesNodePickMode: SeriesNodePickMode10,
  valueProperty: valueProperty10,
  Validate: Validate62,
  CachedTextMeasurerPool: CachedTextMeasurerPool7,
  TextUtils: TextUtils4
} = _ModuleSupport131;
var { ColorScale: ColorScale6 } = _Scale17;
var { Group: Group11, Selection: Selection9, Text: Text6, PointerEvents: PointerEvents5 } = _Scene62;
var { sanitizeHtml: sanitizeHtml7, Logger: Logger19 } = _Util81;
var fixedScale = _ModuleSupport131.MercatorScale.fixedScale();
var MapShapeSeries = class extends DataModelSeries5 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode10.EXACT_SHAPE_MATCH, SeriesNodePickMode10.NEAREST_NODE]
    });
    this.properties = new MapShapeSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale6();
    this.itemGroup = this.contentGroup.appendChild(new Group11({ name: "itemGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group11({ name: "itemLabelGroup" }));
    this.datumSelection = Selection9.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection9.select(
      this.itemLabelGroup,
      Text6
    );
    this.highlightDatumSelection = Selection9.select(
      this.highlightNode,
      () => this.nodeFactory()
    );
    this.previousLabelLayouts = void 0;
    this._previousDatumMidPoint = void 0;
    this.itemLabelGroup.pointerEvents = PointerEvents5.None;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1 /* Polygons */;
    geoGeometry.lineJoin = "round";
    return geoGeometry;
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    const { data, topology, colorScale } = this;
    const { topologyIdKey, idKey, colorKey, labelKey, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null || !containsType(feature.geometry, 1 /* Polygon */))
        return;
      featureById.set(property, feature);
    });
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        valueProperty10(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
        valueProperty10(idKey, mercatorScaleType, {
          id: "featureValue",
          includeProperty: false,
          processor: () => (datum) => featureById.get(datum)
        }),
        ...labelKey ? [valueProperty10(labelKey, "band", { id: "labelValue" })] : [],
        ...colorKey ? [valueProperty10(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
    this.topologyBounds = processedData.data.reduce(
      (current, { values }) => {
        const feature = values[featureIdx];
        const geometry = feature?.geometry;
        if (geometry == null)
          return current;
        return geometryBbox(geometry, current);
      },
      void 0
    );
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    if (topology == null) {
      Logger19.warnOnce(`no topology was provided for [MapShapeSeries]; nothing will be rendered.`);
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount4(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelLayout(datum, labelValue, font2, geometry, previousLabelLayout) {
    if (labelValue == null || geometry == null)
      return;
    const { idKey, idName, colorKey, colorName, labelKey, labelName, padding, label } = this.properties;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const baseSize = CachedTextMeasurerPool7.measureText(String(labelText), { font: font2 });
    const numLines = labelText.split("\n").length;
    const aspectRatio = (baseSize.width + 2 * padding) / (numLines * TextUtils4.getLineHeight(label.fontSize) + 2 * padding);
    if (previousLabelLayout?.geometry === geometry && previousLabelLayout?.labelText === labelText && previousLabelLayout?.aspectRatio === aspectRatio) {
      return previousLabelLayout;
    }
    const fixedGeometry = projectGeometry(geometry, fixedScale);
    const fixedPolygon = largestPolygon(fixedGeometry);
    if (fixedPolygon == null)
      return;
    const labelPlacement = preferredLabelCenter(fixedPolygon, {
      aspectRatio,
      precision: 1e-3
    });
    if (labelPlacement == null)
      return;
    const { x, y, maxWidth } = labelPlacement;
    return { geometry, labelText, aspectRatio, x, y, maxWidth, fixedPolygon };
  }
  getLabelDatum(labelLayout, scaling) {
    const { scale } = this;
    if (scale == null)
      return;
    const { padding, label } = this.properties;
    const { labelText, aspectRatio, x: untruncatedX, y, maxWidth, fixedPolygon } = labelLayout;
    const maxSizeWithoutTruncation = {
      width: Math.ceil(maxWidth * scaling),
      height: Math.ceil(maxWidth * scaling / aspectRatio),
      meta: untruncatedX
    };
    const labelFormatting = formatSingleLabel(labelText, label, { padding }, (height, allowTruncation) => {
      if (!allowTruncation)
        return maxSizeWithoutTruncation;
      const result = maxWidthInPolygonForRectOfHeight(fixedPolygon, untruncatedX, y, height / scaling);
      return {
        width: result.width * scaling,
        height,
        meta: result.x
      };
    });
    if (labelFormatting == null)
      return;
    const [{ text: text2, fontSize, lineHeight, width }, formattingX] = labelFormatting;
    if (text2 === TextUtils4.EllipsisChar)
      return;
    const x = width < maxSizeWithoutTruncation.width ? untruncatedX : formattingX;
    const position = this.scale.convert(fixedScale.invert([x, y]));
    return {
      x: position[0],
      y: position[1],
      text: text2,
      fontSize,
      lineHeight
    };
  }
  async createNodeData() {
    const { id: seriesId, dataModel, processedData, colorScale, properties, scale, previousLabelLayouts } = this;
    const { idKey, colorKey, labelKey, label, fill: fillProperty } = properties;
    if (dataModel == null || processedData == null)
      return;
    const scaling = scale != null ? (scale.range[1][0] - scale.range[0][0]) / scale.bounds.width : NaN;
    const colorScaleValid = this.isColorScaleValid();
    const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);
    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
    const font2 = label.getFont();
    const labelLayouts = /* @__PURE__ */ new Map();
    this.previousLabelLayouts = labelLayouts;
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    processedData.data.forEach(({ datum, values }) => {
      const idValue = values[idIdx];
      const colorValue = colorIdx != null ? values[colorIdx] : void 0;
      const labelValue = labelIdx != null ? values[labelIdx] : void 0;
      const geometry = values[featureIdx]?.geometry;
      if (geometry == null) {
        missingGeometries.push(idValue);
      }
      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
      const labelLayout = this.getLabelLayout(
        datum,
        labelValue,
        font2,
        geometry,
        previousLabelLayouts?.get(idValue)
      );
      if (labelLayout != null) {
        labelLayouts.set(idValue, labelLayout);
      }
      const labelDatum = labelLayout != null && scale != null ? this.getLabelDatum(labelLayout, scaling) : void 0;
      if (labelDatum != null) {
        labelData.push(labelDatum);
      }
      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;
      nodeData.push({
        series: this,
        itemId: idKey,
        datum,
        idValue,
        colorValue,
        labelValue,
        fill: color ?? fillProperty,
        projectedGeometry
      });
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      Logger19.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  async update() {
    const { datumSelection, labelSelection, highlightDatumSelection } = this;
    await this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection, isHighlight: false });
    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });
    await this.updateLabelNodes({ labelSelection });
    this.highlightDatumSelection = await this.updateDatumSelection({
      nodeData: highlightedDatum != null ? [highlightedDatum] : [],
      datumSelection: highlightDatumSelection
    });
    await this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId8(datum.idValue));
  }
  async updateDatumNodes(opts) {
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { datumSelection, isHighlight } = opts;
    const { idKey, colorKey, labelKey, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset, itemStyler } = properties;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          idKey,
          colorKey,
          labelKey,
          fill: datum.fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: isHighlight
        });
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.fill = highlightStyle?.fill ?? format?.fill ?? datum.fill;
      geoGeometry.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      geoGeometry.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      geoGeometry.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;
      geoGeometry.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      geoGeometry.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      geoGeometry.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
    });
  }
  async updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { color: fill, fontStyle, fontWeight, fontFamily } = this.properties.label;
    labelSelection.each((label, { x, y, text: text2, fontSize, lineHeight }) => {
      label.visible = true;
      label.x = x;
      label.y = y;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.lineHeight = lineHeight;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistance = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distance = node.distanceToPoint(x, y);
      if (distance < minDistance) {
        minDistance = distance;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;
  }
  datumMidPoint(datum) {
    const { _previousDatumMidPoint } = this;
    if (_previousDatumMidPoint?.datum === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const polygon = projectedGeometry != null ? largestPolygon(projectedGeometry) : void 0;
    const center = polygon != null ? polygonMarkerCenter(polygon, 2) : void 0;
    const point = center != null ? { x: center[0], y: center[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idKey,
      idName,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      colorKey,
      colorName,
      colorRange,
      visible
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: legendItemName ?? title ?? idName ?? idKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey },
        symbols: [
          {
            marker: {
              fill,
              fillOpacity,
              stroke: stroke2,
              strokeWidth,
              strokeOpacity
            }
          }
        ],
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !properties.isValid()) {
      return _ModuleSupport131.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      fillOpacity,
      lineDash,
      lineDashOffset,
      itemStyler,
      tooltip
    } = properties;
    const { datum, fill, idValue, colorValue, labelValue, itemId } = nodeDatum;
    const title = sanitizeHtml7(properties.title ?? legendItemName) ?? "";
    const contentLines = [];
    contentLines.push(sanitizeHtml7((idName != null ? `${idName}: ` : "") + idValue));
    if (colorValue != null) {
      contentLines.push(sanitizeHtml7((colorName ?? colorKey) + ": " + colorValue));
    }
    if (labelValue != null && labelKey !== idKey) {
      contentLines.push(sanitizeHtml7((labelName ?? labelKey) + ": " + labelValue));
    }
    const content = contentLines.join("<br>");
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        seriesId,
        datum,
        idKey,
        colorKey,
        labelKey,
        fill,
        stroke: stroke2,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        highlighted: false,
        fillOpacity,
        strokeOpacity,
        lineDash,
        lineDashOffset
      });
    }
    const color = format?.fill ?? fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        idKey,
        title,
        color,
        colorKey,
        colorName,
        idName,
        itemId,
        labelKey,
        labelName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  computeFocusBounds(opts) {
    return findFocusedGeoGeometry(this, opts);
  }
};
MapShapeSeries.className = "MapShapeSeries";
MapShapeSeries.type = "map-shape";
__decorateClass([
  Validate62(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapShapeSeries.prototype, "_chartTopology", 2);

// packages/ag-charts-enterprise/src/series/map-shape/mapShapeModule.ts
var {
  DEFAULT_INVERTED_LABEL_COLOUR,
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3,
  DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR2,
  singleSeriesPaletteFactory: singleSeriesPaletteFactory3
} = _Theme23;
var MapShapeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape",
  moduleFactory: (ctx) => new MapShapeSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      fillOpacity: 1,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0,
      padding: 2,
      label: {
        color: DEFAULT_INVERTED_LABEL_COLOUR,
        fontWeight: "bold",
        overflowStrategy: "hide"
      }
    }
  },
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill } = singleSeriesPaletteFactory3(opts);
    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3);
    const { fills } = takeColors(colorsCount);
    return {
      fill,
      stroke: themeTemplateParameters.get(DEFAULT_BACKGROUND_COLOUR2),
      colorRange: userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]]
    };
  }
};

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleModule.ts
import { _Theme as _Theme25 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleSeries.ts
import { _Scene as _Scene67 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesBase.ts
import { _ModuleSupport as _ModuleSupport133, _Scale as _Scale18, _Scene as _Scene63, _Util as _Util82 } from "ag-charts-community";
var {
  isDefined: isDefined3,
  ChartAxisDirection: ChartAxisDirection16,
  PolarAxis,
  diff: diff4,
  fixNumericExtent: fixNumericExtent4,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty2,
  keyProperty: keyProperty5,
  mergeDefaults: mergeDefaults6,
  normaliseGroupTo,
  resetLabelFn,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation2,
  seriesLabelFadeOutAnimation,
  valueProperty: valueProperty11,
  animationValidation: animationValidation4,
  isFiniteNumber: isFiniteNumber2,
  SeriesNodePickMode: SeriesNodePickMode11
} = _ModuleSupport133;
var { BandScale: BandScale3 } = _Scale18;
var { motion: motion3 } = _Scene63;
var { isNumber, normalizeAngle360: normalizeAngle3606, sanitizeHtml: sanitizeHtml8 } = _Util82;
var RadialColumnSeriesNodeEvent = class extends _ModuleSupport133.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialColumnSeriesBase = class extends _ModuleSupport133.PolarSeries {
  constructor(moduleCtx, {
    animationResetFns
  }) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      pickModes: [SeriesNodePickMode11.NEAREST_NODE, SeriesNodePickMode11.EXACT_SHAPE_MATCH],
      animationResetFns: {
        ...animationResetFns,
        label: resetLabelFn
      }
    });
    this.NodeEvent = RadialColumnSeriesNodeEvent;
    this.groupScale = new BandScale3();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager?.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection16.X) {
      return dataModel.getDomain(this, "angleValue", "key", processedData);
    } else {
      const yExtent = dataModel.getDomain(this, "radiusValue-end", "value", processedData);
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent4(fixedYExtent);
    }
  }
  async processData(dataController) {
    const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    if (!this.properties.isValid() || !(visible || animationEnabled))
      return;
    const stackGroupId = this.getStackId();
    const stackGroupTrailingId = `${stackGroupId}-trailing`;
    const extraProps = [];
    if (isDefined3(normalizedTo)) {
      extraProps.push(normaliseGroupTo([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range"));
    }
    if (animationEnabled && this.processedData) {
      extraProps.push(diff4(this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation4());
    }
    const visibleProps = visible || !animationEnabled ? {} : { forceValue: 0 };
    const radiusScaleType = this.axes[ChartAxisDirection16.Y]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection16.X]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty5(angleKey, angleScaleType, { id: "angleValue" }),
        valueProperty11(radiusKey, radiusScaleType, {
          id: "radiusValue-raw",
          invalidValue: null,
          ...visibleProps
        }),
        ...groupAccumulativeValueProperty2(
          radiusKey,
          "normal",
          "current",
          {
            id: `radiusValue-end`,
            rangeId: `radiusValue-range`,
            invalidValue: null,
            groupId: stackGroupId,
            separateNegative: true,
            ...visibleProps
          },
          radiusScaleType
        ),
        ...groupAccumulativeValueProperty2(
          radiusKey,
          "trailing",
          "current",
          {
            id: `radiusValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId,
            separateNegative: true,
            ...visibleProps
          },
          radiusScaleType
        ),
        ...extraProps
      ]
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  isRadiusAxisReversed() {
    return this.axes[ChartAxisDirection16.Y]?.isReversed();
  }
  async maybeRefreshNodeData() {
    const circleChanged = this.didCircleChange();
    if (!circleChanged && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = await this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection16.Y];
    return radiusAxis instanceof PolarAxis ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  async createNodeData() {
    const { processedData, dataModel, groupScale } = this;
    if (!processedData || !dataModel || !this.properties.isValid()) {
      return;
    }
    const angleAxis = this.axes[ChartAxisDirection16.X];
    const radiusAxis = this.axes[ChartAxisDirection16.Y];
    const angleScale = angleAxis?.scale;
    const radiusScale = radiusAxis?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const radiusStartIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-start`);
    const radiusEndIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-end`);
    const radiusRangeIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-range`);
    const radiusRawIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-raw`);
    let groupPaddingInner = 0;
    let groupPaddingOuter = 0;
    if (angleAxis instanceof AngleCategoryAxis) {
      groupPaddingInner = angleAxis.groupPaddingInner;
      groupPaddingOuter = angleAxis.paddingInner;
    }
    const groupAngleStep = angleScale.bandwidth ?? 0;
    const paddedGroupAngleStep = groupAngleStep * (1 - groupPaddingOuter);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
    groupScale.range = [-paddedGroupAngleStep / 2, paddedGroupAngleStep / 2];
    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
    const radiusAxisReversed = this.isRadiusAxisReversed();
    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
    const axisTotalRadius = axisOuterRadius + axisInnerRadius;
    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
    const getLabelNodeDatum = (datum, radiusDatum, x, y) => {
      const labelText = this.getLabelText(
        label,
        { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
        (value) => isFiniteNumber2(value) ? value.toFixed(2) : String(value)
      );
      if (labelText) {
        return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
      }
    };
    const nodeData = [];
    const context = { itemId: radiusKey, nodeData, labelData: nodeData };
    if (!this.visible)
      return context;
    processedData.data.forEach((group, index, data) => {
      const { datum, keys, values, aggValues } = group;
      const angleDatum = keys[0];
      const radiusDatum = values[radiusRawIndex];
      const isPositive = radiusDatum >= 0 && !Object.is(radiusDatum, -0);
      const innerRadiusDatum = values[radiusStartIndex];
      const outerRadiusDatum = values[radiusEndIndex];
      const radiusRange = aggValues?.[radiusRangeIndex][isPositive ? 1 : 0] ?? 0;
      const negative = isPositive === radiusAxisReversed;
      if (innerRadiusDatum === void 0 || outerRadiusDatum === void 0) {
        return;
      }
      let startAngle;
      let endAngle;
      if (data.length === 1) {
        startAngle = -0.5 * Math.PI;
        endAngle = 1.5 * Math.PI;
      } else {
        let groupAngle = angleScale.convert(angleDatum);
        if (visibleGroupCount === 1) {
          groupAngle -= groupScale.bandwidth / 2;
        }
        startAngle = normalizeAngle3606(groupAngle + groupScale.convert(String(groupIndex)));
        endAngle = normalizeAngle3606(startAngle + groupScale.bandwidth);
      }
      const angle = startAngle + groupScale.bandwidth / 2;
      const innerRadius = axisTotalRadius - radiusScale.convert(innerRadiusDatum);
      const outerRadius = axisTotalRadius - radiusScale.convert(outerRadiusDatum);
      const midRadius = (innerRadius + outerRadius) / 2;
      const stackInnerRadius = axisTotalRadius - radiusScale.convert(0);
      const stackOuterRadius = axisTotalRadius - radiusScale.convert(radiusRange);
      const x = Math.cos(angle) * midRadius;
      const y = Math.sin(angle) * midRadius;
      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, radiusDatum, x, y) : void 0;
      const columnWidth = this.getColumnWidth(startAngle, endAngle);
      nodeData.push({
        series: this,
        datum,
        point: { x, y, size: 0 },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        negative,
        innerRadius,
        outerRadius,
        stackInnerRadius,
        stackOuterRadius,
        startAngle,
        endAngle,
        axisInnerRadius,
        axisOuterRadius,
        columnWidth,
        index
      });
    });
    return { itemId: radiusKey, nodeData, labelData: nodeData };
  }
  getColumnWidth(_startAngle, _endAngle) {
    return NaN;
  }
  async update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    await this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updateSectorSelection(this.itemSelection, false);
    this.updateSectorSelection(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updateSectorSelection(selection, highlighted) {
    let selectionData = [];
    if (highlighted) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      if (activeHighlight?.datum && activeHighlight.series === this) {
        selectionData = [activeHighlight];
      }
    } else {
      selectionData = this.nodeData;
    }
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      cornerRadius,
      angleKey,
      radiusKey
    } = mergeDefaults6(highlighted ? this.properties.highlightStyle.item : null, this.properties);
    const idFn = (datum) => datum.angleValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      const format = this.properties.itemStyler ? this.ctx.callbackCache.call(this.properties.itemStyler, {
        datum: datum.datum,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius,
        highlighted,
        angleKey,
        radiusKey,
        seriesId: this.id
      }) : void 0;
      this.updateItemPath(node, datum, highlighted, format);
      node.fill = format?.fill ?? fill;
      node.fillOpacity = format?.fillOpacity ?? fillOpacity;
      node.stroke = format?.stroke ?? stroke2;
      node.strokeWidth = format?.strokeWidth ?? strokeWidth;
      node.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;
      node.lineDash = format?.lineDash ?? lineDash;
      node.lineDashOffset = format?.lineDashOffset ?? lineDashOffset;
      node.cornerRadius = format?.cornerRadius ?? cornerRadius;
      node.lineJoin = "round";
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getColumnTransitionFunctions();
    motion3.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation2(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getColumnTransitionFunctions();
    motion3.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, axes, dataModel } = this;
    const {
      angleKey,
      radiusKey,
      angleName,
      radiusName,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      itemStyler,
      tooltip
    } = this.properties;
    const { angleValue, radiusValue, datum, itemId } = nodeDatum;
    const xAxis = axes[ChartAxisDirection16.X];
    const yAxis = axes[ChartAxisDirection16.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber(radiusValue)) || !dataModel) {
      return _ModuleSupport133.EMPTY_TOOLTIP_CONTENT;
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml8(radiusName);
    const content = sanitizeHtml8(`${angleString}: ${radiusString}`);
    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {
      highlighted: false,
      seriesId,
      datum,
      angleKey,
      radiusKey,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius
    })) ?? { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      {
        seriesId,
        datum,
        color,
        title,
        angleKey,
        radiusKey,
        angleName,
        radiusName,
        angleValue,
        itemId,
        radiusValue
      }
    );
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());
  }
  getLegendData(legendType) {
    if (!this.data?.length || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName ?? radiusKey
        },
        symbols: [
          {
            marker: {
              fill: fill ?? "rgba(0, 0, 0, 0)",
              stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity ?? 1,
              strokeOpacity: strokeOpacity ?? 1,
              strokeWidth
            }
          }
        ]
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
};

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesBaseProperties.ts
import { _ModuleSupport as _ModuleSupport134, _Scene as _Scene64 } from "ag-charts-community";
var { Label: Label7 } = _Scene64;
var {
  SeriesProperties: SeriesProperties8,
  SeriesTooltip: SeriesTooltip12,
  Validate: Validate63,
  COLOR_STRING: COLOR_STRING20,
  DEGREE: DEGREE3,
  FUNCTION: FUNCTION13,
  LINE_DASH: LINE_DASH14,
  NUMBER: NUMBER15,
  OBJECT: OBJECT28,
  POSITIVE_NUMBER: POSITIVE_NUMBER22,
  RATIO: RATIO24,
  STRING: STRING29
} = _ModuleSupport134;
var RadialColumnSeriesBaseProperties = class extends SeriesProperties8 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.label = new Label7();
    this.tooltip = new SeriesTooltip12();
  }
};
__decorateClass([
  Validate63(STRING29)
], RadialColumnSeriesBaseProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate63(STRING29, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "angleName", 2);
__decorateClass([
  Validate63(STRING29)
], RadialColumnSeriesBaseProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate63(STRING29, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate63(COLOR_STRING20)
], RadialColumnSeriesBaseProperties.prototype, "fill", 2);
__decorateClass([
  Validate63(RATIO24)
], RadialColumnSeriesBaseProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate63(COLOR_STRING20)
], RadialColumnSeriesBaseProperties.prototype, "stroke", 2);
__decorateClass([
  Validate63(POSITIVE_NUMBER22)
], RadialColumnSeriesBaseProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate63(RATIO24)
], RadialColumnSeriesBaseProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate63(LINE_DASH14)
], RadialColumnSeriesBaseProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate63(POSITIVE_NUMBER22)
], RadialColumnSeriesBaseProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate63(POSITIVE_NUMBER22)
], RadialColumnSeriesBaseProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate63(FUNCTION13, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate63(DEGREE3)
], RadialColumnSeriesBaseProperties.prototype, "rotation", 2);
__decorateClass([
  Validate63(STRING29, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "stackGroup", 2);
__decorateClass([
  Validate63(NUMBER15, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate63(OBJECT28)
], RadialColumnSeriesBaseProperties.prototype, "label", 2);
__decorateClass([
  Validate63(OBJECT28)
], RadialColumnSeriesBaseProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleUtil.ts
import { _Scene as _Scene66 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnUtil.ts
import { _Scene as _Scene65 } from "ag-charts-community";
var { motion: motion4 } = _Scene65;
function createAngleMotionCalculator() {
  const angles = {
    startAngle: /* @__PURE__ */ new Map(),
    endAngle: /* @__PURE__ */ new Map()
  };
  const angleKeys = ["startAngle", "endAngle"];
  const calculate = (node, datum, status) => {
    angleKeys.forEach((key) => {
      const map = angles[key];
      let from2 = (status === "removed" || status === "updated" ? node : datum)[key];
      let to2 = (status === "removed" ? node : datum)[key];
      if (isNaN(to2)) {
        to2 = node.previousDatum?.[key] ?? NaN;
      }
      const diff8 = from2 - to2;
      if (Math.abs(diff8) > Math.PI) {
        from2 -= Math.sign(diff8) * 2 * Math.PI;
      }
      map.set(datum, { from: from2, to: to2 });
    });
  };
  const getAngles = (datum, fromToKey) => {
    return {
      startAngle: angles.startAngle.get(datum)[fromToKey],
      endAngle: angles.endAngle.get(datum)[fromToKey]
    };
  };
  const from = (datum) => getAngles(datum, "from");
  const to = (datum) => getAngles(datum, "to");
  return { calculate, from, to };
}
function fixRadialColumnAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.startAngle) || isNaN(node.previousDatum.endAngle)) {
      return "added";
    }
    if (isNaN(datum.startAngle) || isNaN(datum.endAngle)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialColumnAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (node, datum, status) => {
    status = fixRadialColumnAnimationStatus(node, datum, status);
    angles.calculate(node, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed" || status === "updated") {
      innerRadius = node.innerRadius;
      outerRadius = node.outerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      columnWidth = datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    const phase = motion4.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return {
      innerRadius,
      outerRadius,
      columnWidth,
      axisInnerRadius,
      axisOuterRadius,
      startAngle,
      endAngle,
      phase
    };
  };
  const toFn = (node, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed") {
      innerRadius = node.innerRadius;
      outerRadius = node.innerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;
      columnWidth = isNaN(datum.columnWidth) ? node.columnWidth : datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
  };
  return { toFn, fromFn };
}
function resetRadialColumnSelectionFn(_node, {
  innerRadius,
  outerRadius,
  columnWidth,
  axisInnerRadius,
  axisOuterRadius,
  startAngle,
  endAngle
}) {
  return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
}

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleUtil.ts
var { SectorBox, motion: motion5 } = _Scene66;
function getRadii(datum) {
  const { negative, innerRadius, outerRadius, stackInnerRadius, stackOuterRadius } = datum;
  return {
    innerRadius: negative ? stackOuterRadius : stackInnerRadius,
    outerRadius: negative ? stackInnerRadius : stackOuterRadius,
    clipInnerRadius: negative ? outerRadius : innerRadius,
    clipOuterRadius: negative ? innerRadius : outerRadius
  };
}
function prepareNightingaleAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (sect, datum, status) => {
    status = fixRadialColumnAnimationStatus(sect, datum, status);
    angles.calculate(sect, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
    }
    clipSector ?? (clipSector = new SectorBox(startAngle, endAngle, innerRadius, outerRadius));
    const phase = motion5.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector, phase };
  };
  const toFn = (_sect, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      clipSector = new SectorBox(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      let clipInnerRadius, clipOuterRadius;
      ({ innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum));
      if (isNaN(innerRadius))
        innerRadius = axisZeroRadius;
      if (isNaN(outerRadius))
        outerRadius = axisZeroRadius;
      if (isNaN(clipInnerRadius))
        clipInnerRadius = axisZeroRadius;
      if (isNaN(clipOuterRadius))
        clipOuterRadius = axisZeroRadius;
      clipSector = new SectorBox(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
  };
  return { toFn, fromFn };
}
function resetNightingaleSelectionFn(_sect, datum) {
  const { startAngle, endAngle } = datum;
  const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
  const clipSector = new SectorBox(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
  return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
}

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleSeries.ts
var { Sector: Sector4, SectorBox: SectorBox2 } = _Scene67;
var NightingaleSeries = class extends RadialColumnSeriesBase {
  // TODO: Enable once the options contract has been revisited
  // @Validate(POSITIVE_NUMBER)
  // sectorSpacing = 1;
  constructor(moduleCtx) {
    super(moduleCtx, { animationResetFns: { item: resetNightingaleSelectionFn } });
    this.properties = new RadialColumnSeriesBaseProperties();
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `nightingale-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new Sector4();
  }
  updateItemPath(node, datum, highlight, _format) {
    const { negative } = datum;
    node.centerX = 0;
    node.centerY = 0;
    node.startOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.endOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.startInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    node.endInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    if (highlight) {
      const { startAngle, endAngle } = datum;
      const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
      node.innerRadius = innerRadius;
      node.outerRadius = outerRadius;
      node.startAngle = startAngle;
      node.endAngle = endAngle;
      node.clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareNightingaleAnimationFunctions(axisZeroRadius);
  }
};
NightingaleSeries.className = "NightingaleSeries";
NightingaleSeries.type = "nightingale";

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleThemes.ts
import { _Theme as _Theme24 } from "ag-charts-community";
var NIGHTINGALE_SERIES_THEME = {
  series: {
    strokeWidth: 1,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: _Theme24.DEFAULT_FONT_FAMILY,
      color: _Theme24.DEFAULT_LABEL_COLOUR
    }
  },
  axes: {
    [_Theme24.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: _Theme24.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [_Theme24.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: _Theme24.POLAR_AXIS_SHAPE.CIRCLE
    }
  }
};

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleModule.ts
var NightingaleModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "nightingale",
  moduleFactory: (ctx) => new NightingaleSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme25.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: _Theme25.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: NIGHTINGALE_SERIES_THEME,
  paletteFactory({ takeColors, userPalette }) {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    return {
      fill,
      stroke: userPalette !== "inbuilt" ? stroke2 : _Theme25.DEFAULT_POLAR_SERIES_STROKE
    };
  },
  stackable: true,
  groupable: true,
  stackedByDefault: true
};

// packages/ag-charts-enterprise/src/series/ohlc/ohlcModule.ts
import { _Theme as _Theme26 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeries.ts
import { _ModuleSupport as _ModuleSupport138 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/ohlc/ohlcGroup.ts
import { _Scene as _Scene68 } from "ag-charts-community";
var OhlcGroup = class extends CandlestickBaseGroup {
  constructor() {
    super();
    this.append([
      new _Scene68.Line({ tag: 0 /* Body */ }),
      new _Scene68.Line({ tag: 1 /* Open */ }),
      new _Scene68.Line({ tag: 2 /* Close */ })
    ]);
  }
  updateCoordinates() {
    const {
      x,
      y,
      yBottom,
      yHigh,
      yLow,
      width,
      height,
      datum: { itemId }
    } = this;
    const selection = _Scene68.Selection.select(this, _Scene68.Rect);
    const [body] = selection.selectByTag(0 /* Body */);
    const [open] = selection.selectByTag(1 /* Open */);
    const [close] = selection.selectByTag(2 /* Close */);
    if (width === 0 || height === 0) {
      body.visible = false;
      open.visible = false;
      close.visible = false;
      return;
    }
    body.visible = true;
    open.visible = true;
    close.visible = true;
    const halfWidth = width / 2;
    body.setProperties({
      x1: Math.floor(x + halfWidth),
      x2: Math.floor(x + halfWidth),
      y1: yHigh,
      y2: yLow
    });
    const isRising = itemId === "up";
    const openY = isRising ? yBottom : y;
    const closeY = isRising ? y : yBottom;
    open.setProperties({
      x1: Math.floor(x),
      x2: Math.floor(x + halfWidth),
      y: Math.round(openY)
    });
    close.setProperties({
      x1: Math.floor(x + halfWidth),
      x2: Math.floor(x + width),
      y: Math.round(closeY)
    });
  }
  updateDatumStyles(_datum, activeStyles) {
    const selection = _Scene68.Selection.select(this, _Scene68.Rect);
    const [body] = selection.selectByTag(0 /* Body */);
    const [open] = selection.selectByTag(1 /* Open */);
    const [close] = selection.selectByTag(2 /* Close */);
    body.setProperties(activeStyles);
    open.setProperties(activeStyles);
    close.setProperties(activeStyles);
  }
};

// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport137 } from "ag-charts-community";
var { BaseProperties: BaseProperties24, Validate: Validate64, COLOR_STRING: COLOR_STRING21, FUNCTION: FUNCTION14, LINE_DASH: LINE_DASH15, OBJECT: OBJECT29, POSITIVE_NUMBER: POSITIVE_NUMBER23, RATIO: RATIO25 } = _ModuleSupport137;
var OhlcSeriesItem = class extends BaseProperties24 {
  constructor() {
    super(...arguments);
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate64(COLOR_STRING21)
], OhlcSeriesItem.prototype, "stroke", 2);
__decorateClass([
  Validate64(POSITIVE_NUMBER23)
], OhlcSeriesItem.prototype, "strokeWidth", 2);
__decorateClass([
  Validate64(RATIO25)
], OhlcSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate64(LINE_DASH15)
], OhlcSeriesItem.prototype, "lineDash", 2);
__decorateClass([
  Validate64(POSITIVE_NUMBER23)
], OhlcSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate64(FUNCTION14, { optional: true })
], OhlcSeriesItem.prototype, "itemStyler", 2);
var OhlcSeriesItems = class extends BaseProperties24 {
  constructor() {
    super(...arguments);
    this.up = new OhlcSeriesItem();
    this.down = new OhlcSeriesItem();
  }
};
__decorateClass([
  Validate64(OBJECT29)
], OhlcSeriesItems.prototype, "up", 2);
__decorateClass([
  Validate64(OBJECT29)
], OhlcSeriesItems.prototype, "down", 2);
var OhlcSeriesProperties = class extends CandlestickSeriesProperties {
  constructor() {
    super(...arguments);
    this.item = new OhlcSeriesItems();
  }
};
__decorateClass([
  Validate64(OBJECT29)
], OhlcSeriesProperties.prototype, "item", 2);
__decorateClass([
  Validate64(FUNCTION14, { optional: true })
], OhlcSeriesProperties.prototype, "itemStyler", 2);

// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeries.ts
var { mergeDefaults: mergeDefaults7 } = _ModuleSupport138;
var OhlcSeries = class extends OhlcSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, resetCandlestickSelectionsFn);
    this.properties = new OhlcSeriesProperties();
  }
  async createNodeData() {
    const baseNodeData = this.createBaseNodeData();
    if (!baseNodeData) {
      return;
    }
    const nodeData = baseNodeData.nodeData.map((datum) => {
      const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(datum.itemId);
      return {
        ...datum,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      };
    });
    return { ...baseNodeData, nodeData };
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { xKey, openKey, closeKey, highKey, lowKey, itemStyler } = this.properties;
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(nodeDatum.itemId);
    if (itemStyler) {
      const formatStyles = callbackCache.call(itemStyler, {
        datum: nodeDatum.datum,
        itemId: nodeDatum.itemId,
        seriesId,
        highlighted,
        xKey,
        openKey,
        closeKey,
        highKey,
        lowKey,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      });
      if (formatStyles) {
        return mergeDefaults7(formatStyles, this.getSeriesStyles(nodeDatum));
      }
    }
    return this.getSeriesStyles(nodeDatum);
  }
  nodeFactory() {
    return new OhlcGroup();
  }
  getSeriesStyles(nodeDatum) {
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = nodeDatum;
    return {
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
  getActiveStyles(nodeDatum, highlighted) {
    const activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
    return highlighted ? mergeDefaults7(this.properties.highlightStyle.item, activeStyles) : activeStyles;
  }
  computeFocusBounds(opts) {
    return computeCandleFocusBounds(this, opts);
  }
};
OhlcSeries.className = "ohlc";
OhlcSeries.type = "ohlc";

// packages/ag-charts-enterprise/src/series/ohlc/ohlcModule.ts
var OhlcModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ohlc",
  moduleFactory: (ctx) => new OhlcSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: _Theme26.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme26.POSITION.LEFT
    },
    {
      type: _Theme26.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,
      position: _Theme26.POSITION.BOTTOM
    }
  ],
  themeTemplate: {
    animation: { enabled: false },
    axes: {
      [_Theme26.CARTESIAN_AXIS_TYPE.NUMBER]: {
        crosshair: {
          snap: false
        }
      },
      [_Theme26.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {
        groupPaddingInner: 0,
        crosshair: {
          enabled: true
        }
      }
    }
  },
  groupable: false,
  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {
    if (userPalette === "user-indexed") {
      const {
        strokes: [stroke2]
      } = takeColors(colorsCount);
      return {
        item: {
          up: {
            stroke: stroke2
          },
          down: {
            stroke: stroke2
          }
        }
      };
    }
    return {
      item: {
        up: { stroke: palette.up.stroke },
        down: { stroke: palette.down.stroke }
      }
    };
  }
};

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaModule.ts
import { _ModuleSupport as _ModuleSupport144, _Theme as _Theme28 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radar/radarThemes.ts
import { _ModuleSupport as _ModuleSupport139, _Theme as _Theme27 } from "ag-charts-community";
var BASE_RADAR_SERIES_THEME = {
  series: {
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: _Theme27.DEFAULT_FONT_FAMILY,
      color: _Theme27.DEFAULT_LABEL_COLOUR
    },
    marker: {
      enabled: true,
      fillOpacity: 1,
      shape: "circle",
      size: 6,
      strokeOpacity: 1,
      strokeWidth: 0
    }
  },
  axes: {
    [_Theme27.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      label: {
        padding: 10
      }
    }
  }
};
var RADAR_LINE_SERIES_THEME = _ModuleSupport139.mergeDefaults(
  {
    series: {
      strokeWidth: 2
    }
  },
  BASE_RADAR_SERIES_THEME
);
var RADAR_AREA_SERIES_THEME = _ModuleSupport139.mergeDefaults(
  {
    series: {
      fillOpacity: 0.8,
      strokeWidth: 2,
      marker: {
        enabled: false
      }
    }
  },
  BASE_RADAR_SERIES_THEME
);

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeries.ts
import { _ModuleSupport as _ModuleSupport143, _Scene as _Scene72 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radar/radarSeries.ts
import { _ModuleSupport as _ModuleSupport141, _Scene as _Scene71, _Util as _Util84 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radar/radarSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport140, _Scene as _Scene70 } from "ag-charts-community";
var { Label: Label8 } = _Scene70;
var {
  SeriesMarker,
  SeriesProperties: SeriesProperties9,
  SeriesTooltip: SeriesTooltip13,
  Validate: Validate65,
  BOOLEAN: BOOLEAN20,
  COLOR_STRING: COLOR_STRING22,
  DEGREE: DEGREE4,
  LINE_DASH: LINE_DASH16,
  OBJECT: OBJECT30,
  POSITIVE_NUMBER: POSITIVE_NUMBER24,
  RATIO: RATIO26,
  STRING: STRING30
} = _ModuleSupport140;
var RadarSeriesProperties = class extends SeriesProperties9 {
  constructor() {
    super(...arguments);
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.marker = new SeriesMarker();
    this.label = new Label8();
    this.tooltip = new SeriesTooltip13();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate65(STRING30)
], RadarSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate65(STRING30)
], RadarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate65(STRING30, { optional: true })
], RadarSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate65(STRING30, { optional: true })
], RadarSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate65(COLOR_STRING22)
], RadarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate65(POSITIVE_NUMBER24)
], RadarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate65(RATIO26)
], RadarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate65(LINE_DASH16)
], RadarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate65(POSITIVE_NUMBER24)
], RadarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate65(DEGREE4)
], RadarSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate65(OBJECT30)
], RadarSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate65(OBJECT30)
], RadarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate65(OBJECT30)
], RadarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate65(BOOLEAN20)
], RadarSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-enterprise/src/series/radar/radarSeries.ts
var {
  ChartAxisDirection: ChartAxisDirection17,
  PolarAxis: PolarAxis2,
  SeriesNodePickMode: SeriesNodePickMode12,
  valueProperty: valueProperty12,
  fixNumericExtent: fixNumericExtent5,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation3,
  markerFadeInAnimation,
  resetMarkerFn,
  animationValidation: animationValidation5,
  isFiniteNumber: isFiniteNumber3,
  computeMarkerFocusBounds: computeMarkerFocusBounds2
} = _ModuleSupport141;
var { BBox: BBox11, Group: Group12, Path: Path7, PointerEvents: PointerEvents6, Selection: Selection10, Text: Text7, getMarker: getMarker3 } = _Scene71;
var { extent, isNumberEqual: isNumberEqual8, sanitizeHtml: sanitizeHtml9, toFixed } = _Util84;
var RadarSeriesNodeEvent = class extends _ModuleSupport141.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadarSeries = class extends _ModuleSupport141.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode12.NEAREST_NODE, SeriesNodePickMode12.EXACT_SHAPE_MATCH],
      canHaveAxes: true,
      animationResetFns: {
        item: resetMarkerFn
      }
    });
    this.properties = new RadarSeriesProperties();
    this.NodeEvent = RadarSeriesNodeEvent;
    this.resetInvalidToZero = false;
    this.circleCache = { r: 0, cx: 0, cy: 0 };
    const lineGroup = new Group12();
    this.contentGroup.append(lineGroup);
    this.lineSelection = Selection10.select(lineGroup, Path7);
    lineGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
  }
  nodeFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker3(shape);
    return new MarkerShape();
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager?.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection17.X) {
      return dataModel.getDomain(this, `angleValue`, "value", processedData);
    } else {
      const domain = dataModel.getDomain(this, `radiusValue`, "value", processedData);
      const ext = extent(domain.length === 0 ? domain : [0].concat(domain));
      return fixNumericExtent5(ext);
    }
  }
  async processData(dataController) {
    if (!this.properties.isValid()) {
      return;
    }
    const { angleKey, radiusKey } = this.properties;
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      extraProps.push(animationValidation5());
    }
    const radiusScaleType = this.axes[ChartAxisDirection17.Y]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection17.X]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty12(angleKey, angleScaleType, { id: "angleValue" }),
        valueProperty12(radiusKey, radiusScaleType, { id: "radiusValue", invalidValue: void 0 }),
        ...extraProps
      ]
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection17.Y];
    return radiusAxis instanceof PolarAxis2 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  async maybeRefreshNodeData() {
    const didCircleChange = this.didCircleChange();
    if (!didCircleChange && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = await this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  async createNodeData() {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.properties.isValid()) {
      return;
    }
    const { angleKey, radiusKey, angleName, radiusName, marker, label } = this.properties;
    const angleScale = this.axes[ChartAxisDirection17.X]?.scale;
    const radiusScale = this.axes[ChartAxisDirection17.Y]?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
    const radiusIdx = dataModel.resolveProcessedDataIndexById(this, `radiusValue`);
    const axisInnerRadius = this.getAxisInnerRadius();
    const nodeData = processedData.data.map((group) => {
      const { datum, values } = group;
      const angleDatum = values[angleIdx];
      const radiusDatum = values[radiusIdx];
      const angle = angleScale.convert(angleDatum);
      const radius = this.radius + axisInnerRadius - radiusScale.convert(radiusDatum);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = cos * radius;
      const y = sin * radius;
      let labelNodeDatum;
      if (label.enabled) {
        const labelText = this.getLabelText(
          label,
          { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
          (value) => isFiniteNumber3(value) ? value.toFixed(2) : String(value)
        );
        if (labelText) {
          let textAlign = "right";
          if (isNumberEqual8(cos, 0)) {
            textAlign = "center";
          } else if (cos > 0) {
            textAlign = "left";
          }
          let textBaseline = "bottom";
          if (isNumberEqual8(sin, 0)) {
            textBaseline = "middle";
          } else if (sin > 0) {
            textBaseline = "top";
          }
          labelNodeDatum = {
            x: x + cos * marker.size,
            y: y + sin * marker.size,
            text: labelText,
            textAlign,
            textBaseline
          };
        }
      }
      return {
        series: this,
        datum,
        point: { x, y, size: marker.size },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        missing: !_Util84.isNumber(angle) || !_Util84.isNumber(radius)
      };
    });
    return { itemId: radiusKey, nodeData, labelData: nodeData };
  }
  async update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const { series } = this.ctx.highlightManager?.getActiveHighlight() ?? {};
    this.highlightGroup.visible = (animationEnabled || this.visible) && !!(series === this);
    await this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updatePathSelections();
    this.updateMarkerSelection();
    this.updateMarkers(this.itemSelection, false);
    this.updateMarkers(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.lineSelection.update(pathData);
  }
  updateMarkerSelection() {
    if (this.properties.marker.isDirty()) {
      this.itemSelection.clear();
      this.itemSelection.cleanup();
      this.itemSelection = Selection10.select(this.itemGroup, () => this.nodeFactory(), false);
    }
    this.itemSelection.update(this.properties.marker.enabled ? this.nodeData : []);
  }
  getMarkerFill(highlightedStyle) {
    return highlightedStyle?.fill ?? this.properties.marker.fill;
  }
  updateMarkers(selection, highlight) {
    const { angleKey, radiusKey, marker, visible } = this.properties;
    let selectionData = [];
    if (visible && marker.shape && marker.enabled) {
      if (highlight) {
        const highlighted = this.ctx.highlightManager?.getActiveHighlight();
        if (highlighted?.datum) {
          selectionData = [highlighted];
        }
      } else {
        selectionData = this.nodeData;
      }
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    selection.update(selectionData).each((node, datum) => {
      const fill = this.getMarkerFill(highlightedStyle);
      const fillOpacity = highlightedStyle?.fillOpacity ?? this.properties.marker.fillOpacity;
      const stroke2 = highlightedStyle?.stroke ?? marker.stroke ?? this.properties.stroke;
      const strokeWidth = highlightedStyle?.strokeWidth ?? marker.strokeWidth ?? this.properties.strokeWidth ?? 1;
      const strokeOpacity = highlightedStyle?.strokeOpacity ?? this.properties.marker.strokeOpacity;
      const format = marker.itemStyler ? this.ctx.callbackCache.call(marker.itemStyler, {
        datum: datum.datum,
        angleKey,
        radiusKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        shape: marker.shape,
        size: marker.size,
        highlighted: highlight,
        seriesId: this.id
      }) : void 0;
      node.fill = format?.fill ?? fill;
      node.stroke = format?.stroke ?? stroke2;
      node.strokeWidth = format?.strokeWidth ?? strokeWidth;
      node.fillOpacity = highlightedStyle?.fillOpacity ?? marker.fillOpacity ?? 1;
      node.strokeOpacity = marker.strokeOpacity ?? this.properties.strokeOpacity ?? 1;
      node.size = format?.size ?? marker.size;
      const { x, y } = datum.point;
      node.x = x;
      node.y = y;
      node.visible = visible && node.size > 0 && !isNaN(x) && !isNaN(y);
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getTooltipHtml(nodeDatum) {
    if (!this.properties.isValid()) {
      return _ModuleSupport141.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { angleKey, radiusKey, angleName, radiusName, marker, tooltip } = this.properties;
    const { datum, angleValue, radiusValue, itemId } = nodeDatum;
    const formattedAngleValue = typeof angleValue === "number" ? toFixed(angleValue) : String(angleValue);
    const formattedRadiusValue = typeof radiusValue === "number" ? toFixed(radiusValue) : String(radiusValue);
    const title = sanitizeHtml9(radiusName);
    const content = sanitizeHtml9(`${formattedAngleValue}: ${formattedRadiusValue}`);
    const {
      itemStyler,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth = this.properties.strokeWidth,
      strokeOpacity,
      shape,
      size
    } = marker;
    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {
      datum,
      angleKey,
      radiusKey,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      shape,
      size,
      highlighted: false,
      seriesId
    })) ?? { fill };
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        title,
        color,
        seriesId,
        itemId
      }
    );
  }
  getLegendData(legendType) {
    if (!this.data?.length || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, visible, marker } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName ?? radiusKey
        },
        symbols: [
          {
            marker: {
              shape: marker.shape,
              fill: this.getMarkerFill() ?? marker.stroke ?? stroke2 ?? "rgba(0, 0, 0, 0)",
              stroke: marker.stroke ?? stroke2 ?? "rgba(0, 0, 0, 0)",
              fillOpacity: marker.fillOpacity ?? 1,
              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,
              strokeWidth: marker.strokeWidth ?? 0,
              enabled: marker.enabled || strokeWidth <= 0
            },
            line: {
              stroke: stroke2,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ]
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  pickNodeClosestDatum(hitPoint) {
    const { nodeData, centerX: cx, centerY: cy } = this;
    const { x, y } = hitPoint;
    const radius = this.radius;
    const distanceFromCenter = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
    if (distanceFromCenter > radius + this.properties.marker.size) {
      return;
    }
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const distance = Math.sqrt((hitPoint.x - datumX - cx) ** 2 + (hitPoint.y - datumY - cy) ** 2);
      if (distance < minDistance) {
        minDistance = distance;
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      const distance = Math.max(minDistance - (closestDatum.point?.size ?? 0), 0);
      return { datum: closestDatum, distance };
    }
  }
  async computeLabelsBBox() {
    const { label } = this.properties;
    await this.maybeRefreshNodeData();
    const textBoxes = [];
    const tempText2 = new Text7();
    this.nodeData.forEach((nodeDatum) => {
      if (!label.enabled || !nodeDatum.label) {
        return;
      }
      tempText2.text = nodeDatum.label.text;
      tempText2.x = nodeDatum.label.x;
      tempText2.y = nodeDatum.label.y;
      tempText2.setFont(label);
      tempText2.setAlign(nodeDatum.label);
      const box = tempText2.getBBox();
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox11.merge(textBoxes);
  }
  getLineNode() {
    return this.lineSelection?.at(0);
  }
  beforePathAnimation() {
    const lineNode = this.getLineNode();
    lineNode.fill = void 0;
    lineNode.lineJoin = "round";
    lineNode.lineCap = "round";
    lineNode.pointerEvents = PointerEvents6.None;
    lineNode.stroke = this.properties.stroke;
    lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    lineNode.strokeOpacity = this.properties.strokeOpacity;
    lineNode.lineDash = this.properties.lineDash;
    lineNode.lineDashOffset = this.properties.lineDashOffset;
  }
  getLinePoints() {
    const { nodeData, resetInvalidToZero } = this;
    const { connectMissingData } = this.properties;
    if (nodeData.length === 0) {
      return [];
    }
    const radiusAxis = this.axes[ChartAxisDirection17.Y];
    const angleAxis = this.axes[ChartAxisDirection17.X];
    const reversedAngleAxis = angleAxis?.isReversed();
    const reversedRadiusAxis = radiusAxis?.isReversed();
    const data = reversedRadiusAxis && !reversedAngleAxis ? [...nodeData].reverse() : nodeData;
    const points = [];
    let prevPointInvalid = false;
    let firstValid;
    data.forEach((datum, index) => {
      let { x, y } = datum.point;
      const isPointInvalid = isNaN(x) || isNaN(y);
      if (!isPointInvalid) {
        firstValid ?? (firstValid = datum);
      }
      if (isPointInvalid && !connectMissingData) {
        x = 0;
        y = 0;
      }
      const moveTo = index === 0 || !resetInvalidToZero && !connectMissingData && (isPointInvalid || prevPointInvalid);
      points.push({ x, y, moveTo });
      prevPointInvalid = isPointInvalid;
    });
    if (firstValid !== void 0) {
      points.push({ x: firstValid.point.x, y: firstValid.point.y, moveTo: false });
    }
    return points;
  }
  animateSinglePath(pathNode, points, ratio) {
    const { path } = pathNode;
    path.clear(true);
    const axisInnerRadius = this.getAxisInnerRadius();
    const radiusAxis = this.axes[ChartAxisDirection17.Y];
    const reversedRadiusAxis = radiusAxis?.isReversed();
    const radiusZero = reversedRadiusAxis ? this.radius + axisInnerRadius - radiusAxis?.scale.convert(0) : axisInnerRadius;
    points.forEach((point) => {
      const { x: x1, y: y1, arc, radius = 0, startAngle = 0, endAngle = 0, moveTo } = point;
      const angle = Math.atan2(y1, x1);
      const x0 = radiusZero * Math.cos(angle);
      const y0 = radiusZero * Math.sin(angle);
      const t = ratio;
      const x = x0 * (1 - t) + x1 * t;
      const y = y0 * (1 - t) + y1 * t;
      if (arc) {
        path.arc(x1, y1, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    pathNode.checkPathDirty();
  }
  animatePaths(ratio) {
    const linePoints = this.getLinePoints();
    this.animateSinglePath(this.getLineNode(), linePoints, ratio);
  }
  animateEmptyUpdateReady() {
    const { itemSelection, labelSelection } = this;
    const { animationManager } = this.ctx;
    this.beforePathAnimation();
    animationManager.animate({
      id: `${this.id}_'path`,
      groupId: this.id,
      from: 0,
      to: 1,
      phase: "initial",
      collapsable: false,
      onUpdate: (ratio) => this.animatePaths(ratio),
      onStop: () => this.animatePaths(1)
    });
    markerFadeInAnimation(this, animationManager, "added", itemSelection);
    seriesLabelFadeInAnimation3(this, "labels", animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    super.animateWaitingUpdateReady(data);
    this.resetPaths();
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetPaths();
  }
  resetPaths() {
    const lineNode = this.getLineNode();
    if (lineNode) {
      const { path: linePath } = lineNode;
      const linePoints = this.getLinePoints();
      lineNode.fill = void 0;
      lineNode.stroke = this.properties.stroke;
      lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      lineNode.strokeOpacity = this.properties.strokeOpacity;
      lineNode.lineDash = this.properties.lineDash;
      lineNode.lineDashOffset = this.properties.lineDashOffset;
      linePath.clear(true);
      linePoints.forEach(({ x, y, moveTo }) => {
        if (moveTo) {
          linePath.moveTo(x, y);
        } else {
          linePath.lineTo(x, y);
        }
      });
      lineNode.checkPathDirty();
    }
  }
  getFormattedMarkerStyle(datum) {
    const { angleKey, radiusKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, angleKey, radiusKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds2(this, opts);
  }
};
RadarSeries.className = "RadarSeries";

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport142 } from "ag-charts-community";
var { RATIO: RATIO27, COLOR_STRING: COLOR_STRING23, Validate: Validate66 } = _ModuleSupport142;
var RadarAreaSeriesProperties = class extends RadarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Validate66(COLOR_STRING23)
], RadarAreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate66(RATIO27)
], RadarAreaSeriesProperties.prototype, "fillOpacity", 2);

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeries.ts
var { Group: Group13, Path: Path8, PointerEvents: PointerEvents7, Selection: Selection11 } = _Scene72;
var { ChartAxisDirection: ChartAxisDirection18 } = _ModuleSupport143;
var RadarAreaSeries = class extends RadarSeries {
  constructor(moduleCtx) {
    super(moduleCtx);
    this.properties = new RadarAreaSeriesProperties();
    this.resetInvalidToZero = true;
    const areaGroup = new Group13();
    areaGroup.zIndexSubOrder = [() => this._declarationOrder, 0];
    this.contentGroup.append(areaGroup);
    this.areaSelection = Selection11.select(areaGroup, Path8);
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.areaSelection.update(pathData);
    super.updatePathSelections();
  }
  getAreaNode() {
    return this.areaSelection.at(0);
  }
  getMarkerFill(highlightedStyle) {
    return highlightedStyle?.fill ?? this.properties.marker.fill ?? this.properties.fill;
  }
  beforePathAnimation() {
    super.beforePathAnimation();
    const areaNode = this.getAreaNode();
    areaNode.fill = this.properties.fill;
    areaNode.fillOpacity = this.properties.fillOpacity;
    areaNode.pointerEvents = PointerEvents7.None;
    areaNode.stroke = void 0;
  }
  animatePaths(ratio) {
    super.animatePaths(ratio);
    this.animateSinglePath(this.getAreaNode(), this.getAreaPoints(), ratio);
  }
  getAreaPoints() {
    const points = this.getLinePoints();
    const getPolarAxis = (direction) => {
      const axis = this.axes[direction];
      return axis instanceof _ModuleSupport143.PolarAxis ? axis : void 0;
    };
    const radiusAxis = getPolarAxis(ChartAxisDirection18.Y);
    const angleAxis = getPolarAxis(ChartAxisDirection18.X);
    const reversedRadiusAxis = radiusAxis?.isReversed();
    if (!reversedRadiusAxis) {
      return points;
    }
    const zeroLinePoints = angleAxis?.getAxisLinePoints()?.points ?? [];
    return points.concat(...zeroLinePoints);
  }
  resetPaths() {
    super.resetPaths();
    const areaNode = this.getAreaNode();
    if (areaNode) {
      const { path: areaPath } = areaNode;
      const areaPoints = this.getAreaPoints();
      areaNode.fill = this.properties.fill;
      areaNode.fillOpacity = this.properties.fillOpacity;
      areaNode.stroke = void 0;
      areaNode.lineDash = this.properties.lineDash;
      areaNode.lineDashOffset = this.properties.lineDashOffset;
      areaNode.lineJoin = areaNode.lineCap = "round";
      areaPath.clear(true);
      areaPoints.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
        if (arc) {
          areaPath.arc(x, y, radius, startAngle, endAngle);
        } else if (moveTo) {
          areaPath.moveTo(x, y);
        } else {
          areaPath.lineTo(x, y);
        }
      });
      areaPath.closePath();
      areaNode.checkPathDirty();
    }
  }
};
RadarAreaSeries.className = "RadarAreaSeries";
RadarAreaSeries.type = "radar-area";

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaModule.ts
var { markerPaletteFactory } = _ModuleSupport144;
var RadarAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-area",
  moduleFactory: (ctx) => new RadarAreaSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: _Theme28.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: _Theme28.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADAR_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory(params);
    return {
      stroke: marker.stroke,
      fill: marker.fill,
      marker
    };
  }
};

// packages/ag-charts-enterprise/src/series/radar-line/radarLineModule.ts
import { _Theme as _Theme29 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radar-line/radarLineSeries.ts
var RadarLineSeries = class extends RadarSeries {
  updatePathSelections() {
    this.lineSelection.update(this.visible ? [true] : []);
  }
};
RadarLineSeries.className = "RadarLineSeries";
RadarLineSeries.type = "radar-line";

// packages/ag-charts-enterprise/src/series/radar-line/radarLineModule.ts
var RadarLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-line",
  moduleFactory: (ctx) => new RadarLineSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: _Theme29.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: _Theme29.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADAR_LINE_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    return {
      stroke: fill,
      marker: { fill, stroke: stroke2 }
    };
  }
};

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarModule.ts
import { _Theme as _Theme31 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeries.ts
import { _ModuleSupport as _ModuleSupport146, _Scale as _Scale19, _Scene as _Scene75, _Util as _Util85 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport145, _Scene as _Scene73 } from "ag-charts-community";
var { Label: Label9 } = _Scene73;
var {
  SeriesProperties: SeriesProperties10,
  SeriesTooltip: SeriesTooltip14,
  Validate: Validate67,
  COLOR_STRING: COLOR_STRING24,
  DEGREE: DEGREE5,
  FUNCTION: FUNCTION15,
  LINE_DASH: LINE_DASH17,
  NUMBER: NUMBER16,
  OBJECT: OBJECT31,
  POSITIVE_NUMBER: POSITIVE_NUMBER25,
  RATIO: RATIO28,
  STRING: STRING31
} = _ModuleSupport145;
var RadialBarSeriesProperties = class extends SeriesProperties10 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.label = new Label9();
    this.tooltip = new SeriesTooltip14();
  }
};
__decorateClass([
  Validate67(STRING31)
], RadialBarSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate67(STRING31)
], RadialBarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate67(STRING31, { optional: true })
], RadialBarSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate67(STRING31, { optional: true })
], RadialBarSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate67(COLOR_STRING24)
], RadialBarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate67(RATIO28)
], RadialBarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate67(COLOR_STRING24)
], RadialBarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate67(POSITIVE_NUMBER25)
], RadialBarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate67(RATIO28)
], RadialBarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate67(LINE_DASH17)
], RadialBarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate67(POSITIVE_NUMBER25)
], RadialBarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate67(POSITIVE_NUMBER25)
], RadialBarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate67(FUNCTION15, { optional: true })
], RadialBarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate67(DEGREE5)
], RadialBarSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate67(STRING31, { optional: true })
], RadialBarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Validate67(NUMBER16, { optional: true })
], RadialBarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate67(OBJECT31)
], RadialBarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate67(OBJECT31)
], RadialBarSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarUtil.ts
import { _Scene as _Scene74 } from "ag-charts-community";
var { SectorBox: SectorBox3, motion: motion6 } = _Scene74;
function fixRadialBarAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.innerRadius) || isNaN(node.previousDatum.outerRadius)) {
      return "added";
    }
    if (isNaN(datum.innerRadius) || isNaN(datum.outerRadius)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialBarSeriesAnimationFunctions(axisZeroAngle) {
  const fromFn = (sect, datum, status) => {
    status = fixRadialBarAnimationStatus(sect, datum, status);
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      startAngle = sect.startAngle;
      endAngle = sect.endAngle;
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    }
    clipSector ?? (clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius));
    const phase = motion6.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector, phase };
  };
  const toFn = (sect, datum, status) => {
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
      clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      startAngle = datum.startAngle;
      endAngle = datum.endAngle;
      innerRadius = isNaN(datum.innerRadius) ? sect.innerRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? sect.outerRadius : datum.outerRadius;
      clipSector = datum.clipSector;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector };
  };
  return { toFn, fromFn };
}
function resetRadialBarSelectionsFn(_node, datum) {
  return {
    centerX: 0,
    centerY: 0,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    clipSector: datum.clipSector
  };
}

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeries.ts
var {
  ChartAxisDirection: ChartAxisDirection19,
  PolarAxis: PolarAxis3,
  diff: diff5,
  isDefined: isDefined4,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty3,
  keyProperty: keyProperty6,
  mergeDefaults: mergeDefaults8,
  normaliseGroupTo: normaliseGroupTo2,
  valueProperty: valueProperty13,
  fixNumericExtent: fixNumericExtent6,
  resetLabelFn: resetLabelFn2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation4,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation2,
  animationValidation: animationValidation6,
  isFiniteNumber: isFiniteNumber4
} = _ModuleSupport146;
var { BandScale: BandScale4 } = _Scale19;
var { Sector: Sector5, SectorBox: SectorBox4, motion: motion7 } = _Scene75;
var { angleBetween: angleBetween4, isNumber: isNumber2, sanitizeHtml: sanitizeHtml10 } = _Util85;
var RadialBarSeriesNodeEvent = class extends _ModuleSupport146.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialBarSeries = class extends _ModuleSupport146.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      animationResetFns: {
        item: resetRadialBarSelectionsFn,
        label: resetLabelFn2
      }
    });
    this.properties = new RadialBarSeriesProperties();
    this.NodeEvent = RadialBarSeriesNodeEvent;
    this.groupScale = new BandScale4();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  nodeFactory() {
    return new Sector5();
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager?.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection19.X) {
      const xExtent = dataModel.getDomain(this, "angleValue-end", "value", processedData);
      const fixedXExtent = [xExtent[0] > 0 ? 0 : xExtent[0], xExtent[1] < 0 ? 0 : xExtent[1]];
      return fixNumericExtent6(fixedXExtent);
    } else {
      return dataModel.getDomain(this, "radiusValue", "key", processedData);
    }
  }
  async processData(dataController) {
    const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    if (!this.properties.isValid() || !(visible || animationEnabled))
      return;
    const stackGroupId = this.getStackId();
    const stackGroupTrailingId = `${stackGroupId}-trailing`;
    const extraProps = [];
    if (isDefined4(normalizedTo)) {
      extraProps.push(normaliseGroupTo2([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range"));
    }
    if (animationEnabled) {
      if (this.processedData) {
        extraProps.push(diff5(this.processedData));
      }
      extraProps.push(animationValidation6());
    }
    const visibleProps = this.visible || !animationEnabled ? {} : { forceValue: 0 };
    const radiusScaleType = this.axes[ChartAxisDirection19.Y]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection19.X]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty6(radiusKey, radiusScaleType, { id: "radiusValue" }),
        valueProperty13(angleKey, angleScaleType, {
          id: "angleValue-raw",
          invalidValue: null,
          ...visibleProps
        }),
        ...groupAccumulativeValueProperty3(
          angleKey,
          "normal",
          "current",
          {
            id: `angleValue-end`,
            rangeId: `angleValue-range`,
            invalidValue: null,
            groupId: stackGroupId,
            separateNegative: true,
            ...visibleProps
          },
          angleScaleType
        ),
        ...groupAccumulativeValueProperty3(
          angleKey,
          "trailing",
          "current",
          {
            id: `angleValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId,
            separateNegative: true,
            ...visibleProps
          },
          angleScaleType
        ),
        ...extraProps
      ]
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  async maybeRefreshNodeData() {
    const circleChanged = this.didCircleChange();
    if (!circleChanged && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = await this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection19.Y];
    return radiusAxis instanceof PolarAxis3 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  async createNodeData() {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.properties.isValid()) {
      return;
    }
    const angleAxis = this.axes[ChartAxisDirection19.X];
    const radiusAxis = this.axes[ChartAxisDirection19.Y];
    const angleScale = angleAxis?.scale;
    const radiusScale = radiusAxis?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const angleStartIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-start`);
    const angleEndIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-end`);
    const angleRangeIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-range`);
    const angleRawIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-raw`);
    let groupPaddingInner = 0;
    if (radiusAxis instanceof RadiusCategoryAxis) {
      groupPaddingInner = radiusAxis.groupPaddingInner;
    }
    const { groupScale } = this;
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
    groupScale.range = [0, Math.abs(radiusScale.bandwidth ?? 0)];
    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
    const barWidth = groupScale.bandwidth >= 1 ? groupScale.bandwidth : groupScale.rawBandwidth;
    const angleAxisReversed = angleAxis.isReversed();
    const radiusAxisReversed = radiusAxis.isReversed();
    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
    const axisTotalRadius = axisOuterRadius + axisInnerRadius;
    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
    const getLabelNodeDatum = (datum, angleDatum, x, y) => {
      const labelText = this.getLabelText(
        label,
        { value: angleDatum, datum, angleKey, radiusKey, angleName, radiusName },
        (value) => isFiniteNumber4(value) ? value.toFixed(2) : String(value)
      );
      if (labelText) {
        return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
      }
    };
    const nodeData = [];
    const context = { itemId: radiusKey, nodeData, labelData: nodeData };
    if (!this.visible)
      return context;
    processedData.data.forEach((group, index) => {
      const { datum, keys, values, aggValues } = group;
      const radiusDatum = keys[0];
      const angleDatum = values[angleRawIndex];
      const isPositive = angleDatum >= 0 && !Object.is(angleDatum, -0);
      const angleStartDatum = values[angleStartIndex];
      const angleEndDatum = values[angleEndIndex];
      const angleRange = aggValues?.[angleRangeIndex][isPositive ? 1 : 0] ?? 0;
      const reversed = isPositive === angleAxisReversed;
      let startAngle = angleScale.convert(angleStartDatum, { clampMode: "clamped" });
      let endAngle = angleScale.convert(angleEndDatum, { clampMode: "clamped" });
      let rangeStartAngle = angleScale.convert(0, { clampMode: "clamped" });
      let rangeEndAngle = angleScale.convert(angleRange, { clampMode: "clamped" });
      if (reversed) {
        [rangeStartAngle, rangeEndAngle] = [rangeEndAngle, rangeStartAngle];
        [startAngle, endAngle] = [endAngle, startAngle];
      }
      const insetAdjustment = radiusScale.domain.length === 1 ? radiusScale.range[0] : 0;
      const dataRadius = axisTotalRadius - radiusScale.convert(radiusDatum) - insetAdjustment;
      const innerRadius = dataRadius + groupScale.convert(String(groupIndex));
      const outerRadius = innerRadius + barWidth;
      const midRadius = (innerRadius + outerRadius) / 2;
      const midAngle = startAngle + angleBetween4(startAngle, endAngle) / 2;
      const x = Math.cos(midAngle) * midRadius;
      const y = Math.sin(midAngle) * midRadius;
      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, angleDatum, x, y) : void 0;
      const clipSector = new SectorBox4(startAngle, endAngle, innerRadius, outerRadius);
      nodeData.push({
        series: this,
        datum,
        point: { x, y, size: 0 },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        innerRadius,
        outerRadius,
        startAngle: rangeStartAngle,
        endAngle: rangeEndAngle,
        clipSector,
        reversed,
        index
      });
    });
    return context;
  }
  async update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    await this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updateSectorSelection(this.itemSelection, false);
    this.updateSectorSelection(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updateSectorSelection(selection, highlighted) {
    let selectionData = [];
    if (highlighted) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      if (activeHighlight?.datum && activeHighlight.series === this) {
        selectionData = [activeHighlight];
      }
    } else {
      selectionData = this.nodeData;
    }
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      cornerRadius,
      angleKey,
      radiusKey
    } = mergeDefaults8(highlighted ? this.properties.highlightStyle.item : null, this.properties);
    const idFn = (datum) => datum.radiusValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      const format = this.properties.itemStyler ? this.ctx.callbackCache.call(this.properties.itemStyler, {
        seriesId: this.id,
        datum: datum.datum,
        highlighted,
        angleKey,
        radiusKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius
      }) : void 0;
      node.fill = format?.fill ?? fill;
      node.fillOpacity = format?.fillOpacity ?? fillOpacity;
      node.stroke = format?.stroke ?? stroke2;
      node.strokeWidth = format?.strokeWidth ?? strokeWidth;
      node.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;
      node.lineDash = format?.lineDash ?? lineDash;
      node.lineDashOffset = format?.lineDashOffset ?? lineDashOffset;
      node.lineJoin = "round";
      node.inset = stroke2 != null ? (format?.strokeWidth ?? strokeWidth) / 2 : 0;
      node.startInnerCornerRadius = datum.reversed ? format?.cornerRadius ?? cornerRadius : 0;
      node.startOuterCornerRadius = datum.reversed ? format?.cornerRadius ?? cornerRadius : 0;
      node.endInnerCornerRadius = datum.reversed ? 0 : format?.cornerRadius ?? cornerRadius;
      node.endOuterCornerRadius = datum.reversed ? 0 : format?.cornerRadius ?? cornerRadius;
      if (highlighted) {
        node.startAngle = datum.startAngle;
        node.endAngle = datum.endAngle;
        node.clipSector = datum.clipSector;
        node.innerRadius = datum.innerRadius;
        node.outerRadius = datum.outerRadius;
      }
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getBarTransitionFunctions() {
    const angleScale = this.axes[ChartAxisDirection19.X]?.scale;
    let axisZeroAngle = 0;
    if (!angleScale) {
      return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
    }
    const d0 = Math.min(angleScale.domain[0], angleScale.domain[1]);
    const d1 = Math.max(angleScale.domain[0], angleScale.domain[1]);
    if (d0 <= 0 && d1 >= 0) {
      axisZeroAngle = angleScale.convert(0);
    }
    return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getBarTransitionFunctions();
    motion7.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation4(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getBarTransitionFunctions();
    motion7.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation2(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, axes, dataModel } = this;
    const {
      angleKey,
      angleName,
      radiusKey,
      radiusName,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      itemStyler,
      tooltip
    } = this.properties;
    const { angleValue, radiusValue, datum, itemId } = nodeDatum;
    const xAxis = axes[ChartAxisDirection19.X];
    const yAxis = axes[ChartAxisDirection19.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber2(angleValue)) || !dataModel) {
      return _ModuleSupport146.EMPTY_TOOLTIP_CONTENT;
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml10(angleName);
    const content = sanitizeHtml10(`${radiusString}: ${angleString}`);
    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {
      highlighted: false,
      seriesId,
      datum,
      angleKey,
      radiusKey,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius
    })) ?? { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      {
        seriesId,
        datum,
        color,
        title,
        angleKey,
        radiusKey,
        angleName,
        radiusName,
        angleValue,
        itemId,
        radiusValue
      }
    );
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());
  }
  getLegendData(legendType) {
    if (!this.data?.length || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { angleKey, angleName, fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: angleKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: angleName ?? angleKey
        },
        symbols: [
          {
            marker: {
              fill: fill ?? "rgba(0, 0, 0, 0)",
              stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity ?? 1,
              strokeOpacity: strokeOpacity ?? 1,
              strokeWidth
            }
          }
        ]
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `radialBar-stack-${groupIndex}-xValues`;
  }
};
RadialBarSeries.className = "RadialBarSeries";
RadialBarSeries.type = "radial-bar";

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarThemes.ts
import { _Theme as _Theme30 } from "ag-charts-community";
var RADIAL_BAR_SERIES_THEME = {
  series: {
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: _Theme30.DEFAULT_FONT_FAMILY,
      color: _Theme30.DEFAULT_INVERTED_LABEL_COLOUR
    }
  },
  axes: {
    [_Theme30.POLAR_AXIS_TYPE.RADIUS_CATEGORY]: {
      innerRadiusRatio: 0.2,
      groupPaddingInner: 0.2,
      paddingInner: 0.2,
      paddingOuter: 0.1
    }
  }
};

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarModule.ts
var RadialBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-bar",
  moduleFactory: (ctx) => new RadialBarSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme31.POLAR_AXIS_TYPE.ANGLE_NUMBER
    },
    {
      type: _Theme31.POLAR_AXIS_TYPE.RADIUS_CATEGORY
    }
  ],
  themeTemplate: RADIAL_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    return {
      fill,
      stroke: stroke2
    };
  },
  stackable: true,
  groupable: true
};

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnModule.ts
import { _Theme as _Theme33 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeries.ts
import { _ModuleSupport as _ModuleSupport148, _Scene as _Scene76 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport147 } from "ag-charts-community";
var { Validate: Validate68, RATIO: RATIO29 } = _ModuleSupport147;
var RadialColumnSeriesProperties = class extends RadialColumnSeriesBaseProperties {
};
__decorateClass([
  Validate68(RATIO29, { optional: true })
], RadialColumnSeriesProperties.prototype, "columnWidthRatio", 2);
__decorateClass([
  Validate68(RATIO29, { optional: true })
], RadialColumnSeriesProperties.prototype, "maxColumnWidthRatio", 2);

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeries.ts
var { ChartAxisDirection: ChartAxisDirection20, PolarAxis: PolarAxis4 } = _ModuleSupport148;
var { RadialColumnShape, getRadialColumnWidth } = _Scene76;
var RadialColumnSeries = class extends RadialColumnSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, {
      animationResetFns: {
        item: resetRadialColumnSelectionFn
      }
    });
    this.properties = new RadialColumnSeriesProperties();
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `radarColumn-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new RadialColumnShape();
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareRadialColumnAnimationFunctions(axisZeroRadius);
  }
  isRadiusAxisCircle() {
    const radiusAxis = this.axes[ChartAxisDirection20.Y];
    return radiusAxis instanceof PolarAxis4 ? radiusAxis.shape === "circle" : false;
  }
  updateItemPath(node, datum, highlight) {
    node.isBeveled = this.isRadiusAxisCircle();
    node.isRadiusAxisReversed = this.isRadiusAxisReversed();
    if (highlight) {
      node.innerRadius = datum.innerRadius;
      node.outerRadius = datum.outerRadius;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
      node.columnWidth = datum.columnWidth;
      node.axisInnerRadius = datum.axisInnerRadius;
      node.axisOuterRadius = datum.axisOuterRadius;
    }
  }
  getColumnWidth(startAngle, endAngle) {
    const { columnWidthRatio = 0.5, maxColumnWidthRatio = 0.5 } = this.properties;
    return getRadialColumnWidth(startAngle, endAngle, this.radius, columnWidthRatio, maxColumnWidthRatio);
  }
};
RadialColumnSeries.className = "RadialColumnSeries";
RadialColumnSeries.type = "radial-column";

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnThemes.ts
import { _Theme as _Theme32 } from "ag-charts-community";
var RADIAL_COLUMN_SERIES_THEME = {
  series: {
    columnWidthRatio: 0.5,
    maxColumnWidthRatio: 0.5,
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: _Theme32.DEFAULT_FONT_FAMILY,
      color: _Theme32.DEFAULT_LABEL_COLOUR
    }
  },
  axes: {
    [_Theme32.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: _Theme32.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [_Theme32.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: _Theme32.POLAR_AXIS_SHAPE.CIRCLE,
      innerRadiusRatio: 0.5
    }
  }
};

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnModule.ts
var RadialColumnModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-column",
  moduleFactory: (ctx) => new RadialColumnSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme33.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: _Theme33.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADIAL_COLUMN_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    return {
      fill,
      stroke: stroke2
    };
  },
  stackable: true,
  groupable: true
};

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeModule.ts
import { _Theme as _Theme34 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeSeries.ts
import {
  _ModuleSupport as _ModuleSupport150,
  _Scene as _Scene80,
  _Util as _Util87
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/gauge-util/label.ts
function formatLabel(value, axis) {
  if (value == null)
    return "";
  if (axis == null)
    return String(value);
  const [min, max] = axis.scale.domain;
  const minLog10 = min !== 0 ? Math.ceil(Math.log10(Math.abs(min))) : 0;
  const maxLog10 = max !== 0 ? Math.ceil(Math.log10(Math.abs(max))) : 0;
  const dp = Math.max(2 - Math.max(minLog10, maxLog10), 0);
  return value.toFixed(dp);
}

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeNeedle.ts
import { _Scene as _Scene77 } from "ag-charts-community";
var { SvgPath, Rotatable, Translatable, Scalable } = _Scene77;
var RadialGaugeNeedle = class extends Rotatable(Scalable(Translatable(SvgPath))) {
  constructor() {
    super(...arguments);
    this.scalingCenterX = 0.5;
    this.scalingCenterY = 0.5;
    this.rotationCenterX = 0.5;
    this.rotationCenterY = 0.5;
  }
};
RadialGaugeNeedle.defaultPathData = "M0.50245 0.53745C0.481767 0.53745 0.465 0.520683 0.465 0.5C0.465 0.479317 0.481767 0.46255 0.50245 0.46255L1 0.500012L0.50245 0.53745Z";

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport149, _Scene as _Scene78, _Util as _Util86 } from "ag-charts-community";
var {
  BaseProperties: BaseProperties25,
  SeriesTooltip: SeriesTooltip15,
  SeriesProperties: SeriesProperties11,
  PropertiesArray: PropertiesArray4,
  Validate: Validate69,
  BOOLEAN: BOOLEAN21,
  COLOR_STRING: COLOR_STRING25,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY7,
  FUNCTION: FUNCTION16,
  LINE_DASH: LINE_DASH18,
  NUMBER: NUMBER17,
  OBJECT_ARRAY: OBJECT_ARRAY2,
  OBJECT: OBJECT32,
  POSITIVE_NUMBER: POSITIVE_NUMBER26,
  RATIO: RATIO30,
  STRING: STRING32,
  UNION: UNION9
} = _ModuleSupport149;
var { Label: Label10 } = _Scene78;
var { Logger: Logger20 } = _Util86;
var TARGET_PLACEMENT2 = UNION9(["inside", "outside", "middle"], "a placement");
var RadialGaugeDefaultTargetLabelProperties = class extends Label10 {
};
__decorateClass([
  Validate69(NUMBER17, { optional: true })
], RadialGaugeDefaultTargetLabelProperties.prototype, "spacing", 2);
var RadialGaugeTargetProperties = class extends BaseProperties25 {
  constructor() {
    super(...arguments);
    this.label = new RadialGaugeDefaultTargetLabelProperties();
  }
};
__decorateClass([
  Validate69(STRING32, { optional: true })
], RadialGaugeTargetProperties.prototype, "text", 2);
__decorateClass([
  Validate69(NUMBER17, { optional: true })
], RadialGaugeTargetProperties.prototype, "value", 2);
__decorateClass([
  Validate69(TARGET_MARKER_SHAPE, { optional: true })
], RadialGaugeTargetProperties.prototype, "shape", 2);
__decorateClass([
  Validate69(TARGET_PLACEMENT2, { optional: true })
], RadialGaugeTargetProperties.prototype, "placement", 2);
__decorateClass([
  Validate69(NUMBER17, { optional: true })
], RadialGaugeTargetProperties.prototype, "spacing", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeTargetProperties.prototype, "size", 2);
__decorateClass([
  Validate69(NUMBER17, { optional: true })
], RadialGaugeTargetProperties.prototype, "rotation", 2);
__decorateClass([
  Validate69(COLOR_STRING25, { optional: true })
], RadialGaugeTargetProperties.prototype, "fill", 2);
__decorateClass([
  Validate69(RATIO30, { optional: true })
], RadialGaugeTargetProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate69(COLOR_STRING25, { optional: true })
], RadialGaugeTargetProperties.prototype, "stroke", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeTargetProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate69(RATIO30, { optional: true })
], RadialGaugeTargetProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate69(LINE_DASH18, { optional: true })
], RadialGaugeTargetProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeTargetProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeTargetProperties.prototype, "label", 2);
var RadialGaugeBarProperties = class extends BaseProperties25 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.fills = new PropertiesArray4(GaugeStopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate69(BOOLEAN21)
], RadialGaugeBarProperties.prototype, "enabled", 2);
__decorateClass([
  Validate69(OBJECT_ARRAY2)
], RadialGaugeBarProperties.prototype, "fills", 2);
__decorateClass([
  Validate69(FILL_MODE)
], RadialGaugeBarProperties.prototype, "fillMode", 2);
__decorateClass([
  Validate69(COLOR_STRING25, { optional: true })
], RadialGaugeBarProperties.prototype, "fill", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeBarProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate69(COLOR_STRING25, { optional: true })
], RadialGaugeBarProperties.prototype, "stroke", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeBarProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate69(LINE_DASH18)
], RadialGaugeBarProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeBarProperties.prototype, "lineDashOffset", 2);
var RadialGaugeScaleProperties = class extends BaseProperties25 {
  constructor() {
    super(...arguments);
    this.fills = new PropertiesArray4(GaugeStopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.defaultFill = "black";
  }
};
__decorateClass([
  Validate69(OBJECT_ARRAY2)
], RadialGaugeScaleProperties.prototype, "fills", 2);
__decorateClass([
  Validate69(FILL_MODE)
], RadialGaugeScaleProperties.prototype, "fillMode", 2);
__decorateClass([
  Validate69(COLOR_STRING25, { optional: true })
], RadialGaugeScaleProperties.prototype, "fill", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeScaleProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate69(COLOR_STRING25)
], RadialGaugeScaleProperties.prototype, "stroke", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeScaleProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeScaleProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate69(LINE_DASH18)
], RadialGaugeScaleProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeScaleProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate69(COLOR_STRING25)
], RadialGaugeScaleProperties.prototype, "defaultFill", 2);
var RadialGaugeNeedleProperties = class extends BaseProperties25 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.spacing = 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate69(BOOLEAN21)
], RadialGaugeNeedleProperties.prototype, "enabled", 2);
__decorateClass([
  Validate69(RATIO30, { optional: true })
], RadialGaugeNeedleProperties.prototype, "radiusRatio", 2);
__decorateClass([
  Validate69(NUMBER17)
], RadialGaugeNeedleProperties.prototype, "spacing", 2);
__decorateClass([
  Validate69(COLOR_STRING25)
], RadialGaugeNeedleProperties.prototype, "fill", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeNeedleProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate69(COLOR_STRING25)
], RadialGaugeNeedleProperties.prototype, "stroke", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeNeedleProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeNeedleProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate69(LINE_DASH18)
], RadialGaugeNeedleProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeNeedleProperties.prototype, "lineDashOffset", 2);
var RadialGaugeLabelProperties = class extends AutoSizedLabel {
};
__decorateClass([
  Validate69(STRING32, { optional: true })
], RadialGaugeLabelProperties.prototype, "text", 2);
var RadialGaugeSecondaryLabelProperties = class extends AutoSizedSecondaryLabel {
};
__decorateClass([
  Validate69(STRING32, { optional: true })
], RadialGaugeSecondaryLabelProperties.prototype, "text", 2);
var RadialGaugeSeriesProperties = class extends SeriesProperties11 {
  constructor() {
    super(...arguments);
    this.segmentation = new GaugeSegmentationProperties();
    this.defaultColorRange = [];
    this.targets = new PropertiesArray4(RadialGaugeTargetProperties);
    this.defaultTarget = new RadialGaugeTargetProperties();
    this.outerRadiusRatio = 1;
    this.innerRadiusRatio = 1;
    this.cornerRadius = 0;
    this.cornerMode = "container";
    this.spacing = 0;
    this.scale = new RadialGaugeScaleProperties();
    this.bar = new RadialGaugeBarProperties();
    this.needle = new RadialGaugeNeedleProperties();
    this.label = new RadialGaugeLabelProperties();
    this.secondaryLabel = new RadialGaugeSecondaryLabelProperties();
    this.tooltip = new SeriesTooltip15();
  }
  isValid(warningPrefix) {
    if (!super.isValid(warningPrefix))
      return false;
    const { outerRadius, innerRadius } = this;
    if (outerRadius == null !== (innerRadius == null)) {
      Logger20.warnOnce("Either [innerRadius] and [outerRadius] must both be set, or neither can be set.");
      return false;
    }
    return true;
  }
};
__decorateClass([
  Validate69(NUMBER17)
], RadialGaugeSeriesProperties.prototype, "value", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "segmentation", 2);
__decorateClass([
  Validate69(COLOR_STRING_ARRAY7)
], RadialGaugeSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Validate69(OBJECT_ARRAY2)
], RadialGaugeSeriesProperties.prototype, "targets", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "defaultTarget", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Validate69(RATIO30)
], RadialGaugeSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeSeriesProperties.prototype, "outerRadius", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26, { optional: true })
], RadialGaugeSeriesProperties.prototype, "innerRadius", 2);
__decorateClass([
  Validate69(POSITIVE_NUMBER26)
], RadialGaugeSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate69(CORNER_MODE)
], RadialGaugeSeriesProperties.prototype, "cornerMode", 2);
__decorateClass([
  Validate69(NUMBER17)
], RadialGaugeSeriesProperties.prototype, "spacing", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "scale", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "bar", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "needle", 2);
__decorateClass([
  Validate69(FUNCTION16, { optional: true })
], RadialGaugeSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass([
  Validate69(OBJECT32)
], RadialGaugeSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeUtil.ts
import { _Scene as _Scene79 } from "ag-charts-community";
var { SectorBox: SectorBox5 } = _Scene79;
var fadeInFns = {
  fromFn: () => ({ opacity: 0, phase: "initial" }),
  toFn: () => ({ opacity: 1 })
};
function computeClipSector(datum) {
  const { startAngle, endAngle, clipStartAngle, clipEndAngle, innerRadius, outerRadius } = datum;
  if (clipStartAngle == null || clipEndAngle == null)
    return;
  return new SectorBox5(
    Math.max(clipStartAngle, startAngle),
    Math.min(clipEndAngle, endAngle),
    innerRadius,
    outerRadius
  );
}
function clipSectorVisibility(startAngle, endAngle, clipSector) {
  return Math.max(startAngle, clipSector.startAngle) <= Math.min(endAngle, clipSector.endAngle);
}
function hasClipSector(datum) {
  return datum.clipStartAngle != null && datum.clipEndAngle != null;
}
function datumClipSector(datum, zero) {
  const { clipStartAngle, clipEndAngle, innerRadius, outerRadius } = datum;
  return new SectorBox5(clipStartAngle, zero ? clipStartAngle : clipEndAngle, innerRadius, outerRadius);
}
function prepareRadialGaugeSeriesAnimationFunctions(initialLoad, initialStartAngle) {
  const phase = initialLoad ? "initial" : "update";
  const node = {
    fromFn(sect, datum) {
      const previousDatum = sect.previousDatum;
      let { startAngle, endAngle } = previousDatum ?? datum;
      const previousClipSector = previousDatum != null && hasClipSector(previousDatum) ? datumClipSector(previousDatum, initialLoad) : void 0;
      const nextClipSector = hasClipSector(datum) ? datumClipSector(datum, initialLoad) : void 0;
      let clipSector;
      if (previousClipSector != null && nextClipSector != null) {
        clipSector = previousClipSector;
      } else if (previousClipSector == null && nextClipSector != null) {
        clipSector = nextClipSector;
        startAngle = datum.startAngle;
        endAngle = datum.endAngle;
      } else if (previousClipSector != null && nextClipSector == null) {
        clipSector = void 0;
        startAngle = datum.startAngle;
        endAngle = datum.endAngle;
      } else if (initialLoad) {
        endAngle = startAngle;
      }
      return { startAngle, endAngle, clipSector, phase };
    },
    toFn(_sect, datum) {
      const { startAngle, endAngle } = datum;
      let clipSector;
      if (hasClipSector(datum)) {
        clipSector = datumClipSector(datum, false);
      }
      return { startAngle, endAngle, clipSector };
    },
    applyFn(sect, params) {
      const { startAngle, endAngle } = params;
      let { clipSector } = params;
      if (clipSector != null) {
        clipSector = new SectorBox5(
          Math.max(startAngle, clipSector.startAngle),
          Math.min(endAngle, clipSector.endAngle),
          clipSector.innerRadius,
          clipSector.outerRadius
        );
      }
      const visible = clipSector == null || clipSectorVisibility(startAngle, endAngle, clipSector);
      sect.startAngle = startAngle;
      sect.endAngle = endAngle;
      sect.clipSector = clipSector;
      sect.visible = visible;
    }
  };
  const needle = {
    fromFn(needleNode) {
      let { angle: rotation } = needleNode.previousDatum ?? needleNode.datum;
      if (initialLoad) {
        rotation = initialStartAngle;
      }
      return { rotation, phase };
    },
    toFn(_needleNode, datum) {
      const { angle: rotation } = datum;
      return { rotation };
    }
  };
  return { node, needle };
}
function resetRadialGaugeSeriesResetSectorFunction(_node, datum) {
  const { startAngle, endAngle } = datum;
  const clipSector = computeClipSector(datum);
  const visible = clipSector == null || clipSectorVisibility(startAngle, endAngle, clipSector);
  return { startAngle, endAngle, clipSector, visible };
}
function resetRadialGaugeSeriesResetNeedleFunction(_node, datum) {
  const { angle } = datum;
  return { rotation: angle };
}
function getLabelText(series, label, value, defaultFormatter) {
  if (label.text != null) {
    return label.text;
  } else if (value != null) {
    const labelFormat = label?.formatter?.({ seriesId: series.id, datum: void 0, value });
    if (labelFormat != null)
      return String(labelFormat);
    return defaultFormatter?.(value);
  }
}
var verticalAlignFactors2 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
function formatRadialGaugeLabels(series, selection, labelProps, secondaryLabelProps, opts, innerRadius, defaultFormatter, datumOverrides) {
  const { padding, textAlign, verticalAlign } = opts;
  let labelDatum;
  let secondaryLabelDatum;
  selection.each((_node, datum) => {
    if (datum.label === "primary" /* Primary */) {
      labelDatum = datum;
    } else if (datum.label === "secondary" /* Secondary */) {
      secondaryLabelDatum = datum;
    }
  });
  const labelText = getLabelText(series, labelProps, datumOverrides?.label ?? labelDatum?.value, defaultFormatter);
  if (labelText == null)
    return;
  const secondaryLabelText = getLabelText(
    series,
    secondaryLabelProps,
    datumOverrides?.secondaryLabel ?? secondaryLabelDatum?.value
  );
  const params = { padding };
  const horizontalFactor = textAlign === "center" ? 2 : 1;
  const verticalFactor = verticalAlign === "middle" ? 2 : 1;
  const sizeFittingHeight = (height2) => ({
    width: Math.sqrt(Math.max(innerRadius ** 2 - (height2 / verticalFactor) ** 2, 0)) * horizontalFactor,
    height: Math.min(height2, verticalFactor * innerRadius),
    meta: null
  });
  let labelLayout;
  let secondaryLabelLayout;
  let height;
  if (secondaryLabelText != null) {
    const layout = formatStackedLabels(
      labelText,
      labelProps,
      secondaryLabelText,
      secondaryLabelProps,
      params,
      sizeFittingHeight
    );
    labelLayout = layout?.label;
    secondaryLabelLayout = layout?.secondaryLabel;
    height = layout?.height ?? 0;
  } else {
    const layout = formatSingleLabel(labelText, labelProps, params, sizeFittingHeight);
    labelLayout = layout?.[0];
    secondaryLabelLayout = void 0;
    height = layout?.[0].height ?? 0;
  }
  const rectYOffset = height * verticalAlignFactors2[verticalAlign];
  selection.each((label, datum) => {
    let layout;
    if (datum.label === "primary" /* Primary */) {
      layout = labelLayout;
    } else if (datum.label === "secondary" /* Secondary */) {
      layout = secondaryLabelLayout;
    }
    if (layout == null) {
      label.visible = false;
      return;
    }
    label.visible = true;
    label.text = layout.text;
    label.fontSize = layout.fontSize;
    label.lineHeight = layout.lineHeight;
    label.textAlign = textAlign;
    label.textBaseline = "middle";
    const rectOriginInLabelRect = datum.label === "primary" /* Primary */ ? layout.height / 2 : height - layout.height / 2;
    label.y = datum.centerY + rectOriginInLabelRect - rectYOffset;
    label.x = datum.centerX;
  });
}

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeSeries.ts
var {
  fromToMotion: fromToMotion4,
  resetMotion: resetMotion2,
  SeriesNodePickMode: SeriesNodePickMode13,
  StateMachine: StateMachine12,
  createDatumId: createDatumId9,
  ChartAxisDirection: ChartAxisDirection21,
  EMPTY_TOOLTIP_CONTENT: EMPTY_TOOLTIP_CONTENT3
} = _ModuleSupport150;
var { BBox: BBox12, Group: Group14, PointerEvents: PointerEvents8, Selection: Selection12, Sector: Sector6, Text: Text8, ConicGradient, getMarker: getMarker4 } = _Scene80;
var { normalizeAngle360: normalizeAngle3607, normalizeAngle360Inclusive, toDegrees, toRadians: toRadians5 } = _Util87;
var targetPlacementRotation = {
  inside: 90,
  middle: 0,
  outside: -90
};
var outsideLabelPlacements = [
  { textAlign: "left", textBaseline: "top" },
  { textAlign: "right", textBaseline: "top" },
  { textAlign: "right", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "bottom" }
];
var insideLabelPlacements = [
  { textAlign: "right", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "top" },
  { textAlign: "right", textBaseline: "top" }
];
var RadialGaugeSeries = class extends _ModuleSupport150.Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode13.EXACT_SHAPE_MATCH, SeriesNodePickMode13.NEAREST_NODE]
    });
    this.canHaveAxes = true;
    this.properties = new RadialGaugeSeriesProperties();
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.scaleGroup = this.contentGroup.appendChild(new Group14({ name: "scaleGroup" }));
    this.itemGroup = this.contentGroup.appendChild(new Group14({ name: "itemGroup" }));
    this.itemNeedleGroup = this.contentGroup.appendChild(new Group14({ name: "itemNeedleGroup" }));
    this.itemTargetGroup = this.contentGroup.appendChild(new Group14({ name: "itemTargetGroup" }));
    this.itemTargetLabelGroup = this.contentGroup.appendChild(new Group14({ name: "itemTargetLabelGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group14({ name: "itemLabelGroup" }));
    this.highlightTargetGroup = this.highlightGroup.appendChild(
      new Group14({ name: "itemTargetLabelGroup" })
    );
    this.scaleSelection = Selection12.select(
      this.scaleGroup,
      () => this.nodeFactory()
    );
    this.datumSelection = Selection12.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.needleSelection = Selection12.select(
      this.itemNeedleGroup,
      RadialGaugeNeedle
    );
    this.targetSelection = Selection12.select(
      this.itemTargetGroup,
      (datum) => this.markerFactory(datum)
    );
    this.targetLabelSelection = Selection12.select(
      this.itemTargetLabelGroup,
      Text8
    );
    this.labelSelection = Selection12.select(
      this.itemLabelGroup,
      Text8
    );
    this.highlightTargetSelection = Selection12.select(
      this.highlightTargetGroup,
      (datum) => this.markerFactory(datum)
    );
    this.nodeDatum = { series: this, datum: {} };
    this.animationState = new StateMachine12("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.animateEmptyUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      ready: {
        updateData: "waiting",
        clear: "clearing",
        // highlight: (data) => this.animateReadyHighlight(data),
        // highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
        resize: () => this.animateReadyResize(),
        reset: "empty",
        skip: "ready"
      },
      waiting: {
        update: {
          target: "ready",
          action: () => this.animateWaitingUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      clearing: {
        update: {
          target: "empty"
          // action: (data) => this.animateClearingUpdateEmpty(data),
        },
        reset: "empty",
        skip: "ready"
      }
    });
    this.itemGroup.pointerEvents = PointerEvents8.None;
    this.itemTargetLabelGroup.pointerEvents = PointerEvents8.None;
    this.itemLabelGroup.pointerEvents = PointerEvents8.None;
  }
  get maximumRadius() {
    return this.properties.outerRadius;
  }
  get minimumRadius() {
    return this.properties.outerRadius;
  }
  get hasData() {
    return this.properties.value != null;
  }
  nodeFactory() {
    return new Sector6();
  }
  markerFactory({ shape }) {
    const MarkerShape = shape !== "line" ? getMarker4(shape) : LineMarker;
    const marker = new MarkerShape();
    marker.size = 1;
    return marker;
  }
  async processData() {
    this.nodeDataRefresh = true;
    this.animationState.transition("updateData");
  }
  formatLabel(value) {
    return formatLabel(value, this.axes[ChartAxisDirection21.X]);
  }
  createConicGradient(fills, fillMode) {
    const { centerX, centerY, radius } = this;
    const { domain, range: range2 } = this.axes[ChartAxisDirection21.X].scale;
    const [startAngle, endAngle] = range2;
    const { defaultColorRange } = this.properties;
    const conicAngle = normalizeAngle3607((startAngle + endAngle) / 2 + Math.PI);
    const sweepAngle = normalizeAngle360Inclusive(endAngle - startAngle);
    const stops = getColorStops(fills, defaultColorRange, domain, fillMode).map(
      ({ color, offset }) => {
        offset = Math.min(Math.max(offset, 0), 1);
        const angle = startAngle + sweepAngle * offset;
        offset = (angle - conicAngle) / (2 * Math.PI);
        offset = (offset % 1 + 1) % 1;
        return { offset, color };
      }
    );
    return new ConicGradient(
      "oklch",
      stops,
      toDegrees(conicAngle) - 90,
      new BBox12(centerX - radius, centerY - radius, 2 * radius, 2 * radius)
    );
  }
  getTargets() {
    const { properties } = this;
    const defaultTarget = properties.defaultTarget;
    return Array.from(properties.targets).map((target) => {
      const {
        text: text2 = defaultTarget.text,
        value = defaultTarget.value ?? 0,
        shape = defaultTarget.shape ?? "triangle",
        rotation = defaultTarget.rotation ?? 0,
        strokeWidth = defaultTarget.strokeWidth ?? 0,
        placement = defaultTarget.placement ?? "middle",
        spacing = defaultTarget.spacing ?? 0,
        size = defaultTarget.size ?? 0,
        fill = defaultTarget.fill ?? "black",
        fillOpacity = defaultTarget.fillOpacity ?? 1,
        stroke: stroke2 = defaultTarget.stroke ?? "black",
        strokeOpacity = defaultTarget.strokeOpacity ?? 1,
        lineDash = defaultTarget.lineDash ?? [0],
        lineDashOffset = defaultTarget.lineDashOffset ?? 0
      } = target;
      const {
        enabled: labelEnabled = defaultTarget.label.enabled,
        color: labelColor = defaultTarget.label.color ?? "black",
        fontStyle: labelFontStyle = defaultTarget.label.fontStyle ?? "normal",
        fontWeight: labelFontWeight = defaultTarget.label.fontWeight ?? "normal",
        fontSize: labelFontSize = defaultTarget.label.fontSize,
        fontFamily: labelFontFamily = defaultTarget.label.fontFamily,
        spacing: labelSpacing = defaultTarget.label.spacing ?? 0
      } = target.label;
      return {
        text: text2,
        value,
        shape,
        placement,
        spacing,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        label: {
          enabled: labelEnabled,
          color: labelColor,
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          spacing: labelSpacing
        }
      };
    });
  }
  getTargetRadius(target) {
    const { radius, properties } = this;
    const { innerRadiusRatio, outerRadiusRatio } = properties;
    const { placement, spacing, size } = target;
    const outerRadius = radius * outerRadiusRatio;
    const innerRadius = radius * innerRadiusRatio;
    switch (placement) {
      case "inside":
        return Math.max(innerRadius - spacing - size / 2, 0);
      case "outside":
        return outerRadius + spacing + size / 2;
      default:
        return (innerRadius + outerRadius) / 2;
    }
  }
  getTargetLabel(target) {
    const angleAxis = this.axes[ChartAxisDirection21.X];
    const angleScale = angleAxis.scale;
    const { value, size, placement, label } = target;
    const { spacing, color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    const lineHeight = void 0;
    const angle = angleScale.convert(value);
    const quadrant = normalizeAngle3607(angle) / (Math.PI / 2) | 0;
    const offset = size / 2 + spacing;
    let textAlign;
    let textBaseline;
    let offsetX;
    let offsetY;
    switch (placement) {
      case "outside":
        ({ textAlign, textBaseline } = outsideLabelPlacements[quadrant]);
        offsetX = offset * Math.cos(angle);
        offsetY = offset * Math.sin(angle);
        break;
      case "inside":
        ({ textAlign, textBaseline } = insideLabelPlacements[quadrant]);
        offsetX = -offset * Math.cos(angle);
        offsetY = -offset * Math.sin(angle);
        break;
      default:
        textAlign = "center";
        textBaseline = "bottom";
        offsetX = 0;
        offsetY = -offset;
        break;
    }
    return {
      offsetX,
      offsetY,
      fill,
      textAlign,
      textBaseline,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      lineHeight
    };
  }
  async createNodeData() {
    const { id: seriesId, properties, radius, centerX, centerY } = this;
    if (!properties.isValid())
      return;
    const angleAxis = this.axes[ChartAxisDirection21.X];
    if (angleAxis == null)
      return;
    const {
      value,
      innerRadiusRatio,
      outerRadiusRatio,
      segmentation,
      cornerRadius,
      cornerMode,
      needle,
      bar,
      scale,
      label,
      secondaryLabel
    } = properties;
    const { outerRadius = radius * outerRadiusRatio, innerRadius = radius * innerRadiusRatio } = properties;
    const targets = this.getTargets();
    const { domain } = angleAxis.scale;
    const nodeData = [];
    const targetData = [];
    const needleData = [];
    const labelData = [];
    const scaleData = [];
    const [startAngle, endAngle] = angleAxis.range;
    const angleScale = angleAxis.scale;
    const cornersOnAllItems = cornerMode === "item";
    const containerStartAngle = angleScale.convert(domain[0]);
    const containerEndAngle = angleScale.convert(value);
    const maxTicks = Math.ceil(normalizeAngle360Inclusive(containerEndAngle - containerStartAngle) * radius);
    let segments = segmentation.enabled ? segmentation.interval.getSegments(angleAxis.scale, maxTicks) : void 0;
    const barFill = bar.fill ?? this.createConicGradient(bar.fills, bar.fillMode);
    const scaleFill = scale.fill ?? (bar.enabled && scale.fills.length === 0 ? scale.defaultFill : void 0) ?? this.createConicGradient(scale.fills, scale.fillMode);
    if (segments == null && cornersOnAllItems) {
      const [segmentStart, segmentEnd] = domain;
      const datum = { value, segmentStart, segmentEnd };
      const appliedCornerRadius = Math.min(cornerRadius, (outerRadius - innerRadius) / 2);
      const angleInset = appliedCornerRadius / ((innerRadius + outerRadius) / 2);
      if (bar.enabled) {
        nodeData.push({
          series: this,
          itemId: `value`,
          datum,
          type: 0 /* Node */,
          centerX,
          centerY,
          outerRadius,
          innerRadius,
          startAngle: containerStartAngle - angleInset,
          endAngle: containerEndAngle + angleInset,
          clipStartAngle: void 0,
          clipEndAngle: void 0,
          startCornerRadius: cornerRadius,
          endCornerRadius: cornerRadius,
          fill: barFill
        });
      }
      scaleData.push({
        series: this,
        itemId: `scale`,
        datum,
        type: 0 /* Node */,
        centerX,
        centerY,
        outerRadius,
        innerRadius,
        startAngle: startAngle - angleInset,
        endAngle: endAngle + angleInset,
        clipStartAngle: void 0,
        clipEndAngle: void 0,
        startCornerRadius: cornerRadius,
        endCornerRadius: cornerRadius,
        fill: scaleFill
      });
    } else {
      segments ?? (segments = domain);
      for (let i = 0; i < segments.length - 1; i += 1) {
        const segmentStart = segments[i + 0];
        const segmentEnd = segments[i + 1];
        const datum = { value, segmentStart, segmentEnd };
        const isStart = i === 0;
        const isEnd = i === segments.length - 2;
        const itemStartAngle = angleScale.convert(segmentStart);
        const itemEndAngle = angleScale.convert(segmentEnd);
        if (bar.enabled) {
          nodeData.push({
            series: this,
            itemId: `value-${i}`,
            datum,
            type: 0 /* Node */,
            centerX,
            centerY,
            outerRadius,
            innerRadius,
            startAngle: itemStartAngle,
            endAngle: itemEndAngle,
            clipStartAngle: containerStartAngle,
            clipEndAngle: containerEndAngle,
            startCornerRadius: cornersOnAllItems || isStart ? cornerRadius : 0,
            endCornerRadius: cornersOnAllItems || isEnd ? cornerRadius : 0,
            fill: barFill
          });
        }
        scaleData.push({
          series: this,
          itemId: `scale-${i}`,
          datum,
          type: 0 /* Node */,
          centerX,
          centerY,
          outerRadius,
          innerRadius,
          startAngle: itemStartAngle,
          endAngle: itemEndAngle,
          clipStartAngle: void 0,
          clipEndAngle: void 0,
          startCornerRadius: cornersOnAllItems || isStart ? cornerRadius : 0,
          endCornerRadius: cornersOnAllItems || isEnd ? cornerRadius : 0,
          fill: scaleFill
        });
      }
    }
    if (!needle.enabled && label.enabled) {
      const { color: fill, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, formatter } = label;
      labelData.push({
        label: "primary" /* Primary */,
        centerX,
        centerY,
        text: label.text,
        value,
        fill,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter
      });
    }
    if (!needle.enabled && secondaryLabel.enabled) {
      const { color: fill, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, formatter } = secondaryLabel;
      labelData.push({
        label: "secondary" /* Secondary */,
        centerX,
        centerY,
        text: secondaryLabel.text,
        value,
        fill,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter
      });
    }
    if (needle.enabled) {
      let needleRadius = needle.radiusRatio != null ? radius * needle.radiusRatio : innerRadius;
      needleRadius = Math.max(needleRadius - needle.spacing, 0);
      const needleAngle = angleScale.convert(value);
      needleData.push({
        centerX,
        centerY,
        radius: needleRadius,
        angle: needleAngle
      });
    }
    for (let i = 0; i < targets.length; i += 1) {
      const target = targets[i];
      const {
        value: targetValue,
        text: text2,
        size,
        shape,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      } = target;
      if (targetValue < Math.min(...domain) || targetValue > Math.max(...domain)) {
        continue;
      }
      const targetRadius = this.getTargetRadius(target);
      const targetAngle = angleScale.convert(targetValue);
      const targetRotation = toRadians5(target.rotation + targetPlacementRotation[target.placement]);
      targetData.push({
        series: this,
        itemId: `target-${i}`,
        midPoint: {
          x: targetRadius * Math.cos(targetAngle) + centerX,
          y: targetRadius * Math.sin(targetAngle) + centerY
        },
        datum: { value: targetValue },
        type: 1 /* Target */,
        value: targetValue,
        text: text2,
        centerX,
        centerY,
        shape,
        radius: targetRadius,
        angle: targetAngle,
        rotation: targetRotation,
        size,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        label: this.getTargetLabel(target)
      });
    }
    return {
      itemId: seriesId,
      nodeData,
      needleData,
      targetData,
      labelData,
      scaleData
    };
  }
  async updateSelections(resize) {
    if (this.nodeDataRefresh || resize) {
      this.contextNodeData = await this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  highlightDatum(node) {
    if (node != null && node.series === this && node.type === 1 /* Target */) {
      return node;
    }
  }
  async update({ seriesRect }) {
    const {
      datumSelection,
      labelSelection,
      needleSelection,
      targetSelection,
      targetLabelSelection,
      scaleSelection,
      highlightTargetSelection
    } = this;
    const resize = this.checkResize(seriesRect);
    await this.updateSelections(resize);
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    const needleData = this.contextNodeData?.needleData ?? [];
    const targetData = this.contextNodeData?.targetData ?? [];
    const scaleData = this.contextNodeData?.scaleData ?? [];
    const highlightTargetDatum = this.highlightDatum(this.ctx.highlightManager.getActiveHighlight());
    this.scaleSelection = await this.updateScaleSelection({ scaleData, scaleSelection });
    await this.updateScaleNodes({ scaleSelection });
    this.needleSelection = await this.updateNeedleSelection({ needleData, needleSelection });
    await this.updateNeedleNodes({ needleSelection });
    this.targetSelection = await this.updateTargetSelection({ targetData, targetSelection });
    await this.updateTargetNodes({ targetSelection, isHighlight: false });
    this.targetLabelSelection = await this.updateTargetLabelSelection({ targetData, targetLabelSelection });
    await this.updateTargetLabelNodes({ targetLabelSelection });
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    await this.updateDatumNodes({ datumSelection });
    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });
    await this.updateLabelNodes({ labelSelection });
    this.highlightTargetSelection = await this.updateTargetSelection({
      targetData: highlightTargetDatum != null ? [highlightTargetDatum] : [],
      targetSelection: highlightTargetSelection
    });
    await this.updateTargetNodes({ targetSelection: highlightTargetSelection, isHighlight: true });
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => {
      return createDatumId9(opts.nodeData.length, datum.itemId);
    });
  }
  async updateDatumNodes(opts) {
    const { datumSelection } = opts;
    const { ctx, properties } = this;
    const { bar, segmentation } = properties;
    const sectorSpacing = segmentation.spacing ?? 0;
    const { fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = bar;
    const strokeWidth = this.getStrokeWidth(bar.strokeWidth);
    const animationDisabled = ctx.animationManager.isSkipped();
    datumSelection.each((sector, datum) => {
      const { centerX, centerY, innerRadius, outerRadius, startCornerRadius, endCornerRadius, fill } = datum;
      sector.centerX = centerX;
      sector.centerY = centerY;
      sector.innerRadius = innerRadius;
      sector.outerRadius = outerRadius;
      sector.fill = fill;
      sector.fillOpacity = fillOpacity;
      sector.stroke = stroke2;
      sector.strokeOpacity = strokeOpacity;
      sector.strokeWidth = strokeWidth;
      sector.lineDash = lineDash;
      sector.lineDashOffset = lineDashOffset;
      sector.startOuterCornerRadius = startCornerRadius;
      sector.startInnerCornerRadius = startCornerRadius;
      sector.endOuterCornerRadius = endCornerRadius;
      sector.endInnerCornerRadius = endCornerRadius;
      sector.radialEdgeInset = (sectorSpacing + sector.strokeWidth) / 2;
      sector.concentricEdgeInset = sector.strokeWidth / 2;
      if (animationDisabled || sector.previousDatum == null) {
        sector.setProperties(resetRadialGaugeSeriesResetSectorFunction(sector, datum));
      }
    });
  }
  async updateScaleSelection(opts) {
    return opts.scaleSelection.update(opts.scaleData, void 0, (datum) => {
      return createDatumId9(opts.scaleData.length, datum.itemId);
    });
  }
  async updateScaleNodes(opts) {
    const { scaleSelection } = opts;
    const { scale, segmentation } = this.properties;
    const sectorSpacing = segmentation.spacing ?? 0;
    const { fillOpacity, stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = scale;
    scaleSelection.each((sector, datum) => {
      const { centerX, centerY, innerRadius, outerRadius, startCornerRadius, endCornerRadius, fill } = datum;
      sector.centerX = centerX;
      sector.centerY = centerY;
      sector.innerRadius = innerRadius;
      sector.outerRadius = outerRadius;
      sector.fill = fill;
      sector.fillOpacity = fillOpacity;
      sector.stroke = stroke2;
      sector.strokeOpacity = strokeOpacity;
      sector.strokeWidth = strokeWidth;
      sector.lineDash = lineDash;
      sector.lineDashOffset = lineDashOffset;
      sector.startOuterCornerRadius = startCornerRadius;
      sector.startInnerCornerRadius = startCornerRadius;
      sector.endOuterCornerRadius = endCornerRadius;
      sector.endInnerCornerRadius = endCornerRadius;
      sector.radialEdgeInset = (sectorSpacing + sector.strokeWidth) / 2;
      sector.concentricEdgeInset = sector.strokeWidth / 2;
      sector.setProperties(resetRadialGaugeSeriesResetSectorFunction(sector, datum));
    });
  }
  async updateNeedleSelection(opts) {
    return opts.needleSelection.update(opts.needleData, void 0, () => createDatumId9([]));
  }
  async updateNeedleNodes(opts) {
    const { needleSelection } = opts;
    const { fill, fillOpacity, stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties.needle;
    const animationDisabled = this.ctx.animationManager.isSkipped();
    needleSelection.each((needle, datum) => {
      const { centerX, centerY, radius } = datum;
      const scale = radius * 2;
      needle.d = RadialGaugeNeedle.defaultPathData;
      needle.fill = fill;
      needle.fillOpacity = fillOpacity;
      needle.stroke = stroke2;
      needle.strokeOpacity = strokeOpacity;
      needle.strokeWidth = strokeWidth / scale;
      needle.lineDash = lineDash.map((d) => d / scale);
      needle.lineDashOffset = lineDashOffset / scale;
      needle.translationX = centerX;
      needle.translationY = centerY;
      needle.scalingX = scale;
      needle.scalingY = scale;
      if (animationDisabled) {
        needle.setProperties(resetRadialGaugeSeriesResetNeedleFunction(needle, datum));
      }
    });
  }
  async updateTargetSelection(opts) {
    return opts.targetSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  async updateTargetNodes(opts) {
    const { targetSelection, isHighlight } = opts;
    const highlightStyle = isHighlight ? this.properties.highlightStyle.item : void 0;
    targetSelection.each((target, datum) => {
      const {
        centerX,
        centerY,
        angle,
        radius,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      } = datum;
      target.size = size;
      target.fill = highlightStyle?.fill ?? fill;
      target.fillOpacity = highlightStyle?.fillOpacity ?? fillOpacity;
      target.stroke = highlightStyle?.stroke ?? stroke2;
      target.strokeOpacity = highlightStyle?.strokeOpacity ?? strokeOpacity;
      target.strokeWidth = highlightStyle?.strokeWidth ?? strokeWidth;
      target.lineDash = highlightStyle?.lineDash ?? lineDash;
      target.lineDashOffset = highlightStyle?.lineDashOffset ?? lineDashOffset;
      target.translationX = centerX + radius * Math.cos(angle);
      target.translationY = centerY + radius * Math.sin(angle);
      target.rotation = angle + rotation;
    });
  }
  async updateTargetLabelSelection(opts) {
    return opts.targetLabelSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  async updateTargetLabelNodes(opts) {
    const { targetLabelSelection } = opts;
    targetLabelSelection.each((label, target) => {
      const { centerX, centerY, radius, angle, text: text2 } = target;
      const { offsetX, offsetY, fill, fontStyle, fontWeight, fontSize, fontFamily, textAlign, textBaseline } = target.label;
      if (text2 == null) {
        label.visible = false;
        return;
      }
      label.visible = true;
      label.x = centerX + radius * Math.cos(angle) + offsetX;
      label.y = centerY + radius * Math.sin(angle) + offsetY;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = textAlign;
      label.textBaseline = textBaseline;
    });
  }
  async updateLabelSelection(opts) {
    return opts.labelSelection.update(opts.labelData, void 0, (datum) => datum.label);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const animationDisabled = this.ctx.animationManager.isSkipped();
    labelSelection.each((label, datum) => {
      label.fill = datum.fill;
      label.fontStyle = datum.fontStyle;
      label.fontWeight = datum.fontWeight;
      label.fontFamily = datum.fontFamily;
    });
    if (animationDisabled || this.labelsHaveExplicitText()) {
      this.formatLabelText();
    }
  }
  labelsHaveExplicitText() {
    for (const { datum } of this.labelSelection) {
      if (datum.text == null) {
        return false;
      }
    }
    return true;
  }
  formatLabelText(datum) {
    const angleAxis = this.axes[ChartAxisDirection21.X];
    if (angleAxis == null)
      return;
    const { labelSelection, radius, textAlign, verticalAlign } = this;
    const { label, secondaryLabel, spacing: padding, innerRadiusRatio } = this.properties;
    formatRadialGaugeLabels(
      this,
      labelSelection,
      label,
      secondaryLabel,
      { padding, textAlign, verticalAlign },
      radius * innerRadiusRatio,
      (value) => this.formatLabel(value),
      datum
    );
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    resetMotion2([this.datumSelection], resetRadialGaugeSeriesResetSectorFunction);
    resetMotion2([this.needleSelection], resetRadialGaugeSeriesResetNeedleFunction);
    this.formatLabelText();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  animateLabelText(params = {}) {
    const { animationManager } = this.ctx;
    let labelFrom;
    let labelTo;
    let secondaryLabelFrom;
    let secondaryLabelTo;
    this.labelSelection.each((label, datum) => {
      label.opacity = 1;
      if (datum.label === "primary" /* Primary */) {
        labelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
        labelTo = datum.value;
      } else if (datum.label === "secondary" /* Secondary */) {
        secondaryLabelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
        secondaryLabelTo = datum.value;
      }
    });
    if (this.labelsHaveExplicitText()) {
    } else if (labelTo == null || secondaryLabelTo == null) {
      this.formatLabelText();
    } else if (labelFrom === labelTo && secondaryLabelFrom === secondaryLabelTo) {
      this.formatLabelText({ label: labelTo, secondaryLabel: secondaryLabelTo });
    } else if (!this.labelsHaveExplicitText()) {
      const animationId = `${this.id}_labels`;
      animationManager.animate({
        id: animationId,
        groupId: "label",
        from: { label: labelFrom, secondaryLabel: secondaryLabelFrom },
        to: { label: labelTo, secondaryLabel: secondaryLabelTo },
        phase: params.phase ?? "update",
        onUpdate: (datum) => this.formatLabelText(datum)
      });
    }
  }
  animateEmptyUpdateReady() {
    const { animationManager } = this.ctx;
    const { node, needle } = prepareRadialGaugeSeriesAnimationFunctions(
      true,
      this.axes[ChartAxisDirection21.X]?.range[0] ?? 0
    );
    fromToMotion4(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    fromToMotion4(this.id, "needle", animationManager, [this.needleSelection], needle, () => "needle");
    fromToMotion4(
      this.id,
      "label",
      animationManager,
      [this.labelSelection],
      fadeInFns,
      (_label, datum) => datum.label
    );
    this.animateLabelText({
      from: this.axes[ChartAxisDirection21.X]?.scale.domain[0] ?? 0,
      phase: "initial"
    });
  }
  animateWaitingUpdateReady() {
    const { animationManager } = this.ctx;
    const { node, needle } = prepareRadialGaugeSeriesAnimationFunctions(
      false,
      this.axes[ChartAxisDirection21.X]?.range[0] ?? 0
    );
    fromToMotion4(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    fromToMotion4(this.id, "needle", animationManager, [this.needleSelection], needle, () => "needle");
    this.animateLabelText();
  }
  animateReadyResize() {
    this.resetAllAnimation();
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  pickNode(point, intent) {
    switch (intent) {
      case "event":
      case "context-menu": {
        const sectorTarget = this.scaleGroup.pickNode(point.x, point.y);
        return sectorTarget != null ? {
          pickMode: _ModuleSupport150.SeriesNodePickMode.EXACT_SHAPE_MATCH,
          match: sectorTarget.datum,
          distance: 0
        } : void 0;
      }
      case "tooltip":
      case "highlight":
      case "highlight-tooltip": {
        const highlightedTarget = this.itemTargetGroup.pickNode(point.x, point.y);
        return highlightedTarget != null ? {
          pickMode: _ModuleSupport150.SeriesNodePickMode.EXACT_SHAPE_MATCH,
          match: highlightedTarget.datum,
          distance: 0
        } : {
          pickMode: _ModuleSupport150.SeriesNodePickMode.NEAREST_NODE,
          match: this.nodeDatum,
          distance: 0
        };
      }
    }
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, properties } = this;
    if (!properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT3;
    }
    const highlightDatum = this.highlightDatum(nodeDatum);
    const value = highlightDatum?.value ?? properties.value;
    const text2 = highlightDatum?.text;
    const { tooltip } = properties;
    const title = text2 ?? "";
    const content = this.formatLabel(value);
    const itemId = highlightDatum?.itemId;
    const datum = void 0;
    const color = highlightDatum?.fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        itemId,
        title,
        datum,
        color,
        value,
        ...this.getModuleTooltipParams()
      }
    );
  }
  pickFocus(opts) {
    const targetData = this.contextNodeData?.targetData;
    if (targetData == null || targetData.length === 0)
      return;
    const datumIndex = Math.min(Math.max(opts.datumIndex, 0), targetData.length - 1);
    const datum = targetData[datumIndex];
    for (const node of this.targetSelection) {
      if (node.datum === datum) {
        const bounds = node.node;
        return { bounds, showFocusBox: true, datum, datumIndex };
      }
    }
  }
  getCaptionText() {
    const { value, label, secondaryLabel } = this.properties;
    const description = [];
    description.push(this.formatLabel(value));
    const labelText = getLabelText(this, label, value);
    if (labelText != null) {
      description.push(labelText);
    }
    const secondaryLabelText = getLabelText(this, secondaryLabel, value);
    if (secondaryLabelText != null) {
      description.push(secondaryLabelText);
    }
    return description.join(". ");
  }
};
RadialGaugeSeries.className = "RadialGaugeSeries";
RadialGaugeSeries.type = "radial-gauge";

// packages/ag-charts-enterprise/src/series/radial-gauge/radialGaugeModule.ts
var {
  FONT_WEIGHT: FONT_WEIGHT4,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY4,
  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS3,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR5,
  DEFAULT_MUTED_LABEL_COLOUR: DEFAULT_MUTED_LABEL_COLOUR2,
  POLAR_AXIS_TYPE
} = _Theme34;
var RadialGaugeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["gauge"],
  identifier: "radial-gauge",
  moduleFactory: (ctx) => new RadialGaugeSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    { type: POLAR_AXIS_TYPE.ANGLE_NUMBER, line: { enabled: false } },
    { type: POLAR_AXIS_TYPE.RADIUS_NUMBER, line: { enabled: false } }
  ],
  themeTemplate: {
    minWidth: 200,
    minHeight: 200,
    series: {
      outerRadiusRatio: 1,
      innerRadiusRatio: 0.8,
      bar: {
        strokeWidth: 0
      },
      segmentation: {
        enabled: false,
        interval: {},
        spacing: 2
      },
      // @ts-expect-error Private
      defaultTarget: {
        fill: DEFAULT_LABEL_COLOUR5,
        stroke: DEFAULT_LABEL_COLOUR5,
        size: 10,
        shape: "triangle",
        placement: "outside",
        spacing: 5,
        label: {
          enabled: true,
          fontWeight: FONT_WEIGHT4.NORMAL,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY4,
          color: DEFAULT_LABEL_COLOUR5,
          spacing: 5
        }
      },
      needle: {
        enabled: false,
        fill: DEFAULT_LABEL_COLOUR5,
        spacing: 10
      },
      label: {
        enabled: true,
        fontWeight: FONT_WEIGHT4.NORMAL,
        fontSize: 56,
        minimumFontSize: 18,
        fontFamily: DEFAULT_FONT_FAMILY4,
        color: DEFAULT_LABEL_COLOUR5
      },
      secondaryLabel: {
        enabled: true,
        fontWeight: FONT_WEIGHT4.NORMAL,
        fontSize: 14,
        minimumFontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY4,
        color: DEFAULT_MUTED_LABEL_COLOUR2
      },
      tooltip: {
        enabled: false
      }
    }
  },
  paletteFactory(params) {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = params;
    const { fills } = takeColors(colorsCount);
    const defaultColorRange = themeTemplateParameters.get(_Theme34.DEFAULT_GAUGE_SERIES_COLOUR_RANGE);
    const hierarchyFills = themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS3);
    const colorRange = userPalette === "inbuilt" ? defaultColorRange : [fills[0], fills[1]];
    return {
      scale: {
        defaultFill: hierarchyFills?.[1],
        stroke: hierarchyFills?.[2]
      },
      defaultColorRange: defaultColorStops(colorRange)
    };
  }
};

// packages/ag-charts-enterprise/src/series/range-area/rangeAreaModule.ts
import { _ModuleSupport as _ModuleSupport153, _Theme as _Theme36 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/range-area/rangeArea.ts
import { _ModuleSupport as _ModuleSupport152, _Scene as _Scene82, _Util as _Util88 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/range-area/rangeAreaProperties.ts
import { _ModuleSupport as _ModuleSupport151, _Scene as _Scene81 } from "ag-charts-community";
var { DropShadow, Label: Label11 } = _Scene81;
var {
  CartesianSeriesProperties: CartesianSeriesProperties2,
  InterpolationProperties,
  SeriesMarker: SeriesMarker2,
  SeriesTooltip: SeriesTooltip16,
  Validate: Validate70,
  BOOLEAN: BOOLEAN22,
  COLOR_STRING: COLOR_STRING26,
  LINE_DASH: LINE_DASH19,
  OBJECT: OBJECT33,
  PLACEMENT,
  POSITIVE_NUMBER: POSITIVE_NUMBER27,
  RATIO: RATIO31,
  STRING: STRING33
} = _ModuleSupport151;
var RangeAreaSeriesLabel = class extends Label11 {
  constructor() {
    super(...arguments);
    this.placement = "outside";
    this.padding = 6;
  }
};
__decorateClass([
  Validate70(PLACEMENT)
], RangeAreaSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Validate70(POSITIVE_NUMBER27)
], RangeAreaSeriesLabel.prototype, "padding", 2);
var RangeAreaProperties = class extends CartesianSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.shadow = new DropShadow().set({ enabled: false });
    this.marker = new SeriesMarker2();
    this.label = new RangeAreaSeriesLabel();
    this.tooltip = new SeriesTooltip16();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate70(STRING33)
], RangeAreaProperties.prototype, "xKey", 2);
__decorateClass([
  Validate70(STRING33)
], RangeAreaProperties.prototype, "yLowKey", 2);
__decorateClass([
  Validate70(STRING33)
], RangeAreaProperties.prototype, "yHighKey", 2);
__decorateClass([
  Validate70(STRING33, { optional: true })
], RangeAreaProperties.prototype, "xName", 2);
__decorateClass([
  Validate70(STRING33, { optional: true })
], RangeAreaProperties.prototype, "yName", 2);
__decorateClass([
  Validate70(STRING33, { optional: true })
], RangeAreaProperties.prototype, "yLowName", 2);
__decorateClass([
  Validate70(STRING33, { optional: true })
], RangeAreaProperties.prototype, "yHighName", 2);
__decorateClass([
  Validate70(COLOR_STRING26)
], RangeAreaProperties.prototype, "fill", 2);
__decorateClass([
  Validate70(RATIO31)
], RangeAreaProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate70(COLOR_STRING26)
], RangeAreaProperties.prototype, "stroke", 2);
__decorateClass([
  Validate70(POSITIVE_NUMBER27)
], RangeAreaProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate70(RATIO31)
], RangeAreaProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate70(LINE_DASH19)
], RangeAreaProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate70(POSITIVE_NUMBER27)
], RangeAreaProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate70(OBJECT33)
], RangeAreaProperties.prototype, "interpolation", 2);
__decorateClass([
  Validate70(OBJECT33)
], RangeAreaProperties.prototype, "shadow", 2);
__decorateClass([
  Validate70(OBJECT33)
], RangeAreaProperties.prototype, "marker", 2);
__decorateClass([
  Validate70(OBJECT33)
], RangeAreaProperties.prototype, "label", 2);
__decorateClass([
  Validate70(OBJECT33)
], RangeAreaProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate70(BOOLEAN22)
], RangeAreaProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-enterprise/src/series/range-area/rangeArea.ts
var {
  valueProperty: valueProperty14,
  keyProperty: keyProperty7,
  ChartAxisDirection: ChartAxisDirection22,
  mergeDefaults: mergeDefaults9,
  updateLabelNode,
  fixNumericExtent: fixNumericExtent7,
  buildResetPathFn,
  resetLabelFn: resetLabelFn3,
  resetMarkerFn: resetMarkerFn2,
  resetMarkerPositionFn,
  pathSwipeInAnimation,
  resetMotion: resetMotion3,
  markerSwipeScaleInAnimation,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation5,
  animationValidation: animationValidation7,
  diff: diff6,
  updateClipPath,
  isFiniteNumber: isFiniteNumber5,
  computeMarkerFocusBounds: computeMarkerFocusBounds3,
  plotPath,
  pathRanges,
  pathRangePoints,
  pathRangePointsReverse
} = _ModuleSupport152;
var { getMarker: getMarker5, PointerEvents: PointerEvents9 } = _Scene82;
var { sanitizeHtml: sanitizeHtml11, extent: extent2 } = _Util88;
var RangeAreaSeriesNodeEvent = class extends _ModuleSupport152.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeAreaSeries = class extends _ModuleSupport152.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      hasMarkers: true,
      pathsPerSeries: ["fill", "stroke"],
      directionKeys: {
        [ChartAxisDirection22.X]: ["xKey"],
        [ChartAxisDirection22.Y]: ["yLowKey", "yHighKey"]
      },
      directionNames: {
        [ChartAxisDirection22.X]: ["xName"],
        [ChartAxisDirection22.Y]: ["yLowName", "yHighName", "yName"]
      },
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn3,
        marker: (node, datum) => ({ ...resetMarkerFn2(node), ...resetMarkerPositionFn(node, datum) })
      }
    });
    this.properties = new RangeAreaProperties();
    this.NodeEvent = RangeAreaSeriesNodeEvent;
  }
  async processData(dataController) {
    if (!this.properties.isValid() || !this.visible)
      return;
    const { xKey, yLowKey, yHighKey } = this.properties;
    const xScale = this.axes[ChartAxisDirection22.X]?.scale;
    const yScale = this.axes[ChartAxisDirection22.Y]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      extraProps.push(diff6(this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation7());
    }
    await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty7(xKey, xScaleType, { id: `xValue` }),
        valueProperty14(yLowKey, yScaleType, { id: `yLowValue`, invalidValue: void 0 }),
        valueProperty14(yHighKey, yScaleType, { id: `yHighValue`, invalidValue: void 0 }),
        ...extraProps
      ]
    });
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      }
    } = processedData;
    if (direction === ChartAxisDirection22.X) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent7(extent2(keys));
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue");
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue");
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent7(fixedYExtent);
    }
  }
  async createNodeData() {
    const { data, dataModel, axes, visible } = this;
    const xAxis = axes[ChartAxisDirection22.X];
    const yAxis = axes[ChartAxisDirection22.Y];
    if (!(data && visible && xAxis && yAxis && dataModel)) {
      return;
    }
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yLowKey, yHighKey, connectMissingData, marker } = this.properties;
    const itemId = `${yLowKey}-${yHighKey}`;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`xValue`, `yHighValue`, `yLowValue`]);
    const createCoordinates = (xValue, yHigh, yLow, moveTo2) => {
      const x = xScale.convert(xValue) + xOffset;
      const yHighCoordinate = yScale.convert(yHigh);
      const yLowCoordinate = yScale.convert(yLow);
      const { size } = marker;
      return [
        {
          point: { x, y: yHighCoordinate, moveTo: moveTo2 },
          size,
          itemId: `high`,
          yValue: yHigh,
          xValue,
          enabled: true
        },
        {
          point: { x, y: yLowCoordinate, moveTo: moveTo2 },
          size,
          itemId: `low`,
          yValue: yLow,
          xValue,
          enabled: false
        }
      ];
    };
    const labelData = [];
    const markerData = [];
    const strokeData = { itemId, highPoints: [], lowPoints: [] };
    const fillData = { itemId, highPoints: [], lowPoints: [] };
    const context = {
      itemId,
      labelData,
      nodeData: markerData,
      fillData,
      strokeData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!this.visible)
      return context;
    const fillHighPoints = fillData.highPoints;
    const fillLowPoints = fillData.lowPoints;
    const strokeHighPoints = strokeData.highPoints;
    const strokeLowPoints = strokeData.lowPoints;
    let moveTo = true;
    this.processedData?.data.forEach(({ keys, datum, values }, datumIdx) => {
      const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
      const { xValue, yHighValue, yLowValue } = dataValues;
      const invalidRange = yHighValue == null || yLowValue == null;
      const points = invalidRange ? [] : createCoordinates(xValue, yHighValue, yLowValue, false);
      const inverted = yLowValue > yHighValue;
      points.forEach(({ point: { x, y }, enabled, size, itemId: datumItemId = "", yValue }) => {
        markerData.push({
          index: datumIdx,
          series: this,
          itemId: datumItemId,
          datum,
          midPoint: { x, y },
          yHighValue,
          yLowValue,
          xValue,
          xKey,
          yLowKey,
          yHighKey,
          point: { x, y, size },
          enabled
        });
        const labelDatum = this.createLabelData({
          point: { x, y },
          value: yValue,
          yLowValue,
          yHighValue,
          itemId: datumItemId,
          inverted,
          datum,
          series: this
        });
        labelData.push(labelDatum);
      });
      const xValid = xValue != null;
      const yValid = yHighValue != null && yLowValue != null;
      const [high, low] = createCoordinates(xValue, yHighValue ?? 0, yLowValue ?? 0, moveTo);
      if (xValid && yValid) {
        fillHighPoints.push(high);
        fillLowPoints.push(low);
        strokeHighPoints.push(high);
        strokeLowPoints.push(low);
        moveTo = false;
      } else if (!connectMissingData) {
        moveTo = true;
      }
    });
    return context;
  }
  createLabelData({
    point,
    value,
    itemId,
    inverted,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, label } = this.properties;
    const { placement, padding = 10 } = label;
    let actualItemId = itemId;
    if (inverted) {
      actualItemId = itemId === "low" ? "high" : "low";
    }
    const direction = placement === "outside" && actualItemId === "high" || placement === "inside" && actualItemId === "low" ? -1 : 1;
    return {
      x: point.x,
      y: point.y + padding * direction,
      series,
      itemId,
      datum,
      text: this.getLabelText(
        label,
        { value, datum, itemId, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName },
        (v) => isFiniteNumber5(v) ? v.toFixed(2) : String(v)
      ),
      textAlign: "center",
      textBaseline: direction === -1 ? "bottom" : "top"
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker5(shape);
    return new MarkerShape();
  }
  async updatePathNodes(opts) {
    const { opacity, visible } = opts;
    const [fill, stroke2] = opts.paths;
    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    stroke2.setProperties({
      fill: void 0,
      lineJoin: stroke2.lineCap = "round",
      pointerEvents: PointerEvents9.None,
      stroke: this.properties.stroke,
      strokeWidth,
      strokeOpacity: this.properties.strokeOpacity,
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset,
      opacity,
      visible
    });
    fill.setProperties({
      stroke: void 0,
      lineJoin: "round",
      pointerEvents: PointerEvents9.None,
      fill: this.properties.fill,
      fillOpacity: this.properties.fillOpacity,
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset,
      strokeOpacity: this.properties.strokeOpacity,
      fillShadow: this.properties.shadow,
      strokeWidth,
      opacity,
      visible
    });
    updateClipPath(this, stroke2);
    updateClipPath(this, fill);
  }
  async updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    this.updateFillPath(paths, contextData);
    this.updateStrokePath(paths, contextData);
  }
  updateFillPath(paths, contextData) {
    const { interpolation } = this.properties;
    const { fillData } = contextData;
    const [fill] = paths;
    fill.path.clear();
    for (const range2 of pathRanges(fillData.highPoints)) {
      plotPath(pathRangePoints(fillData.highPoints, range2), fill, interpolation);
      plotPath(pathRangePointsReverse(fillData.lowPoints, range2), fill, interpolation, true);
      fill.path.closePath();
    }
    fill.checkPathDirty();
  }
  updateStrokePath(paths, contextData) {
    const { interpolation } = this.properties;
    const { strokeData } = contextData;
    const [, stroke2] = paths;
    stroke2.path.clear(true);
    for (const range2 of pathRanges(strokeData.highPoints)) {
      plotPath(pathRangePoints(strokeData.highPoints, range2), stroke2, interpolation);
      plotPath(pathRangePoints(strokeData.lowPoints, range2), stroke2, interpolation);
    }
    stroke2.checkPathDirty();
  }
  async updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
  }
  async updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yLowKey, yHighKey, marker, fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity } = this.properties;
    const baseStyle = mergeDefaults9(highlighted && this.properties.highlightStyle.item, marker.getStyle(), {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity
    });
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yHighKey, yLowKey }, baseStyle);
    });
    if (!highlighted) {
      this.properties.marker.markClean();
    }
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = PointerEvents9.None;
    });
  }
  async updateLabelNodes(opts) {
    opts.labelSelection.each((textNode, datum) => {
      updateLabelNode(textNode, this.properties.label, datum);
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItems = nodeData.filter((nodeDatum) => nodeDatum.datum === highlightedItem.datum);
    return highlightItems.length > 0 ? highlightItems : void 0;
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes[ChartAxisDirection22.X];
    const yAxis = this.axes[ChartAxisDirection22.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return _ModuleSupport152.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, fill, tooltip } = this.properties;
    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;
    const color = fill ?? "gray";
    const xString = sanitizeHtml11(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml11(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml11(yAxis.formatDatum(yHighValue));
    const xSubheading = xName ?? xKey;
    const yLowSubheading = yLowName ?? yLowKey;
    const yHighSubheading = yHighName ?? yHighKey;
    const title = sanitizeHtml11(yName);
    const content = yName ? `<b>${sanitizeHtml11(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml11(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml11(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        itemId,
        datum,
        xKey,
        yLowKey,
        yHighKey,
        xName,
        yLowName,
        yHighName,
        yName,
        color,
        title,
        yHighValue,
        yLowValue
      }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      yLowKey,
      yHighKey,
      yName,
      yLowName,
      yHighName,
      fill,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      visible,
      marker
    } = this.properties;
    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: this.id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        symbols: [
          {
            marker: {
              shape: marker.shape,
              fill: marker.fill ?? fill,
              stroke: marker.stroke ?? stroke2,
              fillOpacity: marker.fillOpacity,
              strokeOpacity: marker.strokeOpacity,
              strokeWidth: marker.strokeWidth
            },
            line: {
              stroke: stroke2,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ]
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  nodeFactory() {
    return new _Scene82.Group();
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion3([markerSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation5(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { contextData, paths } = animationData;
    super.animateWaitingUpdateReady(animationData);
    this.updateAreaPaths(paths, contextData);
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yLowKey, yHighKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yLowKey, yHighKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    const hiBox = computeMarkerFocusBounds3(this, opts);
    const loBox = computeMarkerFocusBounds3(this, { ...opts, datumIndex: opts.datumIndex + 1 });
    if (hiBox && loBox) {
      return _Scene82.BBox.merge([hiBox, loBox]);
    }
    return void 0;
  }
};
RangeAreaSeries.className = "RangeAreaSeries";
RangeAreaSeries.type = "range-area";

// packages/ag-charts-enterprise/src/series/range-area/rangeAreaThemes.ts
import { _Theme as _Theme35 } from "ag-charts-community";
var RANGE_AREA_SERIES_THEME = {
  series: {
    fillOpacity: 0.7,
    nodeClickRange: "nearest",
    marker: {
      enabled: false,
      size: 6,
      strokeWidth: 2
    },
    label: {
      enabled: false,
      placement: "outside",
      padding: 10,
      fontSize: 12,
      fontFamily: _Theme35.DEFAULT_FONT_FAMILY,
      color: _Theme35.DEFAULT_LABEL_COLOUR
    },
    interpolation: {
      type: "linear",
      // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work
      tension: 1,
      position: "end"
    }
  },
  axes: {
    [_Theme35.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: { enabled: true }
    }
  }
};

// packages/ag-charts-enterprise/src/series/range-area/rangeAreaModule.ts
var { markerPaletteFactory: markerPaletteFactory2 } = _ModuleSupport153;
var RangeAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-area",
  moduleFactory: (ctx) => new RangeAreaSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: _Theme36.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme36.POSITION.LEFT
    },
    {
      type: _Theme36.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme36.POSITION.BOTTOM
    }
  ],
  themeTemplate: RANGE_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory2(params);
    return {
      fill: marker.fill,
      stroke: marker.stroke,
      marker
    };
  }
};

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarModule.ts
import { _Theme as _Theme38 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarSeries.ts
import { _ModuleSupport as _ModuleSupport155, _Scale as _Scale20, _Scene as _Scene84, _Util as _Util89 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarProperties.ts
import { _ModuleSupport as _ModuleSupport154, _Scene as _Scene83 } from "ag-charts-community";
var { DropShadow: DropShadow2, Label: Label12 } = _Scene83;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties4,
  SeriesTooltip: SeriesTooltip17,
  Validate: Validate71,
  COLOR_STRING: COLOR_STRING27,
  FUNCTION: FUNCTION17,
  LINE_DASH: LINE_DASH20,
  OBJECT: OBJECT34,
  PLACEMENT: PLACEMENT2,
  POSITIVE_NUMBER: POSITIVE_NUMBER28,
  RATIO: RATIO32,
  STRING: STRING34
} = _ModuleSupport154;
var RangeBarSeriesLabel = class extends Label12 {
  constructor() {
    super(...arguments);
    this.placement = "inside";
    this.padding = 6;
  }
};
__decorateClass([
  Validate71(PLACEMENT2)
], RangeBarSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Validate71(POSITIVE_NUMBER28)
], RangeBarSeriesLabel.prototype, "padding", 2);
var RangeBarProperties = class extends AbstractBarSeriesProperties4 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.shadow = new DropShadow2().set({ enabled: false });
    this.label = new RangeBarSeriesLabel();
    this.tooltip = new SeriesTooltip17();
  }
};
__decorateClass([
  Validate71(STRING34)
], RangeBarProperties.prototype, "xKey", 2);
__decorateClass([
  Validate71(STRING34)
], RangeBarProperties.prototype, "yLowKey", 2);
__decorateClass([
  Validate71(STRING34)
], RangeBarProperties.prototype, "yHighKey", 2);
__decorateClass([
  Validate71(STRING34, { optional: true })
], RangeBarProperties.prototype, "xName", 2);
__decorateClass([
  Validate71(STRING34, { optional: true })
], RangeBarProperties.prototype, "yName", 2);
__decorateClass([
  Validate71(STRING34, { optional: true })
], RangeBarProperties.prototype, "yLowName", 2);
__decorateClass([
  Validate71(STRING34, { optional: true })
], RangeBarProperties.prototype, "yHighName", 2);
__decorateClass([
  Validate71(COLOR_STRING27)
], RangeBarProperties.prototype, "fill", 2);
__decorateClass([
  Validate71(RATIO32)
], RangeBarProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate71(COLOR_STRING27)
], RangeBarProperties.prototype, "stroke", 2);
__decorateClass([
  Validate71(POSITIVE_NUMBER28)
], RangeBarProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate71(RATIO32)
], RangeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate71(LINE_DASH20)
], RangeBarProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate71(POSITIVE_NUMBER28)
], RangeBarProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate71(POSITIVE_NUMBER28)
], RangeBarProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate71(FUNCTION17, { optional: true })
], RangeBarProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate71(OBJECT34)
], RangeBarProperties.prototype, "shadow", 2);
__decorateClass([
  Validate71(OBJECT34)
], RangeBarProperties.prototype, "label", 2);
__decorateClass([
  Validate71(OBJECT34)
], RangeBarProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarSeries.ts
var {
  SeriesNodePickMode: SeriesNodePickMode14,
  valueProperty: valueProperty15,
  keyProperty: keyProperty8,
  ChartAxisDirection: ChartAxisDirection23,
  getRectConfig,
  updateRect,
  checkCrisp,
  updateLabelNode: updateLabelNode2,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL3,
  LARGEST_KEY_INTERVAL,
  diff: diff7,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions2,
  midpointStartingBarPosition,
  resetBarSelectionsFn: resetBarSelectionsFn2,
  fixNumericExtent: fixNumericExtent8,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation6,
  resetLabelFn: resetLabelFn4,
  animationValidation: animationValidation8,
  createDatumId: createDatumId10,
  isFiniteNumber: isFiniteNumber6,
  computeBarFocusBounds: computeBarFocusBounds5
} = _ModuleSupport155;
var { Rect: Rect6, PointerEvents: PointerEvents10, motion: motion8 } = _Scene84;
var { sanitizeHtml: sanitizeHtml12, isNumber: isNumber3 } = _Util89;
var { ContinuousScale: ContinuousScale4 } = _Scale20;
var RangeBarSeriesNodeEvent = class extends _ModuleSupport155.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeBarSeries = class extends _ModuleSupport155.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode14.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode14.EXACT_SHAPE_MATCH],
      hasHighlightedLabels: true,
      directionKeys: {
        x: ["xKey"],
        y: ["yLowKey", "yHighKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["yLowName", "yHighName", "yName"]
      },
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn2,
        label: resetLabelFn4
      }
    });
    this.properties = new RangeBarProperties();
    this.NodeEvent = RangeBarSeriesNodeEvent;
  }
  async processData(dataController) {
    if (!this.properties.isValid()) {
      return;
    }
    const { xKey, yLowKey, yHighKey } = this.properties;
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      if (this.processedData) {
        extraProps.push(diff7(this.processedData));
      }
      extraProps.push(animationValidation8());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const { processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty8(xKey, xScaleType, { id: "xValue" }),
        valueProperty15(yLowKey, yScaleType, { id: `yLowValue`, ...visibleProps }),
        valueProperty15(yHighKey, yScaleType, { id: `yHighValue`, ...visibleProps }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL3, LARGEST_KEY_INTERVAL] : [],
        ...extraProps
      ],
      groupByKeys: true
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys],
      values
    } = processedData.domain;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef?.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue");
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue");
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent8(fixedYExtent);
    }
  }
  async createNodeData() {
    const {
      data,
      dataModel,
      groupScale,
      processedData,
      properties: { visible }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(data && xAxis && yAxis && dataModel)) {
      return;
    }
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const barAlongX = this.getBarDirection() === ChartAxisDirection23.X;
    const { xKey, yLowKey, yHighKey, fill, stroke: stroke2, strokeWidth } = this.properties;
    const itemId = `${yLowKey}-${yHighKey}`;
    const context = {
      itemId,
      nodeData: [],
      labelData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!visible)
      return context;
    const yLowIndex = dataModel.resolveProcessedDataIndexById(this, `yLowValue`);
    const yHighIndex = dataModel.resolveProcessedDataIndexById(this, `yHighValue`);
    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale4.is(xScale) ? barWidth * -0.5 : 0;
    processedData?.data.forEach(({ keys, datum, values }, dataIndex) => {
      values.forEach((value, valueIndex) => {
        const xDatum = keys[xIndex];
        const x = Math.round(xScale.convert(xDatum)) + groupScale.convert(String(groupIndex)) + barOffset;
        const rawLowValue = value[yLowIndex];
        const rawHighValue = value[yHighIndex];
        const yLowValue = Math.min(rawLowValue, rawHighValue);
        const yHighValue = Math.max(rawLowValue, rawHighValue);
        const yLow = Math.round(yScale.convert(yLowValue));
        const yHigh = Math.round(yScale.convert(yHighValue));
        const y = yHigh;
        const bottomY = yLow;
        const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
        const rect = {
          x: barAlongX ? Math.min(y, bottomY) : x,
          y: barAlongX ? x : Math.min(y, bottomY),
          width: barAlongX ? barHeight : barWidth,
          height: barAlongX ? barWidth : barHeight
        };
        const nodeMidPoint = {
          x: rect.x + rect.width / 2,
          y: rect.y + rect.height / 2
        };
        const labelData = this.createLabelData({
          rect,
          barAlongX,
          yLowValue,
          yHighValue,
          datum: datum[valueIndex],
          series: this
        });
        const nodeDatum = {
          index: dataIndex,
          valueIndex,
          series: this,
          itemId,
          datum: datum[valueIndex],
          xValue: xDatum,
          yLowValue: rawLowValue,
          yHighValue: rawHighValue,
          yLowKey,
          yHighKey,
          xKey,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          midPoint: nodeMidPoint,
          fill,
          stroke: stroke2,
          strokeWidth,
          opacity: 1,
          labels: labelData
        };
        context.nodeData.push(nodeDatum);
        context.labelData.push(...labelData);
      });
    });
    return context;
  }
  createLabelData({
    rect,
    barAlongX,
    yLowValue,
    yHighValue,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, label } = this.properties;
    const labelParams = { datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName };
    const { placement, padding } = label;
    const paddingDirection = placement === "outside" ? 1 : -1;
    const labelPadding = padding * paddingDirection;
    const yLowLabel = {
      x: rect.x + (barAlongX ? -labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : rect.height + labelPadding),
      textAlign: barAlongX ? "left" : "center",
      textBaseline: barAlongX ? "middle" : "bottom",
      text: this.getLabelText(
        label,
        { itemId: "low", value: yLowValue, ...labelParams },
        (v) => isFiniteNumber6(v) ? v.toFixed(2) : String(v)
      ),
      itemId: "low",
      datum,
      series
    };
    const yHighLabel = {
      x: rect.x + (barAlongX ? rect.width + labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : -labelPadding),
      textAlign: barAlongX ? "right" : "center",
      textBaseline: barAlongX ? "middle" : "top",
      text: this.getLabelText(
        label,
        { itemId: "high", value: yHighValue, ...labelParams },
        (value) => isNumber3(value) ? value.toFixed(2) : ""
      ),
      itemId: "high",
      datum,
      series
    };
    if (placement === "outside") {
      yLowLabel.textAlign = barAlongX ? "right" : "center";
      yLowLabel.textBaseline = barAlongX ? "middle" : "top";
      yHighLabel.textAlign = barAlongX ? "left" : "center";
      yHighLabel.textBaseline = barAlongX ? "middle" : "bottom";
    }
    return [yLowLabel, yHighLabel];
  }
  nodeFactory() {
    return new Rect6();
  }
  async updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));
  }
  async updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { id: seriesId, ctx } = this;
    const {
      yLowKey,
      yHighKey,
      highlightStyle: { item: itemHighlightStyle }
    } = this.properties;
    const xAxis = this.axes[ChartAxisDirection23.X];
    const crisp = checkCrisp(
      xAxis?.scale,
      xAxis?.visibleRange,
      this.smallestDataInterval,
      this.largestDataInterval
    );
    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection23.X;
    datumSelection.each((rect, datum) => {
      const {
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        itemStyler,
        shadow: fillShadow
      } = this.properties;
      const style = {
        fill: datum.fill,
        stroke: datum.stroke,
        fillOpacity,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        fillShadow,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        cornerRadius: this.properties.cornerRadius
      };
      const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
      const config = getRectConfig({
        datum,
        isHighlighted: isHighlight,
        style,
        highlightStyle: itemHighlightStyle,
        itemStyler,
        seriesId,
        ctx,
        yLowKey,
        yHighKey
      });
      config.crisp = crisp;
      config.visible = visible;
      updateRect(rect, config);
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  async updateLabelSelection(opts) {
    const labelData = this.properties.label.enabled ? opts.labelData : [];
    return opts.labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = PointerEvents10.None;
    });
  }
  async updateLabelNodes(opts) {
    opts.labelSelection.each((textNode, datum) => {
      updateLabelNode2(textNode, this.properties.label, datum);
    });
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return _ModuleSupport155.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      xKey,
      yLowKey,
      yHighKey,
      xName,
      yLowName,
      yHighName,
      yName,
      fill,
      strokeWidth,
      itemStyler,
      tooltip,
      fillOpacity,
      stroke: stroke2,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius
    } = this.properties;
    const { datum, xValue, yLowValue, yHighValue } = nodeDatum;
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        highlighted: false,
        seriesId,
        datum,
        xKey,
        yLowKey,
        yHighKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius
      });
    }
    const color = format?.fill ?? fill ?? "gray";
    const xString = sanitizeHtml12(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml12(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml12(yAxis.formatDatum(yHighValue));
    const xSubheading = xName ?? xKey;
    const yLowSubheading = yLowName ?? yLowKey;
    const yHighSubheading = yHighName ?? yHighKey;
    const title = sanitizeHtml12(yName);
    const content = yName ? `<b>${sanitizeHtml12(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml12(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml12(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    const defaults = {
      title,
      content,
      backgroundColor: color
    };
    return tooltip.toTooltipHtml(defaults, {
      itemId: void 0,
      datum,
      xKey,
      xName,
      yLowKey,
      yLowName,
      yHighKey,
      yHighName,
      yName,
      color,
      seriesId,
      title
    });
  }
  getLegendData(legendType) {
    const { id, visible } = this;
    if (legendType !== "category") {
      return [];
    }
    const { fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity, yName, yLowName, yHighName, yLowKey, yHighKey } = this.properties;
    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;
    return [
      {
        legendType: "category",
        id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        symbols: [{ marker: { fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth } }]
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition(this.isVertical(), "normal"));
    motion8.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection: datumSelections, labelSelection: labelSelections } = data;
    const { processedData } = this;
    const dataDiff = processedData?.reduced?.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition(this.isVertical(), "fade"));
    motion8.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelections],
      fns,
      (_, datum) => createDatumId10(datum.xValue, datum.valueIndex),
      dataDiff
    );
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelections);
  }
  getDatumId(datum) {
    return `${datum.xValue}-${datum.valueIndex}`;
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    return computeBarFocusBounds5(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
RangeBarSeries.className = "RangeBarSeries";
RangeBarSeries.type = "range-bar";

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarThemes.ts
import { _Theme as _Theme37 } from "ag-charts-community";
var RANGE_BAR_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: _Theme37.DEFAULT_FONT_FAMILY,
      color: _Theme37.DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      placement: "inside"
    }
  },
  axes: {
    [_Theme37.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: { enabled: true }
    }
  }
};

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarModule.ts
var RangeBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-bar",
  moduleFactory: (ctx) => new RangeBarSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme38.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme38.POSITION.BOTTOM
    },
    {
      type: _Theme38.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme38.POSITION.LEFT
    }
  ],
  themeTemplate: RANGE_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke2]
    } = takeColors(1);
    return {
      fill,
      stroke: stroke2
    };
  },
  groupable: true,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};

// packages/ag-charts-enterprise/src/series/sankey/sankeyModule.ts
import { _Theme as _Theme39 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/sankey/sankeySeries.ts
import {
  _ModuleSupport as _ModuleSupport157,
  _Scene as _Scene87,
  _Util as _Util91
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/sankey/sankeyLayout.ts
function sortNodesByY(column) {
  column.nodes.sort((a, b) => Math.round((a.datum.y - b.datum.y) * 100) / 100 || -(a.datum.size - b.datum.size));
}
function justifyNodesAcrossColumn({ nodes, size }, { seriesRectHeight, nodeSpacing, sizeScale }) {
  const nodesHeight = seriesRectHeight * size * sizeScale;
  const outerPadding = (seriesRectHeight - (nodesHeight + nodeSpacing * (nodes.length - 1))) / 2;
  let y = outerPadding;
  nodes.forEach(({ datum: node }) => {
    const height = seriesRectHeight * node.size * sizeScale;
    node.y = y;
    node.height = height;
    y += height + nodeSpacing;
  });
}
function separateNodesInColumn(column, layout) {
  const { nodes } = column;
  const { seriesRectHeight, nodeSpacing } = layout;
  sortNodesByY(column);
  let totalShift = 0;
  let currentTop = 0;
  for (let i = 0; i < nodes.length; i += 1) {
    const { datum: node } = nodes[i];
    const shift = Math.max(currentTop - node.y, 0);
    node.y += shift;
    totalShift += shift;
    currentTop = node.y + node.height + nodeSpacing;
  }
  const lastNodeBottom = currentTop - nodeSpacing;
  if (lastNodeBottom < seriesRectHeight) {
    return totalShift > 0;
  }
  let currentBottom = seriesRectHeight;
  for (let i = nodes.length - 1; i >= 0; i -= 1) {
    const { datum: node } = nodes[i];
    const nodeBottom = node.y + node.height;
    const shift = Math.min(currentBottom - nodeBottom, 0);
    node.y += shift;
    totalShift += shift;
    currentBottom = node.y - nodeSpacing;
  }
  return true;
}
function hasCrossOver(x00, y00, x01, y01, x10, y10, x11, y11) {
  const recM0 = (x01 - x00) / (y01 - y00);
  const recM1 = (x11 - x10) / (y11 - y10);
  const x = ((y10 - y00) * (recM0 * recM1) + x00 * recM1 - x10 * recM0) / (recM1 - recM0);
  if (x00 < x01) {
    return x > x00 && x < Math.min(x01, x11);
  } else {
    return x < x00 && x > Math.max(x01, x11);
  }
}
function removeColumnCrossoversInDirection(column, getLinks) {
  let didShift = false;
  const singleCrossoverColumns = column.nodes.filter((node) => getLinks(node).length === 1);
  let didRemoveCrossover = true;
  for (let runs = 0; didRemoveCrossover && runs < singleCrossoverColumns.length; runs += 1) {
    didRemoveCrossover = false;
    for (let i = 0; i < singleCrossoverColumns.length - 1; i += 1) {
      const { datum: node } = singleCrossoverColumns[i];
      const nodeAfter = getLinks(singleCrossoverColumns[i])[0].node.datum;
      const { datum: otherNode } = singleCrossoverColumns[i + 1];
      const otherNodeAfter = getLinks(singleCrossoverColumns[i + 1])[0].node.datum;
      const crossover = hasCrossOver(
        node.x,
        node.y,
        nodeAfter.x,
        nodeAfter.y,
        otherNode.x,
        otherNode.y,
        otherNodeAfter.x,
        otherNodeAfter.y
      ) || hasCrossOver(
        node.x,
        node.y + node.height / 2,
        nodeAfter.x,
        nodeAfter.y + nodeAfter.height / 2,
        otherNode.x,
        otherNode.y + otherNode.height / 2,
        otherNodeAfter.x,
        otherNodeAfter.y + otherNodeAfter.height / 2
      ) || hasCrossOver(
        node.x,
        node.y + node.height,
        nodeAfter.x,
        nodeAfter.y + nodeAfter.height,
        otherNode.x,
        otherNode.y + otherNode.height,
        otherNodeAfter.x,
        otherNodeAfter.y + otherNodeAfter.height
      );
      if (!crossover)
        continue;
      const current = singleCrossoverColumns[i];
      singleCrossoverColumns[i] = singleCrossoverColumns[i + 1];
      singleCrossoverColumns[i + 1] = current;
      const y = node.y;
      node.y = otherNode.y + otherNode.height - node.height;
      otherNode.y = y;
      didShift = true;
      didRemoveCrossover = true;
    }
  }
  return didShift;
}
function removeColumnCrossovers(column) {
  let didShift = false;
  sortNodesByY(column);
  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksBefore) || didShift;
  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksAfter) || didShift;
  return didShift;
}
function weightedNodeY(links) {
  if (links.length === 0)
    return;
  let totalYValues = 0;
  let totalSize = 0;
  for (const {
    node: { datum: node }
  } of links) {
    totalYValues += node.y * node.size;
    totalSize += node.size;
  }
  return totalYValues / totalSize;
}
function layoutColumn(column, layout, weight, direction) {
  column.nodes.forEach(({ datum: node, linksBefore, linksAfter }) => {
    const forwardLinks = direction === 1 ? linksBefore : linksAfter;
    const backwardsLinks = direction === 1 ? linksAfter : linksBefore;
    const nextY = weightedNodeY(forwardLinks);
    if (nextY != null) {
      const nodeWeight = backwardsLinks.length !== 0 ? weight : 1;
      node.y = node.y + (nextY - node.y) * nodeWeight;
    }
  });
  return separateNodesInColumn(column, layout);
}
function layoutColumnsForward(columns, layout, weight) {
  let didShift = false;
  for (let i = 0; i < columns.length; i += 1) {
    didShift = layoutColumn(columns[i], layout, weight, 1) || didShift;
  }
  return didShift;
}
function layoutColumnsBackwards(columns, layout, weight) {
  let didShift = false;
  for (let i = columns.length - 1; i >= 0; i -= 1) {
    didShift = layoutColumn(columns[i], layout, weight, -1) || didShift;
  }
  return didShift;
}
function removeColumnsCrossovers(columns) {
  let didShift = false;
  for (let i = columns.length - 1; i >= 0; i -= 1) {
    didShift = removeColumnCrossovers(columns[i]) || didShift;
  }
  return didShift;
}
function layoutColumns(columns, layout) {
  columns.forEach((column) => {
    justifyNodesAcrossColumn(column, layout);
  });
  let didLayoutColumnsBackwards = false;
  for (let i = 0; i < 6; i += 1) {
    const didLayoutColumnsForward = layoutColumnsForward(columns, layout, 1);
    didLayoutColumnsBackwards = layoutColumnsBackwards(columns, layout, 0.5);
    const didRemoveColumnCrossovers = removeColumnsCrossovers(columns);
    if (!didLayoutColumnsForward && !didLayoutColumnsBackwards && !didRemoveColumnCrossovers) {
      break;
    }
  }
  if (didLayoutColumnsBackwards) {
    layoutColumnsForward(columns, layout, 1);
    removeColumnsCrossovers(columns);
  }
}

// packages/ag-charts-enterprise/src/series/sankey/sankeyLink.ts
import { _Scene as _Scene85 } from "ag-charts-community";
var { BBox: BBox13, Path: Path9, ScenePathChangeDetection: ScenePathChangeDetection3, splitBezier } = _Scene85;
function offsetTrivialCubicBezier(path, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, offset) {
  let tx, ty;
  if (p1y !== p0y && p3y !== p2y) {
    const slope1 = -(p1x - p0x) / (p1y - p0y);
    const slope2 = -(p3x - p2x) / (p3y - p2y);
    tx = (p2y - p0y + slope1 * p0x - slope2 * p2x) / (slope1 - slope2);
    ty = slope1 * (tx - p0x) + p0y;
  } else if (p1y === p0y && p3y !== p2y) {
    tx = p0x;
    const slope2 = -(p3x - p2x) / (p3y - p2y);
    ty = slope2 * (tx - p3x) + p3y;
  } else if (p1y !== p0y && p3y === p2y) {
    tx = p3x;
    const slope1 = -(p1x - p0x) / (p1y - p0y);
    ty = slope1 * (tx - p0x) + p0y;
  } else {
    throw new Error("Offsetting flat bezier curve");
  }
  const d0 = Math.hypot(p0y - ty, p0x - tx);
  const s0 = (d0 + offset) / d0;
  const d1 = Math.hypot(p3y - ty, p3x - tx);
  const s1 = (d1 + offset) / d1;
  const q1x = tx + (p1x - tx) * s0;
  const q1y = ty + (p1y - ty) * s0;
  const q2x = tx + (p2x - tx) * s1;
  const q2y = ty + (p2y - ty) * s1;
  const q3x = tx + (p3x - tx) * s1;
  const q3y = ty + (p3y - ty) * s1;
  path.cubicCurveTo(q1x, q1y, q2x, q2y, q3x, q3y);
}
var SankeyLink = class extends Path9 {
  constructor() {
    super(...arguments);
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.height = 0;
    this.inset = 0;
  }
  computeBBox() {
    const x = Math.min(this.x1, this.x2);
    const width = Math.max(this.x1, this.x2) - x;
    const y = Math.min(this.y1, this.y2);
    const height = Math.max(this.y1, this.y2) - y + this.height;
    return new BBox13(x, y, width, height);
  }
  updatePath() {
    const { path, inset } = this;
    path.clear();
    const x1 = this.x1 + inset;
    const x2 = this.x2 - inset;
    const y1 = this.y1 + inset;
    const y2 = this.y2 + inset;
    const height = this.height - 2 * inset;
    if (height < 0 || x1 > x2)
      return;
    const p0x = x1;
    const p0y = y1 + height / 2;
    const p1x = (x1 + x2) / 2;
    const p1y = y1 + height / 2;
    const p2x = (x1 + x2) / 2;
    const p2y = y2 + height / 2;
    const p3x = x2;
    const p3y = y2 + height / 2;
    path.moveTo(p0x, p0y - height / 2);
    if (Math.abs(this.y2 - this.y1) < 1 || this.x2 - this.x1 < this.height * Math.SQRT2) {
      path.cubicCurveTo(p1x, p1y - height / 2, p2x, p2y - height / 2, p3x, p3y - height / 2);
      path.lineTo(p3x, p3y + height / 2);
      path.cubicCurveTo(p2x, p2y + height / 2, p1x, p1y + height / 2, p0x, p0y + height / 2);
    } else {
      const [a, b] = splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, 0.5);
      const offset = (y2 > y1 ? 1 : -1) * height / 2;
      offsetTrivialCubicBezier(path, a[0].x, a[0].y, a[1].x, a[1].y, a[2].x, a[2].y, a[3].x, a[3].y, offset);
      offsetTrivialCubicBezier(path, b[0].x, b[0].y, b[1].x, b[1].y, b[2].x, b[2].y, b[3].x, b[3].y, -offset);
      path.lineTo(p3x, p3y + height / 2);
      offsetTrivialCubicBezier(path, b[3].x, b[3].y, b[2].x, b[2].y, b[1].x, b[1].y, b[0].x, b[0].y, offset);
      offsetTrivialCubicBezier(path, a[3].x, a[3].y, a[2].x, a[2].y, a[1].x, a[1].y, a[0].x, a[0].y, -offset);
    }
    path.closePath();
  }
};
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "x1", 2);
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "x2", 2);
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "y1", 2);
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "y2", 2);
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "height", 2);
__decorateClass([
  ScenePathChangeDetection3()
], SankeyLink.prototype, "inset", 2);

// packages/ag-charts-enterprise/src/series/sankey/sankeySeriesProperties.ts
import {
  _ModuleSupport as _ModuleSupport156,
  _Scene as _Scene86
} from "ag-charts-community";
var {
  BaseProperties: BaseProperties26,
  SeriesTooltip: SeriesTooltip18,
  SeriesProperties: SeriesProperties12,
  ARRAY: ARRAY10,
  COLOR_STRING: COLOR_STRING28,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY8,
  FUNCTION: FUNCTION18,
  LINE_DASH: LINE_DASH21,
  OBJECT: OBJECT35,
  POSITIVE_NUMBER: POSITIVE_NUMBER29,
  RATIO: RATIO33,
  STRING: STRING35,
  UNION: UNION10,
  Validate: Validate72
} = _ModuleSupport156;
var { Label: Label13 } = _Scene86;
var ALIGNMENT = UNION10(["left", "right", "center", "justify"], "a justification value");
var SankeySeriesLabelProperties = class extends Label13 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
  }
};
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesLabelProperties.prototype, "spacing", 2);
var SankeySeriesLinkProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate72(COLOR_STRING28, { optional: true })
], SankeySeriesLinkProperties.prototype, "fill", 2);
__decorateClass([
  Validate72(RATIO33)
], SankeySeriesLinkProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate72(COLOR_STRING28, { optional: true })
], SankeySeriesLinkProperties.prototype, "stroke", 2);
__decorateClass([
  Validate72(RATIO33)
], SankeySeriesLinkProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesLinkProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate72(LINE_DASH21)
], SankeySeriesLinkProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesLinkProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate72(FUNCTION18, { optional: true })
], SankeySeriesLinkProperties.prototype, "itemStyler", 2);
var SankeySeriesNodeProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.width = 1;
    this.alignment = "justify";
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesNodeProperties.prototype, "spacing", 2);
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesNodeProperties.prototype, "width", 2);
__decorateClass([
  Validate72(ALIGNMENT)
], SankeySeriesNodeProperties.prototype, "alignment", 2);
__decorateClass([
  Validate72(COLOR_STRING28, { optional: true })
], SankeySeriesNodeProperties.prototype, "fill", 2);
__decorateClass([
  Validate72(RATIO33)
], SankeySeriesNodeProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate72(COLOR_STRING28, { optional: true })
], SankeySeriesNodeProperties.prototype, "stroke", 2);
__decorateClass([
  Validate72(RATIO33)
], SankeySeriesNodeProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesNodeProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate72(LINE_DASH21)
], SankeySeriesNodeProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate72(POSITIVE_NUMBER29)
], SankeySeriesNodeProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate72(FUNCTION18, { optional: true })
], SankeySeriesNodeProperties.prototype, "itemStyler", 2);
var SankeySeriesProperties = class extends SeriesProperties12 {
  constructor() {
    super(...arguments);
    this.nodes = void 0;
    this.idKey = "";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.sizeKey = void 0;
    this.sizeName = void 0;
    this.fills = [];
    this.strokes = [];
    this.label = new SankeySeriesLabelProperties();
    this.link = new SankeySeriesLinkProperties();
    this.node = new SankeySeriesNodeProperties();
    this.tooltip = new SeriesTooltip18();
  }
};
__decorateClass([
  Validate72(ARRAY10, { optional: true })
], SankeySeriesProperties.prototype, "nodes", 2);
__decorateClass([
  Validate72(STRING35)
], SankeySeriesProperties.prototype, "fromKey", 2);
__decorateClass([
  Validate72(STRING35)
], SankeySeriesProperties.prototype, "toKey", 2);
__decorateClass([
  Validate72(STRING35)
], SankeySeriesProperties.prototype, "idKey", 2);
__decorateClass([
  Validate72(STRING35, { optional: true })
], SankeySeriesProperties.prototype, "idName", 2);
__decorateClass([
  Validate72(STRING35, { optional: true })
], SankeySeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate72(STRING35, { optional: true })
], SankeySeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate72(STRING35, { optional: true })
], SankeySeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate72(STRING35, { optional: true })
], SankeySeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate72(COLOR_STRING_ARRAY8)
], SankeySeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate72(COLOR_STRING_ARRAY8)
], SankeySeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate72(OBJECT35)
], SankeySeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate72(OBJECT35)
], SankeySeriesProperties.prototype, "link", 2);
__decorateClass([
  Validate72(OBJECT35)
], SankeySeriesProperties.prototype, "node", 2);
__decorateClass([
  Validate72(OBJECT35)
], SankeySeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/sankey/sankeySeries.ts
var { SeriesNodePickMode: SeriesNodePickMode15, CachedTextMeasurerPool: CachedTextMeasurerPool8, TextWrapper: TextWrapper6, createDatumId: createDatumId11, EMPTY_TOOLTIP_CONTENT: EMPTY_TOOLTIP_CONTENT4 } = _ModuleSupport157;
var { sanitizeHtml: sanitizeHtml13 } = _Util91;
var { Rect: Rect7, Text: Text9, BBox: BBox14 } = _Scene87;
var SankeySeries = class extends FlowProportionSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      pickModes: [SeriesNodePickMode15.NEAREST_NODE, SeriesNodePickMode15.EXACT_SHAPE_MATCH]
    });
    this.properties = new SankeySeriesProperties();
  }
  isLabelEnabled() {
    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;
  }
  linkFactory() {
    return new SankeyLink();
  }
  nodeFactory() {
    return new Rect7();
  }
  async createNodeData() {
    const {
      id: seriesId,
      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 }
    } = this;
    const {
      fromKey,
      toKey,
      sizeKey,
      label: { spacing: labelSpacing },
      node: { spacing: nodeSpacing, width: nodeWidth, alignment }
    } = this.properties;
    const defaultLabelFormatter = (v) => String(v);
    const {
      nodeGraph: baseNodeGraph,
      links,
      maxPathLength
    } = this.getNodeGraph(
      (node) => {
        const label = this.getLabelText(
          this.properties.label,
          {
            datum: node.datum,
            value: node.label,
            fromKey,
            toKey,
            sizeKey
          },
          defaultLabelFormatter
        );
        return {
          ...node,
          label,
          size: 0,
          x: NaN,
          y: NaN,
          width: nodeWidth,
          height: NaN
        };
      },
      (link) => ({
        ...link,
        x1: NaN,
        x2: NaN,
        y1: NaN,
        y2: NaN,
        height: NaN
      }),
      { includeCircularReferences: false }
    );
    const nodeGraph = baseNodeGraph;
    const inset = this.isLabelEnabled() ? (seriesRectWidth - nodeWidth) * (1 - maxPathLength / (maxPathLength + 1)) : 0;
    const columnWidth = (seriesRectWidth - nodeWidth - 2 * inset) / (maxPathLength - 1);
    const columns = [];
    for (let index = 0; index < maxPathLength; index += 1) {
      const x = inset + index * columnWidth;
      columns.push({ index, size: 0, nodes: [], x });
    }
    nodeGraph.forEach((graphNode) => {
      const { datum: node, linksBefore, linksAfter, maxPathLengthBefore, maxPathLengthAfter } = graphNode;
      const size = Math.max(
        linksBefore.reduce((acc, { link }) => acc + link.size, 0),
        linksAfter.reduce((acc, { link }) => acc + link.size, 0)
      );
      if (linksBefore.length === 0 && linksAfter.length === 0 || size === 0) {
        graphNode.columnIndex = -1;
        return;
      }
      let column;
      switch (alignment) {
        case "left":
          column = columns[maxPathLengthBefore];
          break;
        case "right":
          column = columns[maxPathLength - 1 - maxPathLengthAfter];
          break;
        case "center": {
          if (linksBefore.length !== 0) {
            column = columns[maxPathLengthBefore];
          } else if (linksAfter.length !== 0) {
            const columnIndex = linksAfter.reduce(
              (acc, link) => Math.min(acc, link.node.maxPathLengthBefore),
              maxPathLength
            ) - 1;
            column = columns[columnIndex];
          } else {
            column = columns[0];
          }
          break;
        }
        case "justify": {
          column = linksAfter.length === 0 ? columns[maxPathLength - 1] : columns[maxPathLengthBefore];
          break;
        }
      }
      node.x = column.x;
      node.size = size;
      column.nodes.push(graphNode);
      column.size += size;
      graphNode.columnIndex = column.index;
    });
    nodeGraph.forEach((graphNode) => {
      let closestColumnIndex = Infinity;
      let maxSizeOfClosestNodesAfter = 0;
      graphNode.linksAfter.forEach((link) => {
        const node = link.node;
        const { columnIndex } = node;
        if (columnIndex < closestColumnIndex) {
          closestColumnIndex = columnIndex;
          maxSizeOfClosestNodesAfter = node.datum.size;
        } else if (columnIndex === closestColumnIndex) {
          maxSizeOfClosestNodesAfter = Math.max(maxSizeOfClosestNodesAfter, node.datum.size);
        }
      });
      graphNode.closestColumnIndex = closestColumnIndex;
      graphNode.maxSizeOfClosestNodesAfter = maxSizeOfClosestNodesAfter;
    });
    const sizeScale = columns.reduce((acc, { size, nodes }) => {
      const columnSizeScale = (1 - (nodes.length - 1) * (nodeSpacing / seriesRectHeight)) / size;
      return Math.min(acc, columnSizeScale);
    }, Infinity);
    for (let i = columns.length - 1; i >= 0; i -= 1) {
      const nodes = columns[i].nodes;
      nodes.sort(
        (a, b) => a.closestColumnIndex - b.closestColumnIndex || a.maxSizeOfClosestNodesAfter - b.maxSizeOfClosestNodesAfter || a.datum.size - b.datum.size
      );
    }
    layoutColumns(columns, {
      seriesRectHeight,
      nodeSpacing,
      sizeScale
    });
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {
      const bottom = node.y + node.height;
      const sortNodes = (l) => {
        return l.sort((a, b) => {
          const aNode = a.node.datum;
          const bNode = b.node.datum;
          const aBottom = aNode.y + aNode.height;
          const bBottom = bNode.y + bNode.height;
          const dAngleTop = Math.atan2(aNode.y - node.y, Math.abs(aNode.x - node.x)) - Math.atan2(bNode.y - node.y, Math.abs(bNode.x - node.x));
          const dAngleBottom = Math.atan2(aBottom - bottom, Math.abs(aNode.x - node.x)) - Math.atan2(bBottom - bottom, Math.abs(bNode.x - node.x));
          return dAngleTop + dAngleBottom;
        });
      };
      let y2 = node.y;
      sortNodes(linksBefore).forEach(({ link }) => {
        link.y2 = y2;
        y2 += link.size * seriesRectHeight * sizeScale;
      });
      let y1 = node.y;
      sortNodes(linksAfter).forEach(({ link }) => {
        link.y1 = y1;
        y1 += link.size * seriesRectHeight * sizeScale;
      });
    });
    const nodeData = [];
    const labelData = [];
    const { fontSize } = this.properties.label;
    const canvasFont = this.properties.label.getFont();
    columns.forEach((column, index) => {
      const leading = index === 0;
      const trailing = index === columns.length - 1;
      let bottom = -Infinity;
      column.nodes.sort((a, b) => a.datum.y - b.datum.y);
      column.nodes.forEach(({ datum: node }) => {
        node.midPoint = {
          x: node.x + node.width / 2,
          y: node.y + node.height / 2
        };
        nodeData.push(node);
        if (node.label == null)
          return;
        const x = leading ? node.x - labelSpacing : node.x + node.width + labelSpacing;
        const y = node.y + node.height / 2;
        let text2;
        if (!leading && !trailing) {
          const y12 = y - fontSize * Text9.defaultLineHeightRatio;
          const y2 = y + fontSize * Text9.defaultLineHeightRatio;
          let maxX = seriesRectWidth;
          nodeGraph.forEach(({ datum }) => {
            const intersectsLabel = datum.x > node.x && Math.max(datum.y, y12) <= Math.min(datum.y + datum.height, y2);
            if (intersectsLabel) {
              maxX = Math.min(maxX, datum.x - labelSpacing);
            }
          });
          const maxWidth = maxX - node.x - 2 * labelSpacing;
          text2 = TextWrapper6.wrapText(node.label, {
            maxWidth,
            maxHeight: node.height,
            font: this.properties.label,
            textWrap: "never",
            overflow: "hide"
          });
        }
        if (text2 == null || text2 === "") {
          const labelInset = leading || trailing ? labelSpacing : labelSpacing * 2;
          text2 = TextWrapper6.wrapText(node.label, {
            maxWidth: columnWidth - labelInset,
            maxHeight: node.height,
            font: this.properties.label,
            textWrap: "never"
          });
        }
        if (text2 === "")
          return;
        const { height } = CachedTextMeasurerPool8.measureText(text2, {
          font: canvasFont,
          textAlign: "left",
          textBaseline: "middle"
        });
        const y0 = y - height / 2;
        const y1 = y + height / 2;
        if (y0 >= bottom) {
          labelData.push({ x, y, leading, text: text2 });
          bottom = y1;
        }
      });
    });
    links.forEach((link) => {
      const { fromNode, toNode, size } = link;
      link.height = seriesRectHeight * size * sizeScale;
      link.x1 = fromNode.x + nodeWidth;
      link.x2 = toNode.x;
      link.midPoint = {
        x: (link.x1 + link.x2) / 2,
        y: (link.y1 + link.y2) / 2 + link.height / 2
      };
      nodeData.push(link);
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  async updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
    labelSelection.each((label, { x, y, leading, text: text2 }) => {
      label.visible = true;
      label.x = x;
      label.y = y;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = leading ? "right" : "left";
      label.textBaseline = "middle";
    });
  }
  async updateNodeSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId11([datum.type, datum.id]));
  }
  async updateNodeNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { fromKey, toKey, sizeKey } = this.properties;
    const {
      fill: baseFill,
      fillOpacity,
      stroke: baseStroke,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      itemStyler
    } = this.properties.node;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.node.strokeWidth);
    datumSelection.each((rect, datum) => {
      const fill = baseFill ?? datum.fill;
      const stroke2 = baseStroke ?? datum.stroke;
      let format;
      if (itemStyler != null) {
        const { label, size } = datum;
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          label,
          size,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: isHighlight
        });
      }
      rect.x = datum.x;
      rect.y = datum.y;
      rect.width = datum.width;
      rect.height = datum.height;
      rect.fill = highlightStyle?.fill ?? format?.fill ?? fill;
      rect.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      rect.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      rect.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      rect.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;
      rect.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      rect.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
    });
  }
  async updateLinkSelection(opts) {
    return opts.datumSelection.update(
      opts.nodeData,
      void 0,
      (datum) => createDatumId11([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])
    );
  }
  async updateLinkNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { fromKey, toKey, sizeKey } = properties;
    const {
      fill: baseFill,
      fillOpacity,
      stroke: baseStroke,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      itemStyler
    } = properties.link;
    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
    const strokeWidth = this.getStrokeWidth(properties.link.strokeWidth);
    datumSelection.each((link, datum) => {
      const fill = baseFill ?? datum.fromNode.fill;
      const stroke2 = baseStroke ?? datum.fromNode.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: isHighlight
        });
      }
      link.x1 = datum.x1;
      link.y1 = datum.y1;
      link.x2 = datum.x2;
      link.y2 = datum.y2;
      link.height = datum.height;
      link.fill = highlightStyle?.fill ?? format?.fill ?? fill;
      link.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;
      link.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke2;
      link.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;
      link.strokeWidth = Math.min(
        highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth,
        datum.height / 2
      );
      link.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;
      link.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;
      link.inset = link.strokeWidth / 2;
    });
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT4;
    }
    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;
    const { datum, itemId } = nodeDatum;
    let title;
    const contentLines = [];
    let fill;
    if (nodeDatum.type === 0 /* Link */) {
      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.link;
      const { fromNode, toNode, size } = nodeDatum;
      title = `${fromNode.label ?? fromNode.id} - ${toNode.label ?? toNode.id}`;
      if (sizeKey != null) {
        contentLines.push(sanitizeHtml13(`${sizeName ?? sizeKey}: ` + size));
      }
      fill = properties.link.fill ?? fromNode.fill;
      const stroke2 = properties.link.stroke ?? fromNode.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: true
        });
      }
      fill = format?.fill ?? fill;
    } else {
      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.node;
      const { id, label, size } = nodeDatum;
      title = label ?? id;
      if (sizeKey != null) {
        contentLines.push(sanitizeHtml13(`${sizeName ?? sizeKey}: ` + size));
      }
      fill = properties.link.fill ?? datum.fill;
      const stroke2 = properties.link.stroke ?? datum.stroke;
      let format;
      if (itemStyler != null) {
        format = callbackCache.call(itemStyler, {
          seriesId,
          datum: datum.datum,
          label,
          size,
          fromKey,
          toKey,
          sizeKey,
          fill,
          fillOpacity,
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          lineDash,
          lineDashOffset,
          highlighted: true
        });
      }
      fill = format?.fill ?? fill;
    }
    const content = contentLines.join("<br>");
    const color = fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        title,
        color,
        itemId,
        fromKey,
        toKey,
        sizeKey,
        sizeName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getLabelData() {
    return [];
  }
  computeFocusBounds({
    datumIndex,
    seriesRect
  }) {
    const datum = this.contextNodeData?.nodeData[datumIndex];
    if (datum?.type === 1 /* Node */) {
      const { x, y, width, height } = datum;
      const bbox = new BBox14(x, y, width, height);
      return _Scene87.Transformable.toCanvas(this.contentGroup, bbox).clip(seriesRect);
    } else if (datum?.type === 0 /* Link */) {
      for (const link of this.linkSelection) {
        if (link.datum === datum) {
          return link.node;
        }
      }
      return void 0;
    }
  }
};
SankeySeries.className = "SankeySeries";
SankeySeries.type = "sankey";

// packages/ag-charts-enterprise/src/series/sankey/sankeyModule.ts
var { DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY5, DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR6 } = _Theme39;
var SankeyModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["flow-proportion"],
  solo: true,
  identifier: "sankey",
  moduleFactory: (ctx) => new SankeySeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: {
    seriesArea: {
      padding: {
        top: 10,
        bottom: 10
      }
    },
    series: {
      highlightStyle: {
        series: {
          dimOpacity: 0.2
        }
      },
      label: {
        fontFamily: DEFAULT_FONT_FAMILY5,
        color: DEFAULT_LABEL_COLOUR6,
        fontSize: 12,
        spacing: 10
      },
      node: {
        spacing: 20,
        width: 10,
        strokeWidth: 0
      },
      link: {
        fillOpacity: 0.5,
        strokeWidth: 0
      }
    },
    legend: {
      enabled: false,
      toggleSeries: false
    }
  },
  paletteFactory({ takeColors, colorsCount }) {
    return takeColors(colorsCount);
  }
};

// packages/ag-charts-enterprise/src/series/sunburst/sunburstModule.ts
import { _Theme as _Theme40 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeries.ts
import { _ModuleSupport as _ModuleSupport159, _Scene as _Scene88, _Util as _Util92 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport158 } from "ag-charts-community";
var {
  HierarchySeriesProperties,
  HighlightStyle,
  SeriesTooltip: SeriesTooltip19,
  Validate: Validate73,
  COLOR_STRING: COLOR_STRING29,
  FUNCTION: FUNCTION19,
  NUMBER: NUMBER18,
  OBJECT: OBJECT36,
  POSITIVE_NUMBER: POSITIVE_NUMBER30,
  RATIO: RATIO34,
  STRING: STRING36
} = _ModuleSupport158;
var SunburstSeriesTileHighlightStyle = class extends HighlightStyle {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedLabel();
  }
};
__decorateClass([
  Validate73(STRING36, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Validate73(RATIO34, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate73(COLOR_STRING29, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Validate73(POSITIVE_NUMBER30, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate73(RATIO34, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var SunburstSeriesProperties = class extends HierarchySeriesProperties {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.highlightStyle = new SunburstSeriesTileHighlightStyle();
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
    this.tooltip = new SeriesTooltip19();
  }
};
__decorateClass([
  Validate73(STRING36, { optional: true })
], SunburstSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate73(STRING36, { optional: true })
], SunburstSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate73(STRING36, { optional: true })
], SunburstSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass([
  Validate73(RATIO34)
], SunburstSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate73(POSITIVE_NUMBER30)
], SunburstSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate73(RATIO34)
], SunburstSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate73(POSITIVE_NUMBER30)
], SunburstSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate73(NUMBER18, { optional: true })
], SunburstSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Validate73(NUMBER18, { optional: true })
], SunburstSeriesProperties.prototype, "padding", 2);
__decorateClass([
  Validate73(FUNCTION19, { optional: true })
], SunburstSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass([
  Validate73(OBJECT36)
], SunburstSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeries.ts
var { fromToMotion: fromToMotion5 } = _ModuleSupport159;
var { Sector: Sector7, ScalableGroup: ScalableGroup2, Selection: Selection13, TransformableText: TransformableText2 } = _Scene88;
var { sanitizeHtml: sanitizeHtml14 } = _Util92;
var getAngleData = (node, startAngle = 0, angleScale = 2 * Math.PI / node.sumSize, angleData = Array.from(node, () => void 0)) => {
  let currentAngle = startAngle;
  for (const child of node.children) {
    const start = currentAngle;
    const end = currentAngle + child.sumSize * angleScale;
    angleData[child.index] = { start, end };
    getAngleData(child, start, angleScale, angleData);
    currentAngle = end;
  }
  return angleData;
};
var SunburstSeries = class extends _ModuleSupport159.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new SunburstSeriesProperties();
    this.groupSelection = Selection13.select(this.contentGroup, ScalableGroup2);
    this.highlightSelection = Selection13.select(this.highlightGroup, ScalableGroup2);
    this.angleData = [];
  }
  async processData() {
    const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName } = this.properties;
    await super.processData();
    this.angleData = getAngleData(this.rootNode);
    const defaultLabelFormatter = (value) => {
      if (typeof value === "number") {
        return value.toFixed(2);
      } else if (typeof value === "string") {
        return value;
      } else {
        return "";
      }
    };
    this.labelData = Array.from(this.rootNode, ({ datum, depth }) => {
      let label;
      if (datum != null && depth != null && labelKey != null) {
        const value = datum[labelKey];
        label = this.getLabelText(
          this.properties.label,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          },
          defaultLabelFormatter
        );
      }
      if (label === "") {
        label = void 0;
      }
      let secondaryLabel;
      if (datum != null && depth != null && secondaryLabelKey != null) {
        const value = datum[secondaryLabelKey];
        secondaryLabel = this.getLabelText(
          this.properties.secondaryLabel,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          },
          defaultLabelFormatter
        );
      }
      if (secondaryLabel === "") {
        secondaryLabel = void 0;
      }
      return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
    });
  }
  async updateSelections() {
    if (!this.nodeDataRefresh)
      return;
    this.nodeDataRefresh = false;
    const { chart } = this;
    if (chart == null)
      return;
    const seriesRect = chart.seriesRect;
    if (seriesRect == null)
      return;
    const descendants = Array.from(this.rootNode);
    const updateGroup = (group) => {
      group.append([
        new Sector7(),
        new TransformableText2({ tag: 0 /* Primary */ }),
        new TransformableText2({ tag: 1 /* Secondary */ })
      ]);
    };
    this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
  }
  async updateNodes() {
    const { chart, data, maxDepth, labelData } = this;
    if (chart == null || data == null || labelData == null) {
      return;
    }
    const { width, height } = chart.seriesRect;
    const { sectorSpacing = 0, padding = 0, cornerRadius, highlightStyle } = this.properties;
    this.contentGroup.translationX = width / 2;
    this.contentGroup.translationY = height / 2;
    this.highlightGroup.translationX = width / 2;
    this.highlightGroup.translationY = height / 2;
    const baseInset = sectorSpacing * 0.5;
    const radius = Math.min(width, height) / 2;
    const radiusScale = radius / (maxDepth + 1);
    const angleOffset = -Math.PI / 2;
    const highlightedNode = this.ctx.highlightManager?.getActiveHighlight();
    const labelTextNode = new TransformableText2();
    labelTextNode.setFont(this.properties.label);
    this.rootNode.walk((node) => {
      const angleDatum = this.angleData[node.index];
      if (node.depth != null && angleDatum != null) {
        const midAngle = angleDatum.end - angleDatum.start;
        const midRadius = (node.depth + 0.5) * radiusScale;
        node.midPoint.x = Math.cos(midAngle) * midRadius;
        node.midPoint.y = Math.sin(midAngle) * midRadius;
      }
    });
    const updateSector = (node, sector, highlighted) => {
      const { depth } = node;
      const angleDatum = this.angleData[node.index];
      if (depth == null || angleDatum == null) {
        sector.visible = false;
        return;
      }
      sector.visible = true;
      let highlightedFill;
      let highlightedFillOpacity;
      let highlightedStroke;
      let highlightedStrokeWidth;
      let highlightedStrokeOpacity;
      if (highlighted) {
        highlightedFill = highlightStyle.fill;
        highlightedFillOpacity = highlightStyle.fillOpacity;
        highlightedStroke = highlightStyle.stroke;
        highlightedStrokeWidth = highlightStyle.strokeWidth;
        highlightedStrokeOpacity = highlightStyle.strokeOpacity;
      }
      const format = this.getSectorFormat(node, highlighted);
      const fill = format?.fill ?? highlightedFill ?? node.fill;
      const fillOpacity = format?.fillOpacity ?? highlightedFillOpacity ?? this.properties.fillOpacity;
      const stroke2 = format?.stroke ?? highlightedStroke ?? node.stroke;
      const strokeWidth = format?.strokeWidth ?? highlightedStrokeWidth ?? this.properties.strokeWidth;
      const strokeOpacity = format?.strokeOpacity ?? highlightedStrokeOpacity ?? this.properties.strokeOpacity;
      sector.fill = fill;
      sector.fillOpacity = fillOpacity;
      sector.stroke = stroke2;
      sector.strokeWidth = strokeWidth;
      sector.strokeOpacity = strokeOpacity;
      sector.centerX = 0;
      sector.centerY = 0;
      sector.innerRadius = depth * radiusScale;
      sector.outerRadius = (depth + 1) * radiusScale;
      sector.startAngle = angleDatum.start + angleOffset;
      sector.endAngle = angleDatum.end + angleOffset;
      sector.inset = baseInset + strokeWidth * 0.5;
      sector.cornerRadius = cornerRadius;
    };
    this.groupSelection.selectByClass(Sector7).forEach((sector) => {
      updateSector(sector.datum, sector, false);
    });
    this.highlightSelection.selectByClass(Sector7).forEach((sector) => {
      const node = sector.datum;
      const isHighlighted = highlightedNode === node;
      sector.visible = isHighlighted;
      if (sector.visible) {
        updateSector(sector.datum, sector, isHighlighted);
      }
    });
    const labelMeta = Array.from(this.rootNode, (node, index) => {
      const { depth } = node;
      const labelDatum = labelData[index];
      const angleData = this.angleData[index];
      if (depth == null || angleData == null) {
        return;
      }
      const innerRadius = depth * radiusScale + baseInset;
      const outerRadius = (depth + 1) * radiusScale - baseInset;
      const innerAngleOffset = innerRadius > baseInset ? baseInset / innerRadius : baseInset;
      const outerAngleOffset = outerRadius > baseInset ? baseInset / outerRadius : baseInset;
      const innerStartAngle = angleData.start + innerAngleOffset;
      const innerEndAngle = angleData.end + innerAngleOffset;
      const deltaInnerAngle = innerEndAngle - innerStartAngle;
      const outerStartAngle = angleData.start + outerAngleOffset;
      const outerEndAngle = angleData.end + outerAngleOffset;
      const deltaOuterAngle = outerEndAngle - outerStartAngle;
      const sizeFittingHeight = (labelHeight2) => {
        const isCenterCircle = depth === 0 && node.parent?.sumSize === node.sumSize;
        if (isCenterCircle) {
          const labelWidth2 = 2 * Math.sqrt(outerRadius ** 2 - (labelHeight2 * 0.5) ** 2);
          return { width: labelWidth2, height: labelHeight2, meta: 0 /* CenterCircle */ };
        }
        const parallelHeight = labelHeight2;
        const availableWidthUntilItHitsTheOuterRadius = 2 * Math.sqrt(outerRadius ** 2 - (innerRadius + parallelHeight) ** 2);
        const availableWidthUntilItHitsTheStraightEdges = deltaInnerAngle < Math.PI ? 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5) : Infinity;
        const parallelWidth = Math.min(
          availableWidthUntilItHitsTheOuterRadius,
          availableWidthUntilItHitsTheStraightEdges
        );
        const maxPerpendicularAngle = Math.PI / 4;
        let perpendicularHeight;
        let perpendicularWidth;
        if (depth === 0) {
          perpendicularHeight = labelHeight2;
          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - labelHeight2 / (2 * Math.tan(deltaOuterAngle * 0.5));
        } else if (_Util92.normalizeAngle360(deltaInnerAngle) < maxPerpendicularAngle) {
          perpendicularHeight = 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5);
          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - innerRadius;
        } else {
          perpendicularWidth = 0;
          perpendicularHeight = 0;
        }
        return parallelWidth >= perpendicularWidth ? { width: parallelWidth, height: parallelHeight, meta: 1 /* Parallel */ } : { width: perpendicularWidth, height: perpendicularHeight, meta: 2 /* Perpendicular */ };
      };
      const formatting = formatLabels(
        labelDatum?.label,
        this.properties.label,
        labelDatum?.secondaryLabel,
        this.properties.secondaryLabel,
        { padding },
        sizeFittingHeight
      );
      if (formatting == null) {
        return;
      }
      const { width: labelWidth, height: labelHeight, meta: labelPlacement, label, secondaryLabel } = formatting;
      const theta = angleOffset + (angleData.start + angleData.end) / 2;
      const top = Math.sin(theta) >= 0;
      const right = Math.cos(theta) >= 0;
      const circleQuarter = (top ? 3 /* Top */ : 12 /* Bottom */) & (right ? 6 /* Right */ : 9 /* Left */);
      let labelRadius;
      switch (labelPlacement) {
        case 0 /* CenterCircle */:
          labelRadius = 0;
          break;
        case 1 /* Parallel */: {
          const opticalCentering = 0.58;
          const idealRadius = outerRadius - (radiusScale - labelHeight) * opticalCentering;
          const maximumRadius = Math.sqrt((outerRadius - padding) ** 2 - (labelWidth / 2) ** 2);
          labelRadius = Math.min(idealRadius, maximumRadius);
          break;
        }
        case 2 /* Perpendicular */:
          if (depth === 0) {
            const minimumRadius = labelHeight / (2 * Math.tan(deltaInnerAngle * 0.5)) + labelWidth * 0.5;
            const maximumRadius = Math.sqrt(outerRadius ** 2 - (labelHeight * 0.5) ** 2) - labelWidth * 0.5;
            labelRadius = (minimumRadius + maximumRadius) * 0.5;
          } else {
            labelRadius = (innerRadius + outerRadius) * 0.5;
          }
          break;
      }
      return {
        width: labelWidth,
        height: labelHeight,
        labelPlacement,
        circleQuarter,
        radius: labelRadius,
        theta,
        label,
        secondaryLabel
      };
    });
    const updateText = (node, text2, tag, highlighted) => {
      const { index, depth } = node;
      const meta = labelMeta?.[index];
      const labelStyle = tag === 0 /* Primary */ ? this.properties.label : this.properties.secondaryLabel;
      const label = tag === 0 /* Primary */ ? meta?.label : meta?.secondaryLabel;
      if (depth == null || meta == null || label == null) {
        text2.visible = false;
        return;
      }
      const { height: textHeight, labelPlacement, circleQuarter, radius: textRadius, theta } = meta;
      let highlightedColor;
      if (highlighted) {
        const highlightedLabelStyle = tag === 0 /* Primary */ ? this.properties.highlightStyle.label : this.properties.highlightStyle.secondaryLabel;
        highlightedColor = highlightedLabelStyle.color;
      }
      text2.text = label.text;
      text2.fontSize = label.fontSize;
      text2.lineHeight = label.lineHeight;
      text2.fontStyle = labelStyle.fontStyle;
      text2.fontFamily = labelStyle.fontFamily;
      text2.fontWeight = labelStyle.fontWeight;
      text2.fill = highlightedColor ?? labelStyle.color;
      switch (labelPlacement) {
        case 0 /* CenterCircle */:
          text2.textAlign = "center";
          text2.textBaseline = "top";
          text2.translationX = 0;
          text2.translationY = (tag === 0 /* Primary */ ? 0 : textHeight - label.height) - textHeight * 0.5;
          text2.rotation = 0;
          break;
        case 1 /* Parallel */: {
          const topHalf = (circleQuarter & 3 /* Top */) !== 0;
          const translationRadius = tag === 0 /* Primary */ === !topHalf ? textRadius : textRadius - (textHeight - label.height);
          text2.textAlign = "center";
          text2.textBaseline = topHalf ? "bottom" : "top";
          text2.translationX = Math.cos(theta) * translationRadius;
          text2.translationY = Math.sin(theta) * translationRadius;
          text2.rotation = topHalf ? theta - Math.PI * 0.5 : theta + Math.PI * 0.5;
          break;
        }
        case 2 /* Perpendicular */: {
          const rightHalf = (circleQuarter & 6 /* Right */) !== 0;
          const translation = tag === 0 /* Primary */ === !rightHalf ? (textHeight - label.height) * 0.5 : (label.height - textHeight) * 0.5;
          text2.textAlign = "center";
          text2.textBaseline = "middle";
          text2.translationX = Math.cos(theta) * textRadius + Math.cos(theta + Math.PI / 2) * translation;
          text2.translationY = Math.sin(theta) * textRadius + Math.sin(theta + Math.PI / 2) * translation;
          text2.rotation = rightHalf ? theta : theta + Math.PI;
          break;
        }
      }
      text2.visible = true;
    };
    this.groupSelection.selectByClass(TransformableText2).forEach((text2) => {
      updateText(text2.datum, text2, text2.tag, false);
    });
    this.highlightSelection.selectByClass(TransformableText2).forEach((text2) => {
      const node = text2.datum;
      const isHighlighted = highlightedNode === node;
      text2.visible = isHighlighted;
      if (text2.visible) {
        updateText(text2.datum, text2, text2.tag, isHighlighted);
      }
    });
  }
  getSectorFormat(node, isHighlighted) {
    const { datum, fill, stroke: stroke2, depth } = node;
    const {
      ctx: { callbackCache },
      properties: { itemStyler }
    } = this;
    if (!itemStyler || datum == null || depth == null) {
      return {};
    }
    const { colorKey, childrenKey, labelKey, secondaryLabelKey, sizeKey, strokeWidth, fillOpacity, strokeOpacity } = this.properties;
    return callbackCache.call(itemStyler, {
      seriesId: this.id,
      highlighted: isHighlighted,
      datum,
      depth,
      colorKey,
      childrenKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity
    });
  }
  getTooltipHtml(node) {
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey,
      childrenKey
    } = this.properties;
    const { datum, depth } = node;
    if (datum == null || depth == null) {
      return _ModuleSupport159.EMPTY_TOOLTIP_CONTENT;
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format = this.getSectorFormat(node, false);
    const color = format?.fill ?? node.fill;
    if (!tooltip.renderer && !title) {
      return _ModuleSupport159.EMPTY_TOOLTIP_CONTENT;
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml14(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml14(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml14(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: this.properties.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId,
      childrenKey,
      colorName,
      itemId: void 0,
      sizeName
    });
  }
  async createNodeData() {
    return void 0;
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.groupSelection.selectByClass(Sector7));
  }
  animateEmptyUpdateReady({
    datumSelections
  }) {
    fromToMotion5(this.id, "nodes", this.ctx.animationManager, datumSelections, {
      toFn(_group, _datum, _status) {
        return { scalingX: 1, scalingY: 1 };
      },
      fromFn(group, datum, status) {
        if (status === "unknown" && datum != null && group.previousDatum == null) {
          return { scalingX: 0, scalingY: 0 };
        } else {
          return { scalingX: 1, scalingY: 1 };
        }
      }
    });
  }
  computeFocusBounds(nodeDatum) {
    let match;
    for (const { node, datum } of this.groupSelection) {
      if (datum === nodeDatum) {
        match = _Scene88.Selection.selectByClass(node, _Scene88.Sector)[0];
      }
    }
    return match;
  }
};
SunburstSeries.className = "SunburstSeries";
SunburstSeries.type = "sunburst";

// packages/ag-charts-enterprise/src/series/sunburst/sunburstModule.ts
var { DEFAULT_INSIDE_SERIES_LABEL_COLOUR } = _Theme40;
var SunburstModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "sunburst",
  moduleFactory: (ctx) => new SunburstSeries(ctx),
  tooltipDefaults: { range: "exact" },
  solo: true,
  themeTemplate: {
    series: {
      label: {
        fontSize: 14,
        minimumFontSize: 9,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
        overflowStrategy: "ellipsis",
        wrapping: "never",
        spacing: 2
      },
      secondaryLabel: {
        fontSize: 8,
        minimumFontSize: 7,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
        overflowStrategy: "ellipsis",
        wrapping: "never"
      },
      sectorSpacing: 2,
      padding: 3,
      highlightStyle: {
        label: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR
        },
        secondaryLabel: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR
        },
        stroke: `rgba(0, 0, 0, 0.4)`,
        strokeWidth: 2
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = themeTemplateParameters.get(_Theme40.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    return { fills, strokes, colorRange: defaultColorRange };
  }
};

// packages/ag-charts-enterprise/src/series/treemap/treemapModule.ts
import { _Theme as _Theme41 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/treemap/treemapSeries.ts
import {
  _ModuleSupport as _ModuleSupport161,
  _Scene as _Scene90,
  _Util as _Util93
} from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/treemap/treemapSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport160, _Scene as _Scene89 } from "ag-charts-community";
var { Label: Label14 } = _Scene89;
var {
  BaseProperties: BaseProperties27,
  HierarchySeriesProperties: HierarchySeriesProperties2,
  HighlightStyle: HighlightStyle2,
  SeriesTooltip: SeriesTooltip20,
  Validate: Validate74,
  BOOLEAN: BOOLEAN23,
  COLOR_STRING: COLOR_STRING30,
  FUNCTION: FUNCTION20,
  NUMBER: NUMBER19,
  OBJECT: OBJECT37,
  POSITIVE_NUMBER: POSITIVE_NUMBER31,
  RATIO: RATIO35,
  STRING: STRING37,
  STRING_ARRAY,
  TEXT_ALIGN: TEXT_ALIGN3,
  VERTICAL_ALIGN: VERTICAL_ALIGN2
} = _ModuleSupport160;
var TreemapGroupLabel = class extends Label14 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass([
  Validate74(NUMBER19)
], TreemapGroupLabel.prototype, "spacing", 2);
var TreemapSeriesGroup = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.gap = 0;
    this.padding = 0;
    this.interactive = true;
    this.label = new TreemapGroupLabel();
  }
};
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesGroup.prototype, "fill", 2);
__decorateClass([
  Validate74(RATIO35)
], TreemapSeriesGroup.prototype, "fillOpacity", 2);
__decorateClass([
  Validate74(COLOR_STRING30, { optional: true })
], TreemapSeriesGroup.prototype, "stroke", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesGroup.prototype, "strokeWidth", 2);
__decorateClass([
  Validate74(RATIO35)
], TreemapSeriesGroup.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesGroup.prototype, "cornerRadius", 2);
__decorateClass([
  Validate74(TEXT_ALIGN3)
], TreemapSeriesGroup.prototype, "textAlign", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesGroup.prototype, "gap", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesGroup.prototype, "padding", 2);
__decorateClass([
  Validate74(BOOLEAN23)
], TreemapSeriesGroup.prototype, "interactive", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesGroup.prototype, "label", 2);
var TreemapSeriesTile = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.gap = 0;
    this.padding = 0;
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
  }
};
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesTile.prototype, "fill", 2);
__decorateClass([
  Validate74(RATIO35)
], TreemapSeriesTile.prototype, "fillOpacity", 2);
__decorateClass([
  Validate74(COLOR_STRING30, { optional: true })
], TreemapSeriesTile.prototype, "stroke", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31, { optional: true })
], TreemapSeriesTile.prototype, "strokeWidth", 2);
__decorateClass([
  Validate74(RATIO35)
], TreemapSeriesTile.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesTile.prototype, "cornerRadius", 2);
__decorateClass([
  Validate74(TEXT_ALIGN3)
], TreemapSeriesTile.prototype, "textAlign", 2);
__decorateClass([
  Validate74(VERTICAL_ALIGN2)
], TreemapSeriesTile.prototype, "verticalAlign", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesTile.prototype, "gap", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31)
], TreemapSeriesTile.prototype, "padding", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesTile.prototype, "label", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesTile.prototype, "secondaryLabel", 2);
var TreemapSeriesGroupHighlightStyle = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
  }
};
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Validate74(RATIO35, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate74(COLOR_STRING30, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate74(RATIO35, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesGroupHighlightStyle.prototype, "label", 2);
var TreemapSeriesTileHighlightStyle = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
  }
};
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Validate74(RATIO35, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate74(COLOR_STRING30, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Validate74(POSITIVE_NUMBER31, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate74(RATIO35, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var TreemapSeriesHighlightStyle = class extends HighlightStyle2 {
  constructor() {
    super(...arguments);
    this.group = new TreemapSeriesGroupHighlightStyle();
    this.tile = new TreemapSeriesTileHighlightStyle();
  }
};
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesHighlightStyle.prototype, "group", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesHighlightStyle.prototype, "tile", 2);
var TreemapSeriesProperties = class extends HierarchySeriesProperties2 {
  constructor() {
    super(...arguments);
    this.highlightStyle = new TreemapSeriesHighlightStyle();
    this.tooltip = new SeriesTooltip20();
    this.group = new TreemapSeriesGroup();
    this.tile = new TreemapSeriesTile();
    this.undocumentedGroupFills = [];
    this.undocumentedGroupStrokes = [];
  }
};
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate74(STRING37, { optional: true })
], TreemapSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass([
  Validate74(FUNCTION20, { optional: true })
], TreemapSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesProperties.prototype, "group", 2);
__decorateClass([
  Validate74(OBJECT37)
], TreemapSeriesProperties.prototype, "tile", 2);
__decorateClass([
  Validate74(STRING_ARRAY)
], TreemapSeriesProperties.prototype, "undocumentedGroupFills", 2);
__decorateClass([
  Validate74(STRING_ARRAY)
], TreemapSeriesProperties.prototype, "undocumentedGroupStrokes", 2);

// packages/ag-charts-enterprise/src/series/treemap/treemapSeries.ts
var { TextUtils: TextUtils5, TextWrapper: TextWrapper7 } = _ModuleSupport161;
var { Rect: Rect8, Group: Group15, BBox: BBox15, Selection: Selection14, Text: Text10 } = _Scene90;
var { Color: Color7, Logger: Logger21, clamp: clamp6, isEqual: isEqual2, sanitizeHtml: sanitizeHtml15 } = _Util93;
var tempText = new Text10();
function getTextSize(text2, style) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = style;
  tempText.setProperties({
    text: text2,
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    textAlign: "left",
    textBaseline: "top"
  });
  const { width, height } = tempText.getBBox();
  return { width, height };
}
function validateColor(color) {
  if (typeof color === "string" && !Color7.validColorString(color)) {
    const fallbackColor = "black";
    Logger21.warnOnce(
      `invalid Treemap tile colour string "${color}". Affected treemap tiles will be coloured ${fallbackColor}.`
    );
    return fallbackColor;
  }
  return color;
}
function nodeSize(node) {
  return node.children.length > 0 ? node.sumSize - node.size : node.size;
}
var textAlignFactors2 = {
  left: 0,
  center: 0.5,
  right: 1
};
var verticalAlignFactors3 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
var DistantGroup = class extends _Scene90.Group {
  distanceSquared(x, y) {
    return this.getBBox().distanceSquared(x, y);
  }
};
var TreemapSeries = class extends _ModuleSupport161.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new TreemapSeriesProperties();
    this.groupSelection = Selection14.select(this.contentGroup, DistantGroup);
    this.highlightSelection = Selection14.select(this.highlightGroup, Group15);
  }
  groupTitleHeight(node, bbox) {
    const label = this.labelData?.[node.index]?.label;
    const { label: font2 } = this.properties.group;
    const heightRatioThreshold = 3;
    if (label == null) {
      return;
    } else if (font2.fontSize > bbox.width / heightRatioThreshold || font2.fontSize > bbox.height / heightRatioThreshold) {
      return;
    } else {
      const { height: fontHeight } = getTextSize(label, font2);
      return Math.max(fontHeight, font2.fontSize);
    }
  }
  getNodePadding(node, bbox) {
    if (node.index === 0) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    } else if (node.children.length === 0) {
      const { padding: padding2 } = this.properties.tile;
      return {
        top: padding2,
        right: padding2,
        bottom: padding2,
        left: padding2
      };
    }
    const {
      label: { spacing },
      padding
    } = this.properties.group;
    const fontHeight = this.groupTitleHeight(node, bbox);
    const titleHeight = fontHeight != null ? fontHeight + spacing : 0;
    return {
      top: padding + titleHeight,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  async processData() {
    await super.processData();
    const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName, tile, group } = this.properties;
    if (!this.data?.length) {
      this.labelData = void 0;
      return;
    }
    const defaultLabelFormatter = (value) => {
      if (typeof value === "number") {
        return value.toFixed(2);
      } else if (typeof value === "string") {
        return value;
      } else {
        return "";
      }
    };
    this.labelData = Array.from(this.rootNode, ({ datum, depth, children }) => {
      const isLeaf = children.length === 0;
      const labelStyle = isLeaf ? tile.label : group.label;
      let label;
      if (datum != null && depth != null && labelKey != null) {
        const value = datum[labelKey];
        label = this.getLabelText(
          labelStyle,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          },
          defaultLabelFormatter
        );
      }
      if (label === "") {
        label = void 0;
      }
      let secondaryLabel;
      if (isLeaf && datum != null && depth != null && secondaryLabelKey != null) {
        const value = datum[secondaryLabelKey];
        secondaryLabel = this.getLabelText(
          tile.secondaryLabel,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          },
          defaultLabelFormatter
        );
      }
      if (secondaryLabel === "") {
        secondaryLabel = void 0;
      }
      return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
    });
  }
  sortChildren({ children }) {
    const sortedChildrenIndices = Array.from(children, (_, i) => i).filter((i) => nodeSize(children[i]) > 0).sort((aIndex, bIndex) => nodeSize(children[bIndex]) - nodeSize(children[aIndex]));
    const childAt = (i) => {
      const sortedIndex = sortedChildrenIndices[i];
      return children[sortedIndex];
    };
    return { sortedChildrenIndices, childAt };
  }
  /**
   * Squarified Treemap algorithm
   * https://www.win.tue.nl/~vanwijk/stm.pdf
   */
  squarify(node, bbox, outputBoxes, outputPadding) {
    const { index, datum, children } = node;
    if (bbox.width <= 0 || bbox.height <= 0) {
      outputBoxes[index] = void 0;
      outputPadding[index] = void 0;
      return;
    }
    const padding = datum != null ? this.getNodePadding(node, bbox) : { top: 0, right: 0, bottom: 0, left: 0 };
    outputBoxes[index] = index === 0 ? void 0 : bbox;
    outputPadding[index] = index === 0 ? void 0 : padding;
    const { sortedChildrenIndices, childAt } = this.sortChildren(node);
    const allLeafNodes = sortedChildrenIndices.every((sortedIndex) => children[sortedIndex].children.length === 0);
    const targetTileAspectRatio = 1;
    const width = bbox.width - padding.left - padding.right;
    const height = bbox.height - padding.top - padding.bottom;
    if (width <= 0 || height <= 0)
      return;
    const numChildren = sortedChildrenIndices.length;
    let stackSum = 0;
    let startIndex = 0;
    let minRatioDiff = Infinity;
    let partitionSum = sortedChildrenIndices.reduce((sum, sortedIndex) => sum + nodeSize(children[sortedIndex]), 0);
    const innerBox = new BBox15(bbox.x + padding.left, bbox.y + padding.top, width, height);
    const partition = innerBox.clone();
    let i = 0;
    while (i < numChildren) {
      const value = nodeSize(childAt(i));
      const firstValue = nodeSize(childAt(startIndex));
      const isVertical2 = partition.width < partition.height;
      stackSum += value;
      const partThickness = isVertical2 ? partition.height : partition.width;
      const partLength = isVertical2 ? partition.width : partition.height;
      const firstTileLength = partLength * firstValue / stackSum;
      let stackThickness = partThickness * stackSum / partitionSum;
      const ratio = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);
      const diff8 = Math.abs(targetTileAspectRatio - ratio);
      if (diff8 < minRatioDiff) {
        minRatioDiff = diff8;
        i++;
        continue;
      }
      stackSum -= value;
      stackThickness = partThickness * stackSum / partitionSum;
      let start2 = isVertical2 ? partition.x : partition.y;
      for (let j = startIndex; j < i; j++) {
        const child = childAt(j);
        const childSize = nodeSize(child);
        const x = isVertical2 ? start2 : partition.x;
        const y = isVertical2 ? partition.y : start2;
        const length = partLength * childSize / stackSum;
        const stackWidth = isVertical2 ? length : stackThickness;
        const stackHeight = isVertical2 ? stackThickness : length;
        const childBbox = new BBox15(x, y, stackWidth, stackHeight);
        this.applyGap(innerBox, childBbox, allLeafNodes);
        this.squarify(child, childBbox, outputBoxes, outputPadding);
        partitionSum -= childSize;
        start2 += length;
      }
      if (isVertical2) {
        partition.y += stackThickness;
        partition.height -= stackThickness;
      } else {
        partition.x += stackThickness;
        partition.width -= stackThickness;
      }
      startIndex = i;
      stackSum = 0;
      minRatioDiff = Infinity;
    }
    const isVertical = partition.width < partition.height;
    let start = isVertical ? partition.x : partition.y;
    for (let childIdx = startIndex; childIdx < numChildren; childIdx++) {
      const child = childAt(childIdx);
      const x = isVertical ? start : partition.x;
      const y = isVertical ? partition.y : start;
      const part = nodeSize(child) / partitionSum;
      const childWidth = partition.width * (isVertical ? part : 1);
      const childHeight = partition.height * (isVertical ? 1 : part);
      const childBox = new BBox15(x, y, childWidth, childHeight);
      this.applyGap(innerBox, childBox, allLeafNodes);
      this.squarify(child, childBox, outputBoxes, outputPadding);
      start += isVertical ? childWidth : childHeight;
    }
  }
  applyGap(innerBox, childBox, allLeafNodes) {
    const gap = allLeafNodes ? this.properties.tile.gap * 0.5 : this.properties.group.gap * 0.5;
    const getBounds = (box) => ({
      left: box.x,
      top: box.y,
      right: box.x + box.width,
      bottom: box.y + box.height
    });
    const innerBounds = getBounds(innerBox);
    const childBounds = getBounds(childBox);
    const sides = ["top", "right", "bottom", "left"];
    sides.forEach((side) => {
      if (!isEqual2(innerBounds[side], childBounds[side])) {
        childBox.shrink(gap, side);
      }
    });
  }
  async createNodeData() {
    return void 0;
  }
  async updateSelections() {
    if (!this.nodeDataRefresh) {
      return;
    }
    this.nodeDataRefresh = false;
    const { seriesRect } = this.chart ?? {};
    if (!seriesRect)
      return;
    const descendants = Array.from(this.rootNode);
    const updateGroup = (group) => {
      group.append([
        new Rect8(),
        new Text10({ tag: 0 /* Primary */ }),
        new Text10({ tag: 1 /* Secondary */ })
      ]);
    };
    this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
  }
  getTileFormat(node, highlighted) {
    const { datum, depth, children } = node;
    const { colorKey, childrenKey, labelKey, secondaryLabelKey, sizeKey, tile, group, itemStyler } = this.properties;
    if (!itemStyler || datum == null || depth == null) {
      return {};
    }
    const isLeaf = children.length === 0;
    const fill = this.getNodeFill(node);
    const stroke2 = this.getNodeStroke(node);
    const strokeWidth = isLeaf ? tile.strokeWidth : group.strokeWidth;
    return this.ctx.callbackCache.call(itemStyler, {
      seriesId: this.id,
      highlighted,
      datum,
      depth,
      colorKey,
      childrenKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      fill,
      fillOpacity: 1,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity: 1
    });
  }
  getNodeFill(node) {
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return this.properties.tile.fill ?? node.fill;
    }
    const { undocumentedGroupFills } = this.properties;
    const defaultFill = undocumentedGroupFills[Math.min(node.depth ?? 0, undocumentedGroupFills.length)];
    return this.properties.group.fill ?? defaultFill;
  }
  getNodeStroke(node) {
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return this.properties.tile.stroke ?? node.stroke;
    }
    const { undocumentedGroupStrokes } = this.properties;
    const defaultStroke = undocumentedGroupStrokes[Math.min(node.depth ?? 0, undocumentedGroupStrokes.length)];
    return this.properties.group.stroke ?? defaultStroke;
  }
  async updateNodes() {
    const { rootNode, data } = this;
    const { highlightStyle, tile, group } = this.properties;
    const { seriesRect } = this.chart ?? {};
    if (!seriesRect || !data)
      return;
    const { width, height } = seriesRect;
    const bboxes = Array.from(this.rootNode, () => void 0);
    const paddings = Array.from(this.rootNode, () => void 0);
    this.squarify(rootNode, new BBox15(0, 0, width, height), bboxes, paddings);
    let highlightedNode = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedNode != null && !this.properties.group.interactive && highlightedNode.children.length !== 0) {
      highlightedNode = void 0;
    }
    this.updateNodeMidPoint(bboxes);
    const updateRectFn = (node, rect, highlighted) => {
      const bbox = bboxes[node.index];
      if (bbox == null) {
        rect.visible = false;
        return;
      }
      const isLeaf = node.children.length === 0;
      let highlightedFill;
      let highlightedFillOpacity;
      let highlightedStroke;
      let highlightedStrokeWidth;
      let highlightedStrokeOpacity;
      if (highlighted) {
        const { tile: hTitle, group: hGroup } = highlightStyle;
        highlightedFill = isLeaf ? hTitle.fill : hGroup.fill;
        highlightedFillOpacity = isLeaf ? hTitle.fillOpacity : hGroup.fillOpacity;
        highlightedStroke = isLeaf ? hTitle.stroke : hGroup.stroke;
        highlightedStrokeWidth = isLeaf ? hTitle.strokeWidth : hGroup.strokeWidth;
        highlightedStrokeOpacity = isLeaf ? hTitle.strokeOpacity : hGroup.strokeOpacity;
      }
      const format = this.getTileFormat(node, highlighted);
      const fill = format?.fill ?? highlightedFill ?? this.getNodeFill(node);
      const fillOpacity = format?.fillOpacity ?? highlightedFillOpacity ?? (isLeaf ? tile.fillOpacity : group.fillOpacity);
      const stroke2 = format?.stroke ?? highlightedStroke ?? this.getNodeStroke(node);
      const strokeWidth = format?.strokeWidth ?? highlightedStrokeWidth ?? (isLeaf ? tile.strokeWidth : group.strokeWidth);
      const strokeOpacity = format?.strokeOpacity ?? highlightedStrokeOpacity ?? (isLeaf ? tile.strokeOpacity : group.strokeOpacity);
      rect.crisp = true;
      rect.fill = validateColor(fill);
      rect.fillOpacity = fillOpacity;
      rect.stroke = validateColor(stroke2);
      rect.strokeWidth = strokeWidth;
      rect.strokeOpacity = strokeOpacity;
      rect.cornerRadius = isLeaf ? tile.cornerRadius : group.cornerRadius;
      const onlyLeaves = node.parent?.children.every((n) => n.children.length === 0);
      const parentBbox = node.parent != null ? bboxes[node.parent.index] : void 0;
      const parentPadding = node.parent != null ? paddings[node.parent.index] : void 0;
      if (onlyLeaves === true && parentBbox != null && parentPadding != null) {
        rect.clipBBox = bbox;
        rect.x = parentBbox.x + parentPadding.left;
        rect.y = parentBbox.y + parentPadding.top;
        rect.width = parentBbox.width - (parentPadding.left + parentPadding.right);
        rect.height = parentBbox.height - (parentPadding.top + parentPadding.bottom);
      } else {
        rect.clipBBox = void 0;
        rect.x = bbox.x;
        rect.y = bbox.y;
        rect.width = bbox.width;
        rect.height = bbox.height;
      }
      rect.visible = true;
    };
    this.groupSelection.selectByClass(Rect8).forEach((rect) => updateRectFn(rect.datum, rect, false));
    this.highlightSelection.selectByClass(Rect8).forEach((rect) => {
      const isDatumHighlighted = rect.datum === highlightedNode;
      rect.visible = isDatumHighlighted || (highlightedNode?.contains(rect.datum) ?? false);
      if (rect.visible) {
        updateRectFn(rect.datum, rect, isDatumHighlighted);
      }
    });
    const labelMeta = Array.from(this.rootNode, (node) => {
      const { index, children } = node;
      const bbox = bboxes[index];
      const labelDatum = this.labelData?.[index];
      if (bbox == null || labelDatum == null) {
        return;
      }
      if (children.length === 0) {
        const layout = {
          width: bbox.width,
          height: bbox.height,
          meta: null
        };
        const formatting = formatLabels(
          labelDatum.label,
          this.properties.tile.label,
          labelDatum.secondaryLabel,
          this.properties.tile.secondaryLabel,
          { padding: tile.padding },
          () => layout
        );
        if (formatting == null) {
          return;
        }
        const { height: labelHeight, label, secondaryLabel } = formatting;
        const { textAlign, verticalAlign, padding } = tile;
        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;
        const labelX = bbox.x + padding + (bbox.width - 2 * padding) * textAlignFactor;
        const verticalAlignFactor = verticalAlignFactors3[verticalAlign] ?? 0.5;
        const labelYStart = bbox.y + padding + labelHeight * 0.5 + (bbox.height - 2 * padding - labelHeight) * verticalAlignFactor;
        return {
          label: label != null ? {
            text: label.text,
            fontSize: label.fontSize,
            lineHeight: label.lineHeight,
            style: this.properties.tile.label,
            x: labelX,
            y: labelYStart - (labelHeight - label.height) * 0.5
          } : void 0,
          secondaryLabel: secondaryLabel != null ? {
            text: secondaryLabel.text,
            fontSize: secondaryLabel.fontSize,
            lineHeight: secondaryLabel.fontSize,
            style: this.properties.tile.secondaryLabel,
            x: labelX,
            y: labelYStart + (labelHeight - secondaryLabel.height) * 0.5
          } : void 0,
          verticalAlign: "middle",
          textAlign
        };
      } else if (labelDatum?.label == null) {
        return;
      } else {
        const { padding, textAlign } = group;
        const groupTitleHeight = this.groupTitleHeight(node, bbox);
        if (groupTitleHeight == null) {
          return;
        }
        const innerWidth = bbox.width - 2 * padding;
        const text2 = TextWrapper7.wrapText(labelDatum.label, {
          maxWidth: bbox.width - 2 * padding,
          font: group.label,
          textWrap: "never"
        });
        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;
        return {
          label: {
            text: text2,
            fontSize: group.label.fontSize,
            lineHeight: TextUtils5.getLineHeight(group.label.fontSize),
            style: this.properties.group.label,
            x: bbox.x + padding + innerWidth * textAlignFactor,
            y: bbox.y + padding + groupTitleHeight * 0.5
          },
          secondaryLabel: void 0,
          verticalAlign: "middle",
          textAlign
        };
      }
    });
    const updateLabelFn = (node, text2, tag, highlighted) => {
      const isLeaf = node.children.length === 0;
      const meta = labelMeta[node.index];
      const label = tag === 0 /* Primary */ ? meta?.label : meta?.secondaryLabel;
      if (meta == null || label == null) {
        text2.visible = false;
        return;
      }
      let highlightedColor;
      if (highlighted) {
        const { tile: hTitle, group: hGroup } = highlightStyle;
        highlightedColor = hTitle.secondaryLabel.color;
        if (!isLeaf) {
          highlightedColor = hGroup.label.color;
        } else if (tag === 0 /* Primary */) {
          highlightedColor = hTitle.label.color;
        }
      }
      text2.text = label.text;
      text2.fontSize = label.fontSize;
      text2.lineHeight = label.lineHeight;
      text2.fontStyle = label.style.fontStyle;
      text2.fontFamily = label.style.fontFamily;
      text2.fontWeight = label.style.fontWeight;
      text2.fill = highlightedColor ?? label.style.color;
      text2.textAlign = meta.textAlign;
      text2.textBaseline = meta.verticalAlign;
      text2.x = label.x;
      text2.y = label.y;
      text2.visible = true;
    };
    this.groupSelection.selectByClass(Text10).forEach((text2) => {
      updateLabelFn(text2.datum, text2, text2.tag, false);
    });
    this.highlightSelection.selectByClass(Text10).forEach((text2) => {
      const isDatumHighlighted = text2.datum === highlightedNode;
      text2.visible = isDatumHighlighted || (highlightedNode?.contains(text2.datum) ?? false);
      if (text2.visible) {
        updateLabelFn(text2.datum, text2, text2.tag, isDatumHighlighted);
      }
    });
  }
  updateNodeMidPoint(bboxes) {
    this.rootNode.walk((node) => {
      const bbox = bboxes[node.index];
      if (bbox != null) {
        node.midPoint.x = bbox.x + bbox.width / 2;
        node.midPoint.y = bbox.y;
      }
    });
  }
  pickNodeClosestDatum(point) {
    const exactMatch = this.pickNodeExactShape(point);
    if (exactMatch !== void 0) {
      return exactMatch;
    }
    return this.pickNodeNearestDistantObject(point, this.groupSelection.nodes());
  }
  getTooltipHtml(node) {
    const { datum, depth } = node;
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey,
      childrenKey
    } = this.properties;
    const isLeaf = node.children.length === 0;
    const interactive = isLeaf || this.properties.group.interactive;
    if (datum == null || depth == null || !interactive) {
      return _ModuleSupport161.EMPTY_TOOLTIP_CONTENT;
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format = this.getTileFormat(node, false);
    const color = format?.fill ?? this.getNodeFill(node);
    if (!tooltip.renderer && !title) {
      return _ModuleSupport161.EMPTY_TOOLTIP_CONTENT;
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml15(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml15(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml15(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: isLeaf ? this.properties.tile.label.color : this.properties.group.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId,
      childrenKey,
      colorName,
      itemId: void 0,
      sizeName
    });
  }
  pickFocus(opts) {
    const { focusPath: path } = this;
    if (path.length < 2 || this.focusSorted == null) {
      path.length = 1;
      this.focusSorted = this.sortChildren(path[0].nodeDatum);
      path.push({ nodeDatum: this.focusSorted.childAt(0), childIndex: 0 });
    }
    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;
    const current = path[path.length - 1];
    if (depthDelta === 1) {
      if (current.nodeDatum.children.length > 0) {
        this.focusSorted = this.sortChildren(current.nodeDatum);
        const newFocus = { nodeDatum: this.focusSorted.childAt(0), childIndex: 0 };
        path.push(newFocus);
        return this.computeFocusOutputs(newFocus);
      }
    } else if (childDelta !== 0) {
      const targetIndex = current.childIndex + childDelta;
      const maxIndex = (current.nodeDatum.parent?.children.length ?? 1) - 1;
      current.childIndex = clamp6(0, targetIndex, maxIndex);
      current.nodeDatum = this.focusSorted.childAt(current.childIndex);
      return this.computeFocusOutputs(current);
    }
    const result = super.pickFocus(opts);
    if (depthDelta < 0) {
      this.focusSorted = this.sortChildren(path[path.length - 1].nodeDatum.parent);
    }
    return result;
  }
  computeFocusBounds(node) {
    const rects = this.groupSelection.selectByClass(Rect8);
    return _Scene90.Transformable.toCanvas(rects[node.index]);
  }
};
TreemapSeries.className = "TreemapSeries";
TreemapSeries.type = "treemap";

// packages/ag-charts-enterprise/src/series/treemap/treemapModule.ts
var {
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY6,
  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS4,
  DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES2,
  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR7,
  FONT_WEIGHT: FONT_WEIGHT5
} = _Theme41;
var TreemapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "treemap",
  moduleFactory: (ctx) => new TreemapSeries(ctx),
  tooltipDefaults: { range: "exact" },
  solo: true,
  themeTemplate: {
    series: {
      group: {
        label: {
          enabled: true,
          color: DEFAULT_LABEL_COLOUR7,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT5.NORMAL,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY6,
          spacing: 4
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 1,
        padding: 4,
        gap: 2,
        textAlign: "left"
      },
      tile: {
        label: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT5.NORMAL,
          fontSize: 18,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY6,
          wrapping: "on-space",
          overflowStrategy: "ellipsis",
          spacing: 2
        },
        secondaryLabel: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY6,
          wrapping: "never",
          overflowStrategy: "ellipsis"
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 0,
        padding: 3,
        gap: 1
      },
      // Override defaults
      highlightStyle: {
        group: {
          label: {
            color: DEFAULT_LABEL_COLOUR7
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        },
        tile: {
          label: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
          },
          secondaryLabel: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        }
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4);
    const groupFills = themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS4);
    const groupStrokes = themeTemplateParameters.get(DEFAULT_HIERARCHY_STROKES2);
    return {
      fills,
      strokes,
      colorRange: defaultColorRange,
      undocumentedGroupFills: groupFills,
      undocumentedGroupStrokes: groupStrokes
    };
  }
};

// packages/ag-charts-enterprise/src/series/waterfall/waterfallModule.ts
import { _Theme as _Theme43 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeries.ts
import { _ModuleSupport as _ModuleSupport163, _Scene as _Scene92, _Util as _Util94 } from "ag-charts-community";

// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeriesProperties.ts
import { _ModuleSupport as _ModuleSupport162, _Scene as _Scene91 } from "ag-charts-community";
var { DropShadow: DropShadow3, Label: Label15 } = _Scene91;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties5,
  BaseProperties: BaseProperties28,
  PropertiesArray: PropertiesArray5,
  SeriesTooltip: SeriesTooltip21,
  Validate: Validate75,
  BOOLEAN: BOOLEAN24,
  COLOR_STRING: COLOR_STRING31,
  FUNCTION: FUNCTION21,
  LINE_DASH: LINE_DASH22,
  NUMBER: NUMBER20,
  OBJECT: OBJECT38,
  OBJECT_ARRAY: OBJECT_ARRAY3,
  POSITIVE_NUMBER: POSITIVE_NUMBER32,
  RATIO: RATIO36,
  STRING: STRING38,
  UNION: UNION11
} = _ModuleSupport162;
var WaterfallSeriesTotal = class extends BaseProperties28 {
};
__decorateClass([
  Validate75(UNION11(["subtotal", "total"], "a total type"))
], WaterfallSeriesTotal.prototype, "totalType", 2);
__decorateClass([
  Validate75(NUMBER20)
], WaterfallSeriesTotal.prototype, "index", 2);
__decorateClass([
  Validate75(STRING38)
], WaterfallSeriesTotal.prototype, "axisLabel", 2);
var WaterfallSeriesItemTooltip = class extends BaseProperties28 {
};
__decorateClass([
  Validate75(FUNCTION21, { optional: true })
], WaterfallSeriesItemTooltip.prototype, "renderer", 2);
var WaterfallSeriesLabel = class extends Label15 {
  constructor() {
    super(...arguments);
    this.placement = "end";
    this.padding = 6;
  }
};
__decorateClass([
  Validate75(UNION11(["start", "end", "inside"], "a placement"))
], WaterfallSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesLabel.prototype, "padding", 2);
var WaterfallSeriesItem = class extends BaseProperties28 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.stroke = "#c16068";
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.cornerRadius = 0;
    this.shadow = new DropShadow3().set({ enabled: false });
    this.label = new WaterfallSeriesLabel();
    this.tooltip = new WaterfallSeriesItemTooltip();
  }
};
__decorateClass([
  Validate75(STRING38, { optional: true })
], WaterfallSeriesItem.prototype, "name", 2);
__decorateClass([
  Validate75(COLOR_STRING31)
], WaterfallSeriesItem.prototype, "fill", 2);
__decorateClass([
  Validate75(COLOR_STRING31)
], WaterfallSeriesItem.prototype, "stroke", 2);
__decorateClass([
  Validate75(RATIO36)
], WaterfallSeriesItem.prototype, "fillOpacity", 2);
__decorateClass([
  Validate75(RATIO36)
], WaterfallSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate75(LINE_DASH22)
], WaterfallSeriesItem.prototype, "lineDash", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesItem.prototype, "strokeWidth", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesItem.prototype, "cornerRadius", 2);
__decorateClass([
  Validate75(FUNCTION21, { optional: true })
], WaterfallSeriesItem.prototype, "itemStyler", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItem.prototype, "shadow", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItem.prototype, "label", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItem.prototype, "tooltip", 2);
var WaterfallSeriesConnectorLine = class extends BaseProperties28 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 2;
  }
};
__decorateClass([
  Validate75(BOOLEAN24)
], WaterfallSeriesConnectorLine.prototype, "enabled", 2);
__decorateClass([
  Validate75(COLOR_STRING31)
], WaterfallSeriesConnectorLine.prototype, "stroke", 2);
__decorateClass([
  Validate75(RATIO36)
], WaterfallSeriesConnectorLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate75(LINE_DASH22)
], WaterfallSeriesConnectorLine.prototype, "lineDash", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesConnectorLine.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate75(POSITIVE_NUMBER32)
], WaterfallSeriesConnectorLine.prototype, "strokeWidth", 2);
var WaterfallSeriesItems = class extends BaseProperties28 {
  constructor() {
    super(...arguments);
    this.positive = new WaterfallSeriesItem();
    this.negative = new WaterfallSeriesItem();
    this.total = new WaterfallSeriesItem();
  }
};
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItems.prototype, "positive", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItems.prototype, "negative", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesItems.prototype, "total", 2);
var WaterfallSeriesProperties = class extends AbstractBarSeriesProperties5 {
  constructor() {
    super(...arguments);
    this.item = new WaterfallSeriesItems();
    this.totals = new PropertiesArray5(WaterfallSeriesTotal);
    this.line = new WaterfallSeriesConnectorLine();
    this.tooltip = new SeriesTooltip21();
  }
};
__decorateClass([
  Validate75(STRING38)
], WaterfallSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate75(STRING38)
], WaterfallSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate75(STRING38, { optional: true })
], WaterfallSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate75(STRING38, { optional: true })
], WaterfallSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesProperties.prototype, "item", 2);
__decorateClass([
  Validate75(OBJECT_ARRAY3)
], WaterfallSeriesProperties.prototype, "totals", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesProperties.prototype, "line", 2);
__decorateClass([
  Validate75(OBJECT38)
], WaterfallSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeries.ts
var {
  adjustLabelPlacement,
  SeriesNodePickMode: SeriesNodePickMode16,
  fixNumericExtent: fixNumericExtent9,
  valueProperty: valueProperty16,
  keyProperty: keyProperty9,
  accumulativeValueProperty,
  trailingAccumulatedValueProperty,
  ChartAxisDirection: ChartAxisDirection24,
  getRectConfig: getRectConfig2,
  updateRect: updateRect2,
  checkCrisp: checkCrisp2,
  updateLabelNode: updateLabelNode3,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions3,
  collapsedStartingBarPosition: collapsedStartingBarPosition2,
  resetBarSelectionsFn: resetBarSelectionsFn3,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation7,
  resetLabelFn: resetLabelFn5,
  animationValidation: animationValidation9,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS2,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES2,
  isFiniteNumber: isFiniteNumber7,
  computeBarFocusBounds: computeBarFocusBounds6
} = _ModuleSupport163;
var { Rect: Rect9, motion: motion9 } = _Scene92;
var { sanitizeHtml: sanitizeHtml16, isContinuous } = _Util94;
var WaterfallSeries = class extends _ModuleSupport163.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS2,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES2,
      pickModes: [SeriesNodePickMode16.NEAREST_NODE, SeriesNodePickMode16.EXACT_SHAPE_MATCH],
      pathsPerSeries: ["connector"],
      hasHighlightedLabels: true,
      pathsZIndexSubOrderOffset: [-1, -1],
      animationResetFns: {
        datum: resetBarSelectionsFn3,
        label: resetLabelFn5
      }
    });
    this.properties = new WaterfallSeriesProperties();
    this.seriesItemTypes = /* @__PURE__ */ new Set(["positive", "negative", "total"]);
  }
  async processData(dataController) {
    const { xKey, yKey, totals } = this.properties;
    const { data = [] } = this;
    if (!this.properties.isValid() || !this.visible)
      return;
    const positiveNumber = (v) => isContinuous(v) && Number(v) >= 0;
    const negativeNumber = (v) => isContinuous(v) && Number(v) >= 0;
    const totalTypeValue = (v) => v === "total" || v === "subtotal";
    const propertyDefinition = { missingValue: void 0, invalidValue: void 0 };
    const dataWithTotals = [];
    const totalsMap = totals.reduce((result, total) => {
      const totalsAtIndex = result.get(total.index);
      if (totalsAtIndex) {
        totalsAtIndex.push(total);
      } else {
        result.set(total.index, [total]);
      }
      return result;
    }, /* @__PURE__ */ new Map());
    data.forEach((datum, i) => {
      dataWithTotals.push(datum);
      totalsMap.get(i)?.forEach((total) => dataWithTotals.push({ ...total.toJson(), [xKey]: total.axisLabel }));
    });
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      extraProps.push(animationValidation9());
    }
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const { processedData } = await this.requestDataModel(dataController, dataWithTotals, {
      props: [
        keyProperty9(xKey, xScaleType, { id: `xValue` }),
        accumulativeValueProperty(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrent`
        }),
        accumulativeValueProperty(yKey, yScaleType, {
          ...propertyDefinition,
          missingValue: 0,
          id: `yCurrentTotal`
        }),
        accumulativeValueProperty(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrentPositive`,
          validation: positiveNumber
        }),
        accumulativeValueProperty(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrentNegative`,
          validation: negativeNumber
        }),
        trailingAccumulatedValueProperty(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yPrevious`
        }),
        valueProperty16(yKey, yScaleType, { id: `yRaw` }),
        // Raw value pass-through.
        valueProperty16("totalType", "band", {
          id: `totalTypeValue`,
          missingValue: void 0,
          validation: totalTypeValue
        }),
        ...isContinuousX ? [_ModuleSupport163.SMALLEST_KEY_INTERVAL, _ModuleSupport163.LARGEST_KEY_INTERVAL] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.updateSeriesItemTypes();
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys],
      values
    } = processedData.domain;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef?.def.valueType === "category") {
        return keys;
      }
      const isDirectionY = direction === ChartAxisDirection24.Y;
      const isReversed = this.getCategoryAxis().isReversed();
      return this.padBandExtent(keys, isReversed !== isDirectionY);
    } else {
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent");
      const yExtent = values[yCurrIndex];
      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];
      return fixNumericExtent9(fixedYExtent);
    }
  }
  async createNodeData() {
    const { data, dataModel } = this;
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    if (!data || !categoryAxis || !valueAxis || !dataModel)
      return;
    const { line } = this.properties;
    const xScale = categoryAxis.scale;
    const yScale = valueAxis.scale;
    const barAlongX = this.getBarDirection() === ChartAxisDirection24.X;
    const barWidth = this.getBandwidth(categoryAxis) ?? 10;
    const categoryAxisReversed = categoryAxis.isReversed();
    if (this.processedData?.type !== "ungrouped")
      return;
    const context = {
      itemId: this.properties.yKey,
      nodeData: [],
      labelData: [],
      pointData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!this.visible)
      return context;
    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yRaw`);
    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);
    const pointData = [];
    const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent");
    const yPrevIndex = dataModel.resolveProcessedDataIndexById(this, "yPrevious");
    const yCurrTotalIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentTotal");
    function getValues(isTotal, isSubtotal, values) {
      if (isTotal || isSubtotal) {
        return {
          cumulativeValue: values[yCurrTotalIndex],
          trailingValue: isSubtotal ? trailingSubtotal : 0
        };
      }
      return {
        cumulativeValue: values[yCurrIndex],
        trailingValue: values[yPrevIndex]
      };
    }
    function getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue) {
      if (isTotal) {
        return cumulativeValue;
      }
      if (isSubtotal) {
        return (cumulativeValue ?? 0) - (trailingValue ?? 0);
      }
      return rawValue;
    }
    let trailingSubtotal = 0;
    const { xKey, yKey, xName, yName } = this.properties;
    this.processedData?.data.forEach(({ keys, datum, values }, dataIndex) => {
      const datumType = values[totalTypeIndex];
      const isSubtotal = this.isSubtotal(datumType);
      const isTotal = this.isTotal(datumType);
      const isTotalOrSubtotal = isTotal || isSubtotal;
      const xDatum = keys[xIndex];
      const x = Math.round(xScale.convert(xDatum));
      const rawValue = values[yRawIndex];
      const { cumulativeValue, trailingValue } = getValues(isTotal, isSubtotal, values);
      if (isTotalOrSubtotal) {
        trailingSubtotal = cumulativeValue ?? 0;
      }
      const currY = Math.round(yScale.convert(cumulativeValue));
      const trailY = Math.round(yScale.convert(trailingValue));
      const value = getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue);
      const isPositive = (value ?? 0) >= 0;
      const seriesItemType = this.getSeriesItemType(isPositive, datumType);
      const { fill, stroke: stroke2, strokeWidth, label } = this.getItemConfig(seriesItemType);
      const y = isPositive ? currY : trailY;
      const bottomY = isPositive ? trailY : currY;
      const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x,
        y: barAlongX ? x : Math.min(y, bottomY),
        width: barAlongX ? barHeight : barWidth,
        height: barAlongX ? barWidth : barHeight
      };
      const nodeMidPoint = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      };
      const pointY = isTotalOrSubtotal ? currY : trailY;
      const pixelAlignmentOffset = Math.floor(line.strokeWidth) % 2 / 2;
      const startY = categoryAxisReversed ? currY : pointY;
      const stopY = categoryAxisReversed ? pointY : currY;
      let startCoordinates;
      let stopCoordinates;
      if (barAlongX) {
        startCoordinates = {
          x: startY + pixelAlignmentOffset,
          y: rect.y
        };
        stopCoordinates = {
          x: stopY + pixelAlignmentOffset,
          y: rect.y + rect.height
        };
      } else {
        startCoordinates = {
          x: rect.x,
          y: startY + pixelAlignmentOffset
        };
        stopCoordinates = {
          x: rect.x + rect.width,
          y: stopY + pixelAlignmentOffset
        };
      }
      const pathPoint = {
        // lineTo
        x: categoryAxisReversed ? stopCoordinates.x : startCoordinates.x,
        y: categoryAxisReversed ? stopCoordinates.y : startCoordinates.y,
        // moveTo
        x2: categoryAxisReversed ? startCoordinates.x : stopCoordinates.x,
        y2: categoryAxisReversed ? startCoordinates.y : stopCoordinates.y,
        size: 0
      };
      pointData.push(pathPoint);
      const itemId = seriesItemType === "subtotal" ? "total" : seriesItemType;
      const labelText = this.getLabelText(
        label,
        { itemId, value, datum, xKey, yKey, xName, yName },
        (v) => isFiniteNumber7(v) ? v.toFixed(2) : String(v)
      );
      const nodeDatum = {
        index: dataIndex,
        series: this,
        itemId: seriesItemType,
        datum,
        cumulativeValue: cumulativeValue ?? 0,
        xValue: xDatum,
        yValue: value,
        yKey,
        xKey,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        midPoint: nodeMidPoint,
        fill,
        stroke: stroke2,
        strokeWidth,
        opacity: 1,
        label: {
          text: labelText,
          ...adjustLabelPlacement({
            isPositive: (value ?? -1) >= 0,
            isVertical: !barAlongX,
            placement: label.placement,
            padding: label.padding,
            rect
          })
        }
      };
      context.nodeData.push(nodeDatum);
      context.labelData.push(nodeDatum);
    });
    const connectorLinesEnabled = this.properties.line.enabled;
    if (yCurrIndex !== void 0 && connectorLinesEnabled) {
      context.pointData = pointData;
    }
    return context;
  }
  updateSeriesItemTypes() {
    const { dataModel, seriesItemTypes, processedData } = this;
    if (!dataModel || !processedData) {
      return;
    }
    seriesItemTypes.clear();
    const yPositiveIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentPositive");
    const yNegativeIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentNegative");
    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);
    const positiveDomain = processedData.domain.values[yPositiveIndex] ?? [];
    const negativeDomain = processedData.domain.values[yNegativeIndex] ?? [];
    if (positiveDomain.length > 0) {
      seriesItemTypes.add("positive");
    }
    if (negativeDomain.length > 0) {
      seriesItemTypes.add("negative");
    }
    const itemTypes = processedData?.domain.values[totalTypeIndex];
    if (!itemTypes) {
      return;
    }
    itemTypes.forEach((type) => {
      if (type === "total" || type === "subtotal") {
        seriesItemTypes.add("total");
      }
    });
  }
  isSubtotal(datumType) {
    return datumType === "subtotal";
  }
  isTotal(datumType) {
    return datumType === "total";
  }
  nodeFactory() {
    return new Rect9();
  }
  getSeriesItemType(isPositive, datumType) {
    return datumType ?? (isPositive ? "positive" : "negative");
  }
  getItemConfig(seriesItemType) {
    switch (seriesItemType) {
      case "positive": {
        return this.properties.item.positive;
      }
      case "negative": {
        return this.properties.item.negative;
      }
      case "subtotal":
      case "total": {
        return this.properties.item.total;
      }
    }
  }
  async updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data);
  }
  async updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { id: seriesId, ctx } = this;
    const {
      yKey,
      highlightStyle: { item: itemHighlightStyle }
    } = this.properties;
    const categoryAxis = this.getCategoryAxis();
    const crisp = checkCrisp2(
      categoryAxis?.scale,
      categoryAxis?.visibleRange,
      this.smallestDataInterval,
      this.largestDataInterval
    );
    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection24.X;
    datumSelection.each((rect, datum) => {
      const seriesItemType = datum.itemId;
      const {
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        cornerRadius,
        itemStyler,
        shadow: fillShadow
      } = this.getItemConfig(seriesItemType);
      const style = {
        fill: datum.fill,
        stroke: datum.stroke,
        fillOpacity,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        fillShadow,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        cornerRadius
      };
      const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
      const config = getRectConfig2({
        datum,
        isHighlighted: isHighlight,
        style,
        highlightStyle: itemHighlightStyle,
        itemStyler,
        seriesId,
        itemId: datum.itemId,
        ctx,
        value: datum.yValue,
        yKey
      });
      config.crisp = crisp;
      config.visible = visible;
      updateRect2(rect, config);
    });
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    if (labelData.length === 0) {
      return labelSelection.update([]);
    }
    const itemId = labelData[0].itemId;
    const { label } = this.getItemConfig(itemId);
    const data = label.enabled ? labelData : [];
    return labelSelection.update(data);
  }
  async updateLabelNodes(opts) {
    opts.labelSelection.each((textNode, datum) => {
      updateLabelNode3(textNode, this.getItemConfig(datum.itemId).label, datum.label);
    });
  }
  getTooltipHtml(nodeDatum) {
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    if (!this.properties.isValid() || !categoryAxis || !valueAxis) {
      return _ModuleSupport163.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { xKey, yKey, xName, yName, tooltip } = this.properties;
    const { datum, itemId, xValue, yValue } = nodeDatum;
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash = [],
      lineDashOffset,
      cornerRadius,
      name,
      itemStyler
    } = this.getItemConfig(itemId);
    let format;
    if (itemStyler) {
      format = this.ctx.callbackCache.call(itemStyler, {
        datum,
        xKey,
        yKey,
        fill,
        fillOpacity,
        stroke: stroke2,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius,
        highlighted: false,
        seriesId,
        itemId: nodeDatum.itemId
      });
    }
    const color = format?.fill ?? fill ?? "gray";
    const xString = sanitizeHtml16(categoryAxis.formatDatum(xValue));
    const yString = sanitizeHtml16(valueAxis.formatDatum(yValue));
    const isTotal = this.isTotal(itemId);
    const isSubtotal = this.isSubtotal(itemId);
    let ySubheading;
    if (isTotal) {
      ySubheading = "Total";
    } else if (isSubtotal) {
      ySubheading = "Subtotal";
    } else {
      ySubheading = name ?? yName ?? yKey;
    }
    const title = sanitizeHtml16(yName);
    const content = `<b>${sanitizeHtml16(xName ?? xKey)}</b>: ${xString}<br/><b>${sanitizeHtml16(ySubheading)}</b>: ${yString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      { seriesId, itemId, datum, xKey, yKey, xName, yName, color, title }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id, seriesItemTypes } = this;
    const legendData = [];
    const capitalise = (text2) => text2.charAt(0).toUpperCase() + text2.substring(1);
    seriesItemTypes.forEach((item) => {
      const { fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, name } = this.getItemConfig(item);
      legendData.push({
        legendType: "category",
        id,
        itemId: item,
        seriesId: id,
        enabled: true,
        label: { text: name ?? capitalise(item) },
        symbols: [{ marker: { fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth } }]
      });
    });
    return legendData;
  }
  toggleSeriesItem() {
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, contextData, paths }) {
    const fns = prepareBarAnimationFunctions3(collapsedStartingBarPosition2(this.isVertical(), this.axes, "normal"));
    motion9.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation7(this, "labels", this.ctx.animationManager, labelSelection);
    const { pointData } = contextData;
    if (!pointData)
      return;
    const [lineNode] = paths;
    if (this.isVertical()) {
      this.animateConnectorLinesVertical(lineNode, pointData);
    } else {
      this.animateConnectorLinesHorizontal(lineNode, pointData);
    }
  }
  animateConnectorLinesHorizontal(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis?.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v < v2 : (v, v2) => v > v2;
    const startX = valueAxis?.scale.convert(0);
    const endX = pointData.reduce(
      (end, point) => {
        if (compare(point.x, end)) {
          end = point.x;
        }
        return end;
      },
      valueAxisReversed ? Infinity : 0
    );
    const scale = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startX,
      to: endX,
      ease: _ModuleSupport163.Motion.easeOut,
      collapsable: false,
      onUpdate(pointX) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const x = scale(pointX, startX, endX, startX, point.x);
          const x2 = scale(pointX, startX, endX, startX, point.x2);
          if (index !== 0) {
            linePath.lineTo(x, point.y);
          }
          linePath.moveTo(x2, point.y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateConnectorLinesVertical(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis?.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v > v2 : (v, v2) => v < v2;
    const startY = valueAxis?.scale.convert(0);
    const endY = pointData.reduce(
      (end, point) => {
        if (compare(point.y, end)) {
          end = point.y;
        }
        return end;
      },
      valueAxisReversed ? 0 : Infinity
    );
    const scale = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startY,
      to: endY,
      ease: _ModuleSupport163.Motion.easeOut,
      collapsable: false,
      onUpdate(pointY) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const y = scale(pointY, startY, endY, startY, point.y);
          const y2 = scale(pointY, startY, endY, startY, point.y2);
          if (index !== 0) {
            linePath.lineTo(point.x, y);
          }
          linePath.moveTo(point.x2, y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetConnectorLinesPath(data);
  }
  async updatePaths(opts) {
    this.resetConnectorLinesPath({ contextData: opts.contextData, paths: opts.paths });
  }
  resetConnectorLinesPath({ contextData, paths }) {
    if (paths.length === 0) {
      return;
    }
    const [lineNode] = paths;
    this.updateLineNode(lineNode);
    const { path: linePath } = lineNode;
    linePath.clear(true);
    const { pointData } = contextData;
    if (!pointData) {
      return;
    }
    pointData.forEach((point, index) => {
      if (index !== 0) {
        linePath.lineTo(point.x, point.y);
      }
      linePath.moveTo(point.x2, point.y2);
    });
    lineNode.checkPathDirty();
  }
  updateLineNode(lineNode) {
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties.line;
    lineNode.setProperties({
      fill: void 0,
      stroke: stroke2,
      strokeWidth: this.getStrokeWidth(strokeWidth),
      strokeOpacity,
      lineDash,
      lineDashOffset,
      lineJoin: "round",
      pointerEvents: _Scene92.PointerEvents.None
    });
  }
  isLabelEnabled() {
    const { positive, negative, total } = this.properties.item;
    return positive.label.enabled || negative.label.enabled || total.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    return computeBarFocusBounds6(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
WaterfallSeries.className = "WaterfallSeries";
WaterfallSeries.type = "waterfall";

// packages/ag-charts-enterprise/src/series/waterfall/waterfallThemes.ts
import { _Theme as _Theme42 } from "ag-charts-community";
var itemTheme = {
  strokeWidth: 0,
  label: {
    enabled: false,
    fontStyle: void 0,
    fontWeight: _Theme42.FONT_WEIGHT.NORMAL,
    fontSize: 12,
    fontFamily: _Theme42.DEFAULT_FONT_FAMILY,
    color: _Theme42.DEFAULT_LABEL_COLOUR,
    formatter: void 0,
    placement: "end"
  }
};
var WATERFALL_SERIES_THEME = {
  series: {
    item: {
      positive: itemTheme,
      negative: itemTheme,
      total: itemTheme
    },
    line: {
      stroke: _Theme42.PALETTE_NEUTRAL_STROKE,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      strokeWidth: 2
    }
  },
  legend: {
    enabled: true,
    toggleSeries: false
  }
};

// packages/ag-charts-enterprise/src/series/waterfall/waterfallModule.ts
var WaterfallModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "waterfall",
  solo: true,
  moduleFactory: (ctx) => new WaterfallSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: _Theme43.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: _Theme43.POSITION.BOTTOM
    },
    {
      type: _Theme43.CARTESIAN_AXIS_TYPE.NUMBER,
      position: _Theme43.POSITION.LEFT
    }
  ],
  themeTemplate: WATERFALL_SERIES_THEME,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {
    if (userPalette === "user-indexed") {
      const { fills, strokes } = takeColors(colorsCount);
      return {
        line: { stroke: palette.neutral.stroke },
        item: {
          positive: {
            fill: fills[0],
            stroke: strokes[0]
          },
          negative: {
            fill: fills[1],
            stroke: strokes[1]
          },
          total: {
            fill: fills[2],
            stroke: strokes[2]
          }
        }
      };
    }
    return {
      line: { stroke: palette.neutral.stroke },
      item: {
        positive: {
          fill: palette.altUp.fill,
          stroke: palette.altUp.stroke,
          label: {
            color: _Theme43.DEFAULT_LABEL_COLOUR
          }
        },
        negative: {
          fill: palette.altDown.fill,
          stroke: palette.altDown.stroke,
          label: {
            color: _Theme43.DEFAULT_LABEL_COLOUR
          }
        },
        total: {
          fill: palette.neutral.fill,
          stroke: palette.neutral.stroke,
          label: {
            color: _Theme43.DEFAULT_LABEL_COLOUR
          }
        }
      }
    };
  }
};

// packages/ag-charts-enterprise/src/styles.css
var styles_default = `.ag-watermark{position:absolute;bottom:20px;right:25px;font-weight:700;font-family:Impact,sans-serif;font-size:19px;opacity:.7;animation:1s ease-out 3s ag-watermark-fadeout;color:#9b9b9b;pointer-events:none;&:before{content:"";display:block;height:40px;width:170px;background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;background-size:170px 40px}>span{padding-left:.7rem}}@keyframes ag-watermark-fadeout{0%{opacity:.5}to{opacity:0}}.ag-charts-popover{position:absolute;border:var(--ag-charts-popover-border);border-radius:var(--ag-charts-popover-border-radius);background:var(--ag-charts-popover-background-color);color:var(--ag-charts-popover-foreground-color);font-family:var(--ag-charts-font-family);font-size:var(--ag-charts-popover-font-size);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{display:grid;grid:auto-flow auto / 1fr;column-gap:12px;min-width:200px;font-size:var(--ag-charts-popover-font-size-small);--item-padding: 6px 12px;--icon-color: var(--ag-charts-popover-foreground-color)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:"";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-popover-hover-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-popover-active-color);background:var(--ag-charts-popover-active-background-color);color:var(--ag-charts-popover-active-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-dialog{display:flex;flex-direction:column;font-size:14px}.ag-charts-dialog__tabs{display:flex;flex-direction:column}.ag-charts-dialog__header{border-bottom:1px solid var(--ag-charts-border-color);display:flex;gap:var(--ag-charts-input-spacing)}.ag-charts-dialog__drag-handle{align-items:center;color:inherit;cursor:grab;display:flex;padding:1px 6px;text-align:center}.ag-charts-dialog__drag-handle--dragging{cursor:grabbing}.ag-charts-dialog__tab-button{background:none;border:0;border-bottom:2px solid transparent;border-radius:0;color:var(--ag-charts-dialog-tab-color--inactive);margin-bottom:-1px;padding:var(--ag-charts-input-padding) calc(var(--ag-charts-input-padding) / 2)}.ag-charts-dialog__tab-button:hover{background:none}.ag-charts-dialog__tab-button--active{border-color:currentColor;color:inherit}.ag-charts-dialog__drag-handle+.ag-charts-dialog__tab-button{margin-left:calc(var(--ag-charts-input-spacing) * -1)}.ag-charts-button.ag-charts-dialog__close-button{background:none;border:0;margin-left:auto;padding:1px 6px}.ag-charts-dialog__close-button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-dialog__tab-panel{display:none;flex-direction:column;gap:calc(var(--ag-charts-input-spacing) * 2);margin:0 calc(var(--ag-charts-input-spacing) * 2);padding:calc(var(--ag-charts-input-spacing) * 2) 0}.ag-charts-dialog__tab-panel--active{display:flex}.ag-charts-dialog__input-group-line{display:flex;gap:18px}.ag-charts-dialog__input-group{align-items:center;display:flex;font-size:12px}.ag-charts-dialog__input-group-label{color:var(--ag-charts-dialog-input-group-label-color);margin-right:5px}.ag-charts-dialog__input-group-label[for]{cursor:pointer}.ag-charts-dialog__button{border-radius:0;margin-right:-1px}.ag-charts-dialog__button.ag-charts-dialog__button--active{background:var(--ag-charts-input-background-color--active);border-color:var(--ag-charts-input-border-color--active);color:var(--ag-charts-input-color--active);z-index:var(--input-layer-active)}.ag-charts-dialog__button:first-child,.ag-charts-dialog__input-group-label+.ag-charts-dialog__button{border-bottom-left-radius:var(--ag-charts-input-border-radius);border-top-left-radius:var(--ag-charts-input-border-radius)}.ag-charts-dialog__button:last-child{border-bottom-right-radius:var(--ag-charts-input-border-radius);border-top-right-radius:var(--ag-charts-input-border-radius)}.ag-charts-dialog__color-picker-button{--color: #000;background:var(--color);border:none;color:transparent;height:26px;width:26px}.ag-charts-dialog__color-picker-button:hover{background:var(--color)}.ag-charts-color-picker{width:190px;padding:8px;--h: 0;--s: 0;--v: 0;--a: 0;--color: #000;--color-a: #000;--thumb-size: 18px;--inner-width: 172px;--track-height: 12px;--palette-height: 136px;--checker: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><path d="M0 0H2V4H4V2H0Z" fill="%23b2b2b2"/></svg>')}.ag-charts-color-picker__content{display:flex;flex-direction:column}.ag-charts-color-picker__palette{position:relative;width:100%;height:var(--palette-height);margin-bottom:8px;background:linear-gradient(to bottom,#0000,#000),linear-gradient(to right,#fff,#fff0) hsl(var(--h),100%,50%);border-radius:6px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__palette:after{content:"";position:absolute;display:block;top:calc(var(--thumb-size) * -.5 + (1 - var(--v)) * 100%);left:calc(var(--thumb-size) * -.5 + var(--s) * 100%);background:var(--color);width:var(--thumb-size);height:var(--thumb-size);border-radius:99px;box-shadow:var(--box-shadow);--box-shadow: inset 0 0 0 3px white, inset 0 0 1px 3px #0006, 0 0 5px #00000038}.ag-charts-color-picker__palette:focus-visible:after{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),0 0 0 2px #fff8,var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input,.ag-charts-color-picker__alpha-input{-webkit-appearance:none;display:block;position:relative;padding:0;margin:0 calc(var(--inset) * -1);border:0;height:var(--thumb-size);width:auto;background:transparent;--inset: calc((var(--thumb-size) - var(--track-height)) / 2)}.ag-charts-color-picker__hue-input::-webkit-slider-thumb,.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{-webkit-appearance:none;width:var(--thumb-size);height:var(--thumb-size);border-radius:99px;box-shadow:var(--box-shadow);--box-shadow: inset 0 0 0 3px white, inset 0 0 1px 3px #0006, 0 0 5px #00000038;transform:translateZ(0)}.ag-charts-color-picker__hue-input::-webkit-slider-thumb{background:hsl(var(--h),100%,50%)}.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{background:transparent}.ag-charts-color-picker__alpha-input--opaque::-webkit-slider-thumb{background:var(--color)}.ag-charts-color-picker__hue-input:focus-visible::-webkit-slider-thumb,.ag-charts-color-picker__alpha-input:focus-visible::-webkit-slider-thumb{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input:before,.ag-charts-color-picker__alpha-input:before{position:absolute;content:"";display:block;top:calc(50% - var(--track-height) / 2);left:var(--inset);right:var(--inset);height:var(--track-height);border-radius:99px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__hue-input{margin-bottom:4px}.ag-charts-color-picker__hue-input:before{background:linear-gradient(to right,red,red calc((100% - var(--track-height)) * 0 / 6 + var(--track-height) / 2),#ff0 calc((100% - var(--track-height)) * 1 / 6 + var(--track-height) / 2),#0f0 calc((100% - var(--track-height)) * 2 / 6 + var(--track-height) / 2),#0ff calc((100% - var(--track-height)) * 3 / 6 + var(--track-height) / 2),#00f calc((100% - var(--track-height)) * 4 / 6 + var(--track-height) / 2),#f0f calc((100% - var(--track-height)) * 5 / 6 + var(--track-height) / 2),red calc((100% - var(--track-height)) * 6 / 6 + var(--track-height) / 2))}.ag-charts-color-picker__alpha-input{margin-bottom:7px}.ag-charts-color-picker__alpha-input:before{background:linear-gradient(to right,transparent,var(--color)),var(--checker) top left / 4px 4px}.ag-charts-color-picker__color-field{display:flex;border:var(--ag-charts-border);background:var(--ag-charts-background-color);border-radius:4px;overflow:hidden}.ag-charts-color-picker__color-field:has(:focus-visible){border-color:var(--ag-charts-active-color);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__color-label{width:16px;height:16px;margin:7px 0 7px 7px;color:transparent;background:linear-gradient(to right,var(--color-a),var(--color-a)),var(--checker) top left / 4px 4px;border-radius:2px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__color-input{flex:1;min-width:0;padding:7px 7px 7px 8px;border:0;margin:0;color:inherit;background:transparent;font-variant:tabular-nums}.ag-charts-color-picker__color-input:focus-visible{border:none;outline:none}.ag-charts-annotations__axis-button-wrapper{position:absolute;left:0;top:0;user-select:none;font:16px Verdana,sans-serif;overflow:hidden;white-space:nowrap;z-index:var(--ag-charts-layer-annotations);box-sizing:border-box}.ag-charts-annotations__axis-button-wrapper--hidden{display:none}.ag-charts-annotations__axis-button{cursor:pointer;border:none;border-radius:2px;padding:0;line-height:16px;background-color:var(--ag-charts-axis-label-background-color);color:var(--ag-charts-axis-label-color)}.ag-charts-annotations__axis-button:hover{opacity:.8;color:var(--ag-charts-axis-label-color)}.annotations__text-size{width:34px;min-width:0;border-top-left-radius:0;border-top-right-radius:0;--item-padding: 4px 8px}.annotations__line-stroke-width{min-width:0;--item-padding: 6px;column-gap:var(--item-padding)}.annotations__line-style-type{min-width:0;--item-padding: 6px;column-gap:0}.ag-charts-dialog--annotation-settings{width:289px}.ag-charts-dialog--annotation-settings .ag-charts-textarea{height:calc(10px * 2 + var(--line-height) * 1em * 3 + 2px);overflow-y:auto;resize:vertical}.ag-charts-annotations-text-size-menu{border-top-left-radius:0;border-top-right-radius:0;min-width:0;width:34px;--item-padding: 4px 8px}.ag-chart-context-menu{background:#f8f8f8;border:1px solid #babfc7;border-radius:5px;box-shadow:0 1px 4px 1px #babfc766;color:#181d1f;font:13px Verdana,sans-serif;transition:transform .1s ease;white-space:nowrap;z-index:var(--ag-charts-layer-ui-overlay)}.ag-chart-context-menu.ag-charts-dark-context-menu{color:#fff;background:#15181c}.ag-chart-context-menu__cover{position:fixed;left:0;top:0}.ag-chart-context-menu__menu{display:flex;flex-direction:column;padding:.5em 0}.ag-chart-context-menu__menu:focus{outline:none}.ag-chart-context-menu__item{background:none;border:none;box-sizing:border-box;font:inherit;padding:.5em 1em;text-align:left;-webkit-appearance:none;-moz-appearance:none}.ag-chart-context-menu__item.ag-charts-dark-context-menu{color:#fff}.ag-chart-context-menu__item:focus{background:#2196f31a}.ag-chart-context-menu__item:focus.ag-charts-dark-context-menu{background:#2196f31a}.ag-chart-context-menu__item:active{background:#2196f333}.ag-chart-context-menu__item:active.ag-charts-dark-context-menu{background:#2196f31a}.ag-chart-context-menu__item:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-chart-context-menu__item[aria-disabled=true]{border:none;opacity:.5;text-align:left}.ag-chart-context-menu__item[aria-disabled=true]:focus{background:inherit;cursor:inherit}.ag-chart-context-menu__divider{margin:5px 0;background:#babfc7;height:1px}.ag-chart-context-menu__divider.ag-charts-dark-context-menu{background:#2196f31a}.ag-crosshair-label{position:absolute;left:0;top:0;user-select:none;pointer-events:none;font:12px Verdana,sans-serif;overflow:hidden;white-space:nowrap;z-index:var(--ag-charts-layer-crosshair);box-sizing:border-box}.ag-crosshair-label-content{padding:0 8px;border-radius:2px;line-height:20px;background-color:var(--ag-charts-axis-label-background-color);color:var(--ag-charts-axis-label-color)}.ag-crosshair-label-hidden{visibility:hidden!important}.ag-charts-text-input{position:absolute}.ag-charts-text-input__textarea{display:block;height:100%;width:100%;border:0;background:none;line-height:1.38;transform:translateY(.09em)}.ag-charts-text-input__textarea[placeholder]:empty:before{content:attr(placeholder);color:var(--ag-charts-input-placeholder-color);font-weight:400}.ag-charts-text-input__textarea[placeholder]:not(:empty):before{content:""}
`;

// packages/ag-charts-enterprise/src/setup.ts
function setupEnterpriseModules() {
  _ModuleSupport164.moduleRegistry.register(
    AngleCategoryAxisModule,
    AngleNumberAxisModule,
    AnimationModule,
    AnnotationsModule,
    BackgroundModule,
    ForegroundModule,
    BoxPlotModule,
    CandlestickModule,
    ChordModule,
    OhlcModule,
    BulletModule,
    ChartToolbarModule,
    ContextMenuModule,
    CrosshairModule,
    DataSourceModule,
    ErrorBarsModule,
    LinearGaugeModule,
    MapLineModule,
    MapLineBackgroundModule,
    MapMarkerModule,
    MapShapeModule,
    MapShapeBackgroundModule,
    NavigatorModule,
    StatusBarModule,
    GradientLegendModule,
    HeatmapModule,
    NightingaleModule,
    OrdinalTimeAxisModule,
    RadarAreaModule,
    RadarLineModule,
    RadialBarModule,
    RadialColumnModule,
    RadiusCategoryAxisModule,
    RadialGaugeModule,
    RadiusNumberAxisModule,
    RangeBarModule,
    RangeAreaModule,
    SankeyModule,
    SunburstModule,
    SyncModule,
    TreemapModule,
    WaterfallModule,
    ZoomModule
  );
  _ModuleSupport164.enterpriseModule.isEnterprise = true;
  _ModuleSupport164.enterpriseModule.styles = styles_default;
  _ModuleSupport164.enterpriseModule.licenseManager = (options) => new LicenseManager(
    options.container?.ownerDocument ?? (typeof document === "undefined" ? void 0 : document)
  );
  _ModuleSupport164.enterpriseModule.injectWatermark = injectWatermark;
}

// packages/ag-charts-enterprise/src/main.ts
export * from "ag-charts-community";
setupEnterpriseModules();
export {
  AgCharts,
  time
};
